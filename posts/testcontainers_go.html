<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Testing go code with real database using testcontainers</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/b53cc6ef9e9e352d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b53cc6ef9e9e352d.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-959cc2ac3c742fb4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ec0fdebf93e8fc69.js" defer=""></script><script src="/_next/static/chunks/996-372da0b0d3708a80.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-959ba1136e063a38.js" defer=""></script><script src="/_next/static/sW-wDccd-ZCyzGzfnKrfa/_buildManifest.js" defer=""></script><script src="/_next/static/sW-wDccd-ZCyzGzfnKrfa/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><h1 id="top">Taras Bunyk</h1><nav><a href="/">Home</a><a href="http://bunyk.github.io/mandala/">Snowflake drawing</a><a href="/resume">Resume</a><a href="https://bunyk.wordpress.com/">Old blog (in Ukrainian)</a></nav><article><h1>Testing go code with real database using testcontainers</h1><div><em>Published: 2022-06-29T08:34:06.000Z</em></div><div><p>Unit tests are a good thing. They run fast, and allow you to be more confident that you have not broken logic that they verify. If you find a bug, and write a test that reproduces it, you could make sure that bug will not return. They try to, for example, when some developer that comes after you wants to simplify your code, and misses a corner case.</p>
<p>But unit tests usually test some unit (usually function) of your program in isolation, therefore the name. They mock all the dependencies, including database connection. That has its advantages, but also downsides. Sometimes, your back-end code is just a glue between HTTP and database,  and a lot of your logic is implemented directly in the database. Bugs could hide in the database and in the interface to database (especially if you try to build query dynamically). And it would be nice to be able to automatically verify that your queries will work with your DB.</p>
<p>To do that in Python world, you usually have some ORM, which connects to PostgreSQL on production, and to in-memory SQLite when running tests. ORM generates different SQL for that cases, but if you are not running super complex queries, you could be confident enough that behavior of code will be the similar in tests and in live environment.</p>
<p>I though that similar thing is impossible in Go where it's not common to use ORM. Until my teammate with Java background introduced <a href="https://golang.testcontainers.org/"><code>testcontainers</code></a> library to our projects. Here is a <a href="https://engineering.zalando.com/posts/2021/02/integration-tests-with-testcontainers.html">post about testcontainers for Java devs on engineering blog of my company</a>.</p>
<p>Now let's see how to write automated tests that verify the correct end to end behavior of an app, by creating a PostgreSQL DB in a container.</p>
<h2 id="example-service">Example service</h2>
<p>Let's imagine that we are building the rating service. It stores products (or restaurants, blog articles, Stack Overflow comments, whatever). And users leave feedback in a form of a like or dislike. It will have following, simplified API:</p>
<ul>
<li><code>POST /products {name: 'Go'}</code> - creates a new product with given name</li>
<li><code>GET /products</code> returns products ordered by rating <code>[{id: 1, name: 'postgres' likes: 20, dislikes: 0}, {id: 2, name: 'MariaDB' likes: 15, dislikes: 6}, ...]</code></li>
<li><code>POST /products/:id:/like</code> - adds a new like for a product</li>
<li><code>POST /products/:id:/dislike</code> - adds a dislike</li>
</ul>
<p>When computing rating, we would use <a href="https://en.wikipedia.org/wiki/Rule_of_succession">rule of succession</a> to make sure that product with one like (100% of likes), is not rated higher than product with 99 likes and 1 dislike (99% of likes). For that, we assume that there are always one additional "prior" like and one "prior" dislike for each product. So products with zero explicit likes or dislikes, have 50% positive rating, and having one like increases that percent to 66%. The more feedback the product gets, the less impact this prior implicit feedback has on final rating.</p>
<p>For the sake of simplicity, we skip authorization and other details like getting product by id, pagination, or limiting number of likes per product per user. So we could implement functionality quickly and focus on building tests.</p>
<h2 id="implementation">Implementation</h2>
<p>Start a new go project called <code>postest</code>, and add two dependencies:</p>
<pre><code class="hljs language-bash"><span class="hljs-built_in">mkdir</span> postest
go mod init example/postest
go get github.com/gin-gonic/gin <span class="hljs-comment"># for API</span>
go get github.com/jackc/pgx/v4  <span class="hljs-comment"># for storage</span>
<span class="hljs-built_in">mkdir</span> api
<span class="hljs-built_in">mkdir</span> store</code></pre>
<p>Database schema has just one table that looks like this:</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> products (
	id SERIAL <span class="hljs-keyword">PRIMARY</span> KEY,
	name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
	likes <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>,
	dislikes <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>
)</code></pre>
<p>And when we select from it, we will use rule of succession to order results like this:</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> (likes <span class="hljs-operator">+</span> <span class="hljs-number">1</span>) <span class="hljs-operator">/</span> (likes <span class="hljs-operator">+</span> dislikes <span class="hljs-operator">+</span> <span class="hljs-number">2</span>) <span class="hljs-keyword">DESC</span></code></pre>
<p>So if you have apples with 1 like and 0 dislikes, and bananas with 9 likes and 1 dislike, you will get value (1 + 1) / (1 + 0 + 2) = 0.666 for apples, and (9 + 1) / (9 + 1 + 2) = 0.833 for bananas, so bananas will go higher in ranking.</p>
<p>Now, below I'll just put listings of code for <code>api</code> and <code>store</code> packages, and <code>main.go</code>, so you could follow along. If you just want to read - scroll until the <a href="#testing">testing section</a>.</p>
<pre><code class="hljs language-go"><span class="hljs-keyword">package</span> api

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"net/http"</span>

	<span class="hljs-string">"github.com/gin-gonic/gin"</span>

	<span class="hljs-string">"example/postest/store"</span>
)

<span class="hljs-keyword">type</span> api <span class="hljs-keyword">struct</span> {
	store store.Store
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(s store.Store)</span></span> *gin.Engine {
	a := api{store: s}
	r := gin.Default()
	r.GET(<span class="hljs-string">"/products"</span>, a.getProducts)
	r.POST(<span class="hljs-string">"/products"</span>, a.createProduct)
	r.POST(<span class="hljs-string">"/products/:id/like"</span>, a.likeProduct)
	r.POST(<span class="hljs-string">"/products/:id/dislike"</span>, a.dislikeProduct)
	<span class="hljs-keyword">return</span> r
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a api)</span></span> getProducts(c *gin.Context) {
	products, err := a.store.GetProducts(c.Request.Context())
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		c.JSON(http.StatusInternalServerError, gin.H{<span class="hljs-string">"error"</span>: err.Error()})
		<span class="hljs-keyword">return</span>
	}
	c.IndentedJSON(http.StatusOK, products)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a api)</span></span> createProduct(c *gin.Context) {
	<span class="hljs-keyword">var</span> p store.Product
	<span class="hljs-keyword">if</span> err := c.ShouldBindJSON(&#x26;p); err != <span class="hljs-literal">nil</span> {
		c.JSON(http.StatusBadRequest, gin.H{<span class="hljs-string">"error"</span>: err.Error()})
		<span class="hljs-keyword">return</span>
	}
	p, err := a.store.CreateProduct(c.Request.Context(), p)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		c.JSON(http.StatusInternalServerError, gin.H{<span class="hljs-string">"error"</span>: err.Error()})
		<span class="hljs-keyword">return</span>
	}
	c.JSON(http.StatusCreated, p)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a api)</span></span> likeProduct(c *gin.Context) {
	a.rateProduct(c, <span class="hljs-literal">true</span>)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a api)</span></span> dislikeProduct(c *gin.Context) {
	a.rateProduct(c, <span class="hljs-literal">false</span>)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a api)</span></span> rateProduct(c *gin.Context, like <span class="hljs-type">bool</span>) {
	id := c.Param(<span class="hljs-string">"id"</span>)
	<span class="hljs-keyword">if</span> err := a.store.RateProduct(c.Request.Context(), id, like); err != <span class="hljs-literal">nil</span> {
		c.JSON(http.StatusInternalServerError, gin.H{<span class="hljs-string">"error"</span>: err.Error()})
		<span class="hljs-keyword">return</span>
	}
	c.Status(http.StatusOK)
}</code></pre>
<pre><code class="hljs language-go"><span class="hljs-keyword">package</span> store

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"context"</span>
	<span class="hljs-string">"fmt"</span>

	<span class="hljs-string">"github.com/jackc/pgx/v4/pgxpool"</span>
)

<span class="hljs-keyword">type</span> Product <span class="hljs-keyword">struct</span> {
	ID       <span class="hljs-type">int</span>    <span class="hljs-string">`json:"id"`</span>
	Name     <span class="hljs-type">string</span> <span class="hljs-string">`json:"name"`</span>
	Likes    <span class="hljs-type">int</span>    <span class="hljs-string">`json:"likes"`</span>
	Dislikes <span class="hljs-type">int</span>    <span class="hljs-string">`json:"dislikes"`</span>
}

<span class="hljs-keyword">type</span> Store <span class="hljs-keyword">struct</span> {
	db *pgxpool.Pool
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(dsn <span class="hljs-type">string</span>)</span></span> (s Store, err <span class="hljs-type">error</span>) {
	s.db, err = pgxpool.Connect(context.Background(), dsn)
	<span class="hljs-keyword">return</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Store)</span></span> Migrate() <span class="hljs-type">error</span> {
	_, err := s.db.Exec(context.Background(), <span class="hljs-string">`
		CREATE TABLE IF NOT EXISTS products (
			id SERIAL PRIMARY KEY,
			name VARCHAR(255) NOT NULL,
			likes INT NOT NULL DEFAULT 0,
			dislikes INT NOT NULL DEFAULT 0
		)
	`</span>)
	<span class="hljs-keyword">return</span> err
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Store)</span></span> GetProducts(ctx context.Context) ([]Product, <span class="hljs-type">error</span>) {
	<span class="hljs-keyword">var</span> products []Product
	rows, err := s.db.Query(ctx, <span class="hljs-string">`
		SELECT id, name, likes, dislikes
		FROM products
		ORDER BY (likes + 1) / (likes + dislikes + 2) DESC
	`</span>)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
	}
	<span class="hljs-keyword">defer</span> rows.Close()
	<span class="hljs-keyword">for</span> rows.Next() {
		<span class="hljs-keyword">var</span> p Product
		err = rows.Scan(&#x26;p.ID, &#x26;p.Name, &#x26;p.Likes, &#x26;p.Dislikes)
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
		}
		products = <span class="hljs-built_in">append</span>(products, p)
	}
	<span class="hljs-keyword">return</span> products, <span class="hljs-literal">nil</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Store)</span></span> CreateProduct(ctx context.Context, p Product) (Product, <span class="hljs-type">error</span>) {
	err := s.db.QueryRow(context.Background(), <span class="hljs-string">"INSERT INTO products (name) VALUES ($1) RETURNING id"</span>, p.Name).Scan(&#x26;p.ID)
	<span class="hljs-keyword">return</span> p, err
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Store)</span></span> RateProduct(ctx context.Context, id <span class="hljs-type">string</span>, like <span class="hljs-type">bool</span>) <span class="hljs-type">error</span> {
	field := <span class="hljs-string">"dislikes"</span>
	<span class="hljs-keyword">if</span> like {
		field = <span class="hljs-string">"likes"</span>
	}
	r, err := s.db.Exec(ctx, fmt.Sprintf(<span class="hljs-string">"UPDATE products SET %s = %s + 1 WHERE id = $1"</span>, field, field), id)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> err
	}
	<span class="hljs-keyword">if</span> n := r.RowsAffected(); n == <span class="hljs-number">0</span> {
		<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">"no product with id %s"</span>, id)
	}
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}</code></pre>
<p>And in case we would want to run it, here is the <code>main.go</code> file:</p>
<pre><code class="hljs language-go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"log"</span>

	<span class="hljs-string">"example/postest/api"</span>
	<span class="hljs-string">"example/postest/store"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	s, err := store.New(<span class="hljs-string">"postgres://reviews_user:pass@localhost:5432/reviews"</span>)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		log.Fatal(err)
	}
	err = s.Migrate()
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		log.Fatal(err)
	}
	r := api.New(s)

	log.Println(<span class="hljs-string">"Listening on :8080"</span>)
	r.Run(<span class="hljs-string">":8080"</span>)
}</code></pre>
<h2 id="testing">Testing</h2>
<p>Now, how to test it? When we test manually, we connect to some database, like in <code>main.go</code> example above, and try different requests. We will do similar from our automated tests.</p>
<p>But first, create yet another package to aid with our test database container creation. Le'ts call it <code>testdb</code>. Testcontainers help to create any docker containers from Go, <code>testdb</code> will create PostgreSQL DB test container exactly for our needs.</p>
<pre><code class="hljs language-go"><span class="hljs-keyword">package</span> testdb

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"context"</span>
	<span class="hljs-string">"fmt"</span>

	<span class="hljs-string">"github.com/testcontainers/testcontainers-go"</span>
	<span class="hljs-string">"github.com/testcontainers/testcontainers-go/wait"</span>
)

<span class="hljs-keyword">type</span> TestDBContainer <span class="hljs-keyword">struct</span> {
	testcontainers.Container
	context context.Context
	URI     <span class="hljs-type">string</span>
}

<span class="hljs-comment">// logConsumer is log consumer to propagate logs of container to stdout</span>
<span class="hljs-keyword">type</span> TestLogConsumer <span class="hljs-keyword">struct</span>{}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g TestLogConsumer)</span></span> Accept(l testcontainers.Log) {
	fmt.Println(l.LogType, <span class="hljs-type">string</span>(l.Content))
}

<span class="hljs-keyword">var</span> logConsumer TestLogConsumer

<span class="hljs-comment">// We hard-code credentials here, since it's for one-time DB</span>
<span class="hljs-comment">// so they are not very important</span>
<span class="hljs-keyword">const</span> (
	db       = <span class="hljs-string">"test_db"</span>
	user     = <span class="hljs-string">"test_user"</span>
	password = <span class="hljs-string">"test_password"</span>
)

<span class="hljs-comment">// Create container with our test database</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(ctx context.Context)</span></span> (*TestDBContainer, <span class="hljs-type">error</span>) {
	<span class="hljs-comment">// ContainerRequest describes Docker container we want to run</span>
	req := testcontainers.ContainerRequest{
		Image:        <span class="hljs-string">"postgres:latest"</span>,
		ExposedPorts: []<span class="hljs-type">string</span>{<span class="hljs-string">"5432/tcp"</span>, <span class="hljs-string">"8080/tcp"</span>},
		Env: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>{
			<span class="hljs-string">"POSTGRES_DB"</span>:       db,
			<span class="hljs-string">"POSTGRES_USER"</span>:     user,
			<span class="hljs-string">"POSTGRES_PASSWORD"</span>: password,
		},
		WaitingFor: wait.ForLog(<span class="hljs-string">`listening on IPv4 address "0.0.0.0", port 5432`</span>),
	}
	<span class="hljs-comment">// Run container</span>
	container, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
		ContainerRequest: req,
		Started:          <span class="hljs-literal">true</span>, <span class="hljs-comment">// block this call until container is started</span>
	})
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
	}

	<span class="hljs-comment">// use logConsumer to print logs to stdout</span>
	err = container.StartLogProducer(ctx)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
	}
	container.FollowOutput(logConsumer)

	<span class="hljs-comment">// Get externally mapped port</span>
	mappedPort, err := container.MappedPort(ctx, <span class="hljs-string">"5432"</span>)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
	}

	<span class="hljs-comment">// Get container host</span>
	hostIP, err := container.Host(ctx)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
	}

	<span class="hljs-comment">// Build a DB URL connection string</span>
	uri := fmt.Sprintf(<span class="hljs-string">"postgres://%s:%s@%s:%s/%s"</span>, user, password, hostIP, mappedPort.Port(), db)

	<span class="hljs-keyword">return</span> &#x26;TestDBContainer{
		Container: container,
		URI:       uri,
		context:   ctx,
	}, <span class="hljs-literal">nil</span>
}

<span class="hljs-comment">// Stop the container</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TestDBContainer)</span></span> Close() <span class="hljs-type">error</span> {
	<span class="hljs-keyword">return</span> t.Container.Terminate(t.context)
}</code></pre>
<p>And don't forget to install testcontainers package itself:</p>
<pre><code class="hljs language-bash">go get github.com/testcontainers/testcontainers-go</code></pre>
<p>Now, let's add tests in <code>api/api_test.go</code>:</p>
<pre><code class="hljs language-go"><span class="hljs-keyword">package</span> api

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"context"</span>
	<span class="hljs-string">"io"</span>
	<span class="hljs-string">"io/ioutil"</span>
	<span class="hljs-string">"log"</span>
	<span class="hljs-string">"net/http"</span>
	<span class="hljs-string">"net/http/httptest"</span>
	<span class="hljs-string">"strings"</span>
	<span class="hljs-string">"testing"</span>
	<span class="hljs-string">"time"</span>

	<span class="hljs-string">"example/postest/store"</span>
	<span class="hljs-string">"example/postest/testdb"</span>

	<span class="hljs-string">"github.com/stretchr/testify/assert"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCreationAndRatingFlow</span><span class="hljs-params">(t *testing.T)</span></span> {
	<span class="hljs-keyword">var</span> err <span class="hljs-type">error</span>
	ctx, _ := context.WithTimeout(context.Background(), time.Second*<span class="hljs-number">600</span>)
	testDB, err := testdb.New(ctx)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		log.Fatal(err)
	}
	s, err := store.New(testDB.URI)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		log.Fatal(err)
	}
	err = s.Migrate()
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		log.Fatal(err)
	}

	a := New(s)
	h := a.Handler()

	body, status, err := doRequest(h, <span class="hljs-string">"GET"</span>, <span class="hljs-string">"/products"</span>, <span class="hljs-string">""</span>)
	assert.Nil(t, err)
	assert.Equal(t, http.StatusOK, status)
	assert.JSONEq(t, <span class="hljs-string">`[]`</span>, body)

	<span class="hljs-comment">// Test that product is created:</span>
	body, status, err = doRequest(h, <span class="hljs-string">"POST"</span>, <span class="hljs-string">"/products"</span>, <span class="hljs-string">`{"name":"apple"}`</span>)
	assert.Nil(t, err)
	assert.Equal(t, http.StatusCreated, status)
	assert.JSONEq(t, <span class="hljs-string">`{"id":1,"name":"apple","likes":0,"dislikes":0}`</span>, body)

	body, status, err = doRequest(h, <span class="hljs-string">"POST"</span>, <span class="hljs-string">"/products"</span>, <span class="hljs-string">`{"name":"banana"}`</span>)
	assert.Nil(t, err)
	assert.Equal(t, http.StatusCreated, status)
	assert.JSONEq(t, <span class="hljs-string">`{"id":2,"name":"banana","likes":0,"dislikes":0}`</span>, body)

	<span class="hljs-comment">// Now should return two products:</span>
	body, status, err = doRequest(h, <span class="hljs-string">"GET"</span>, <span class="hljs-string">"/products"</span>, <span class="hljs-string">""</span>)
	assert.Nil(t, err)
	assert.Equal(t, http.StatusOK, status)
	assert.JSONEq(t, <span class="hljs-string">`[
		{"id":1,"name":"apple","likes":0,"dislikes":0},
		{"id":2,"name":"banana","likes":0,"dislikes":0}
	]`</span>, body)

	<span class="hljs-comment">// Like banana:</span>
	body, status, err = doRequest(h, <span class="hljs-string">"POST"</span>, <span class="hljs-string">"/products/2/like"</span>, <span class="hljs-string">""</span>)
	assert.Nil(t, err)
	assert.Equal(t, http.StatusOK, status)

	<span class="hljs-comment">// Now banana should be at top:</span>
	body, status, err = doRequest(h, <span class="hljs-string">"GET"</span>, <span class="hljs-string">"/products"</span>, <span class="hljs-string">""</span>)
	assert.JSONEq(t, <span class="hljs-string">`[
		{"id":2,"name":"banana","likes":1,"dislikes":0},
		{"id":1,"name":"apple","likes":0,"dislikes":0}
	]`</span>, body)

	<span class="hljs-comment">// Like apple twice:</span>
	_, _, _ = doRequest(h, <span class="hljs-string">"POST"</span>, <span class="hljs-string">"/products/1/like"</span>, <span class="hljs-string">""</span>)
	_, _, _ = doRequest(h, <span class="hljs-string">"POST"</span>, <span class="hljs-string">"/products/1/like"</span>, <span class="hljs-string">""</span>)

	<span class="hljs-comment">// Now apple should be on top again:</span>
	body, status, err = doRequest(h, <span class="hljs-string">"GET"</span>, <span class="hljs-string">"/products"</span>, <span class="hljs-string">""</span>)
	assert.JSONEq(t, <span class="hljs-string">`[
		{"id":1,"name":"apple","likes":2,"dislikes":0},
		{"id":2,"name":"banana","likes":1,"dislikes":0}
	]`</span>, body)

	<span class="hljs-comment">// Like banana, dislike apple:</span>
	_, _, _ = doRequest(h, <span class="hljs-string">"POST"</span>, <span class="hljs-string">"/products/2/like"</span>, <span class="hljs-string">""</span>)
	_, _, _ = doRequest(h, <span class="hljs-string">"POST"</span>, <span class="hljs-string">"/products/1/dislike"</span>, <span class="hljs-string">""</span>)

	<span class="hljs-comment">// Now banana should be on top again:</span>
	body, status, err = doRequest(h, <span class="hljs-string">"GET"</span>, <span class="hljs-string">"/products"</span>, <span class="hljs-string">""</span>)
	assert.JSONEq(t, <span class="hljs-string">`[
		{"id":2,"name":"banana","likes":2,"dislikes":0},
		{"id":1,"name":"apple","likes":2,"dislikes":1}
	]`</span>, body)

	testDB.Close()
}

<span class="hljs-comment">// helper function to test handler using httptest recorder</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doRequest</span><span class="hljs-params">(h http.Handler, method, path, body <span class="hljs-type">string</span>)</span></span> (content <span class="hljs-type">string</span>, status <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) {
	<span class="hljs-keyword">var</span> bodyReader io.Reader
	<span class="hljs-keyword">if</span> body != <span class="hljs-string">""</span> {
		bodyReader = strings.NewReader(body)
	}
	req := httptest.NewRequest(method, path, bodyReader)
	w := httptest.NewRecorder()
	h.ServeHTTP(w, req)
	res := w.Result()
	<span class="hljs-keyword">defer</span> res.Body.Close()
	data, err := ioutil.ReadAll(res.Body)
	<span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(data), res.StatusCode, err
}</code></pre>
<p>Here I did everything in one testcase. Here all the cases run from one function, one after another. Just to save myself some work like creating a lot of fixtures, so results of previous test are used in next ones.</p>
<p>When we would want to do multiple independent tests, but share DB (because creating DB container for each testcase takes forever), I suggest to use <code>TestMain</code> to create and cleanup database container. Just be careful so tests do not influence each others in bad ways.</p>
<h2 id="debugging">Debugging</h2>
<p>But surprise! When we run the tests above, they fail. Banana with one like is not rated above apple. To debug that, I pause tests execution by inserting  <code>time.Sleep(300 * time.Second)</code> where needed.</p>
<p>While tests sleep, we could open their DB and check what's going on. <code>docker ps</code> will show you name of the PostgreSQL container. And then:</p>
<pre><code class="hljs language-bash">docker <span class="hljs-built_in">exec</span> -it <span class="hljs-variable">$CONTAINER_NAME</span> psql -U test_user test_db</code></pre>
<p>Will launch a <code>psql</code> client. There we could see that our like is stored successfully:</p>
<pre><code>test_db=# select * from products;
 id |  name  | likes | dislikes 
----+--------+-------+----------
  1 | apple  |     0 |        0
  2 | banana |     1 |        0
</code></pre>
<p>But rating is not calculated properly:</p>
<pre><code>test_db=# select name, (likes + 1) / (likes + dislikes + 2) as rating from products;
  name  | rating 
--------+--------
 apple  |      0
 banana |      0
(2 rows)
</code></pre>
<p>Checking case for apples <code>(0 + 1) / (0 + 0 + 2)</code>  we see that we have a problem caused by division:</p>
<pre><code>test_db=# select 1 / 2;
 ?column? 
----------
        0
(1 row)

test_db=# select 1.0 / 2.0;
        ?column?        
------------------------
 0.50000000000000000000

</code></pre>
<p>Yeah, integer division! Open <code>store/store.go</code> and instead of</p>
<pre><code class="hljs language-sql">		<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> (likes <span class="hljs-operator">+</span> <span class="hljs-number">1</span>) <span class="hljs-operator">/</span> (likes <span class="hljs-operator">+</span> dislikes <span class="hljs-operator">+</span> <span class="hljs-number">2</span>) <span class="hljs-keyword">DESC</span></code></pre>
<p>write</p>
<pre><code class="hljs language-sql">		<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> (likes <span class="hljs-operator">+</span> <span class="hljs-number">1.0</span>) <span class="hljs-operator">/</span> (likes <span class="hljs-operator">+</span> dislikes <span class="hljs-operator">+</span> <span class="hljs-number">2.0</span>) <span class="hljs-keyword">DESC</span></code></pre>
<p>Now tests should pass.</p>
<h2 id="coverage">Coverage</h2>
<p>Let's check how much of the code covered our tests:</p>
<pre><code class="hljs language-bash">$ go <span class="hljs-built_in">test</span> -cover ./...
?   	example/postest	[no <span class="hljs-built_in">test</span> files]
ok  	example/postest/api	(cached)	coverage: 71.4% of statements
?   	example/postest/store	[no <span class="hljs-built_in">test</span> files]
?   	example/postest/testdb	[no <span class="hljs-built_in">test</span> files]</code></pre>
<p>Interesting here is that we wrote tests just for the <code>api</code> package, almost 75% of it is covered, but we found a bug inside store package. So coverage report is a little bit misleading. Probably it was designed for unit tests, that do not reach outside of their package.</p>
<p>To have better report do this:</p>
<pre><code class="hljs language-bash">go <span class="hljs-built_in">test</span> -coverpkg=./... -coverprofile=profile.cov ./...</code></pre>
<p>Parameter <code>-coverpkg</code> tells go to record also the coverage of the other packages in folder. You could also pass <code>all</code> value there, but then it will record also coverage of dependencies (web framework, standard library, etc.). Seems too much, so I prefer <code>./...</code>.</p>
<p>This command still prints wrong report, but <code>profile.cov</code> now contains correct results. To view them, run</p>
<pre><code class="hljs language-bash">go tool cover -html=profile.cov</code></pre>
<p>It will open a page in browser with a drop-down selector that shows coverage for each file (<code>store/store.go</code> has 85.2%), and will highlight lines that still needs to be covered.</p>
<p>In our example not covered are mostly error handling code like</p>
<pre><code class="hljs language-go">        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
                <span class="hljs-keyword">return</span> err
        }</code></pre>
<p>It executes when database itself has problems (or our query has errors). Such cases probably could be better covered with mocked DB (or not covered at all).</p>
<h2 id="conclusion">Conclusion</h2>
<p>So we saw that tests found a bug in SQL code itself. If we had just unit-tests that tested logic in Go code and mocked database, this bug would not have been detected.  Yes, in simple example like this query could have been tested manually. But imagine how many bugs are hiding when you build your query dynamically?</p>
<p>I have seen assertions made about final text of SQL query, but that is very brittle way to write test-cases. You don't know if your query will work, and on every logic change you need to change most of your test-cases.</p>
<p>Downside of writing automated tests like this are that they are waaaay slower than normal ones. Like you could go make a tea while they run, especially when you create multiple test databases. But still faster than manual, once you wrote them.</p>
<p>So such integration testing stands in the middle between manual and unit tests. It's slower than unit-tests, but faster than humans. It potentially finds more bugs than unit-testing. But as any other kind of testing proves only that bugs exist, not that there are no bugs at all.</p></div></article><div><div id="disqus_thread"></div></div><nav><a href="/">Home</a><a href="#top">Back to top</a></nav><footer>© <!-- -->2022<!-- --> Bunyk Taras. Built with Next.js</footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"testcontainers_go","title":"Testing go code with real database using testcontainers","date":"2022-06-29T08:34:06.000Z","tags":["go"],"updated_at":"2022-10-25T16:53:30+02:00","content":"\u003cp\u003eUnit tests are a good thing. They run fast, and allow you to be more confident that you have not broken logic that they verify. If you find a bug, and write a test that reproduces it, you could make sure that bug will not return. They try to, for example, when some developer that comes after you wants to simplify your code, and misses a corner case.\u003c/p\u003e\n\u003cp\u003eBut unit tests usually test some unit (usually function) of your program in isolation, therefore the name. They mock all the dependencies, including database connection. That has its advantages, but also downsides. Sometimes, your back-end code is just a glue between HTTP and database,  and a lot of your logic is implemented directly in the database. Bugs could hide in the database and in the interface to database (especially if you try to build query dynamically). And it would be nice to be able to automatically verify that your queries will work with your DB.\u003c/p\u003e\n\u003cp\u003eTo do that in Python world, you usually have some ORM, which connects to PostgreSQL on production, and to in-memory SQLite when running tests. ORM generates different SQL for that cases, but if you are not running super complex queries, you could be confident enough that behavior of code will be the similar in tests and in live environment.\u003c/p\u003e\n\u003cp\u003eI though that similar thing is impossible in Go where it's not common to use ORM. Until my teammate with Java background introduced \u003ca href=\"https://golang.testcontainers.org/\"\u003e\u003ccode\u003etestcontainers\u003c/code\u003e\u003c/a\u003e library to our projects. Here is a \u003ca href=\"https://engineering.zalando.com/posts/2021/02/integration-tests-with-testcontainers.html\"\u003epost about testcontainers for Java devs on engineering blog of my company\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eNow let's see how to write automated tests that verify the correct end to end behavior of an app, by creating a PostgreSQL DB in a container.\u003c/p\u003e\n\u003ch2 id=\"example-service\"\u003eExample service\u003c/h2\u003e\n\u003cp\u003eLet's imagine that we are building the rating service. It stores products (or restaurants, blog articles, Stack Overflow comments, whatever). And users leave feedback in a form of a like or dislike. It will have following, simplified API:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePOST /products {name: 'Go'}\u003c/code\u003e - creates a new product with given name\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eGET /products\u003c/code\u003e returns products ordered by rating \u003ccode\u003e[{id: 1, name: 'postgres' likes: 20, dislikes: 0}, {id: 2, name: 'MariaDB' likes: 15, dislikes: 6}, ...]\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePOST /products/:id:/like\u003c/code\u003e - adds a new like for a product\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePOST /products/:id:/dislike\u003c/code\u003e - adds a dislike\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen computing rating, we would use \u003ca href=\"https://en.wikipedia.org/wiki/Rule_of_succession\"\u003erule of succession\u003c/a\u003e to make sure that product with one like (100% of likes), is not rated higher than product with 99 likes and 1 dislike (99% of likes). For that, we assume that there are always one additional \"prior\" like and one \"prior\" dislike for each product. So products with zero explicit likes or dislikes, have 50% positive rating, and having one like increases that percent to 66%. The more feedback the product gets, the less impact this prior implicit feedback has on final rating.\u003c/p\u003e\n\u003cp\u003eFor the sake of simplicity, we skip authorization and other details like getting product by id, pagination, or limiting number of likes per product per user. So we could implement functionality quickly and focus on building tests.\u003c/p\u003e\n\u003ch2 id=\"implementation\"\u003eImplementation\u003c/h2\u003e\n\u003cp\u003eStart a new go project called \u003ccode\u003epostest\u003c/code\u003e, and add two dependencies:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e\u003cspan class=\"hljs-built_in\"\u003emkdir\u003c/span\u003e postest\ngo mod init example/postest\ngo get github.com/gin-gonic/gin \u003cspan class=\"hljs-comment\"\u003e# for API\u003c/span\u003e\ngo get github.com/jackc/pgx/v4  \u003cspan class=\"hljs-comment\"\u003e# for storage\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003emkdir\u003c/span\u003e api\n\u003cspan class=\"hljs-built_in\"\u003emkdir\u003c/span\u003e store\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDatabase schema has just one table that looks like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eCREATE\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eTABLE\u003c/span\u003e IF \u003cspan class=\"hljs-keyword\"\u003eNOT\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eEXISTS\u003c/span\u003e products (\n\tid SERIAL \u003cspan class=\"hljs-keyword\"\u003ePRIMARY\u003c/span\u003e KEY,\n\tname \u003cspan class=\"hljs-type\"\u003eVARCHAR\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e255\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eNOT\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eNULL\u003c/span\u003e,\n\tlikes \u003cspan class=\"hljs-type\"\u003eINT\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eNOT\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eNULL\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eDEFAULT\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n\tdislikes \u003cspan class=\"hljs-type\"\u003eINT\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eNOT\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eNULL\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eDEFAULT\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n)\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd when we select from it, we will use rule of succession to order results like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eBY\u003c/span\u003e (likes \u003cspan class=\"hljs-operator\"\u003e+\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) \u003cspan class=\"hljs-operator\"\u003e/\u003c/span\u003e (likes \u003cspan class=\"hljs-operator\"\u003e+\u003c/span\u003e dislikes \u003cspan class=\"hljs-operator\"\u003e+\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eDESC\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSo if you have apples with 1 like and 0 dislikes, and bananas with 9 likes and 1 dislike, you will get value (1 + 1) / (1 + 0 + 2) = 0.666 for apples, and (9 + 1) / (9 + 1 + 2) = 0.833 for bananas, so bananas will go higher in ranking.\u003c/p\u003e\n\u003cp\u003eNow, below I'll just put listings of code for \u003ccode\u003eapi\u003c/code\u003e and \u003ccode\u003estore\u003c/code\u003e packages, and \u003ccode\u003emain.go\u003c/code\u003e, so you could follow along. If you just want to read - scroll until the \u003ca href=\"#testing\"\u003etesting section\u003c/a\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e\u003cspan class=\"hljs-keyword\"\u003epackage\u003c/span\u003e api\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e (\n\t\u003cspan class=\"hljs-string\"\u003e\"net/http\"\u003c/span\u003e\n\n\t\u003cspan class=\"hljs-string\"\u003e\"github.com/gin-gonic/gin\"\u003c/span\u003e\n\n\t\u003cspan class=\"hljs-string\"\u003e\"example/postest/store\"\u003c/span\u003e\n)\n\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e api \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e {\n\tstore store.Store\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eNew\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(s store.Store)\u003c/span\u003e\u003c/span\u003e *gin.Engine {\n\ta := api{store: s}\n\tr := gin.Default()\n\tr.GET(\u003cspan class=\"hljs-string\"\u003e\"/products\"\u003c/span\u003e, a.getProducts)\n\tr.POST(\u003cspan class=\"hljs-string\"\u003e\"/products\"\u003c/span\u003e, a.createProduct)\n\tr.POST(\u003cspan class=\"hljs-string\"\u003e\"/products/:id/like\"\u003c/span\u003e, a.likeProduct)\n\tr.POST(\u003cspan class=\"hljs-string\"\u003e\"/products/:id/dislike\"\u003c/span\u003e, a.dislikeProduct)\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e r\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003e(a api)\u003c/span\u003e\u003c/span\u003e getProducts(c *gin.Context) {\n\tproducts, err := a.store.GetProducts(c.Request.Context())\n\t\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\u003cspan class=\"hljs-string\"\u003e\"error\"\u003c/span\u003e: err.Error()})\n\t\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e\n\t}\n\tc.IndentedJSON(http.StatusOK, products)\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003e(a api)\u003c/span\u003e\u003c/span\u003e createProduct(c *gin.Context) {\n\t\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e p store.Product\n\t\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err := c.ShouldBindJSON(\u0026#x26;p); err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n\t\tc.JSON(http.StatusBadRequest, gin.H{\u003cspan class=\"hljs-string\"\u003e\"error\"\u003c/span\u003e: err.Error()})\n\t\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e\n\t}\n\tp, err := a.store.CreateProduct(c.Request.Context(), p)\n\t\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\u003cspan class=\"hljs-string\"\u003e\"error\"\u003c/span\u003e: err.Error()})\n\t\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e\n\t}\n\tc.JSON(http.StatusCreated, p)\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003e(a api)\u003c/span\u003e\u003c/span\u003e likeProduct(c *gin.Context) {\n\ta.rateProduct(c, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e)\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003e(a api)\u003c/span\u003e\u003c/span\u003e dislikeProduct(c *gin.Context) {\n\ta.rateProduct(c, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e)\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003e(a api)\u003c/span\u003e\u003c/span\u003e rateProduct(c *gin.Context, like \u003cspan class=\"hljs-type\"\u003ebool\u003c/span\u003e) {\n\tid := c.Param(\u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e)\n\t\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err := a.store.RateProduct(c.Request.Context(), id, like); err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n\t\tc.JSON(http.StatusInternalServerError, gin.H{\u003cspan class=\"hljs-string\"\u003e\"error\"\u003c/span\u003e: err.Error()})\n\t\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e\n\t}\n\tc.Status(http.StatusOK)\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e\u003cspan class=\"hljs-keyword\"\u003epackage\u003c/span\u003e store\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e (\n\t\u003cspan class=\"hljs-string\"\u003e\"context\"\u003c/span\u003e\n\t\u003cspan class=\"hljs-string\"\u003e\"fmt\"\u003c/span\u003e\n\n\t\u003cspan class=\"hljs-string\"\u003e\"github.com/jackc/pgx/v4/pgxpool\"\u003c/span\u003e\n)\n\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e Product \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e {\n\tID       \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e    \u003cspan class=\"hljs-string\"\u003e`json:\"id\"`\u003c/span\u003e\n\tName     \u003cspan class=\"hljs-type\"\u003estring\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`json:\"name\"`\u003c/span\u003e\n\tLikes    \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e    \u003cspan class=\"hljs-string\"\u003e`json:\"likes\"`\u003c/span\u003e\n\tDislikes \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e    \u003cspan class=\"hljs-string\"\u003e`json:\"dislikes\"`\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e Store \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e {\n\tdb *pgxpool.Pool\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eNew\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(dsn \u003cspan class=\"hljs-type\"\u003estring\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e (s Store, err \u003cspan class=\"hljs-type\"\u003eerror\u003c/span\u003e) {\n\ts.db, err = pgxpool.Connect(context.Background(), dsn)\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003e(s Store)\u003c/span\u003e\u003c/span\u003e Migrate() \u003cspan class=\"hljs-type\"\u003eerror\u003c/span\u003e {\n\t_, err := s.db.Exec(context.Background(), \u003cspan class=\"hljs-string\"\u003e`\n\t\tCREATE TABLE IF NOT EXISTS products (\n\t\t\tid SERIAL PRIMARY KEY,\n\t\t\tname VARCHAR(255) NOT NULL,\n\t\t\tlikes INT NOT NULL DEFAULT 0,\n\t\t\tdislikes INT NOT NULL DEFAULT 0\n\t\t)\n\t`\u003c/span\u003e)\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e err\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003e(s Store)\u003c/span\u003e\u003c/span\u003e GetProducts(ctx context.Context) ([]Product, \u003cspan class=\"hljs-type\"\u003eerror\u003c/span\u003e) {\n\t\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e products []Product\n\trows, err := s.db.Query(ctx, \u003cspan class=\"hljs-string\"\u003e`\n\t\tSELECT id, name, likes, dislikes\n\t\tFROM products\n\t\tORDER BY (likes + 1) / (likes + dislikes + 2) DESC\n\t`\u003c/span\u003e)\n\t\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n\t\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e, err\n\t}\n\t\u003cspan class=\"hljs-keyword\"\u003edefer\u003c/span\u003e rows.Close()\n\t\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e rows.Next() {\n\t\t\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e p Product\n\t\terr = rows.Scan(\u0026#x26;p.ID, \u0026#x26;p.Name, \u0026#x26;p.Likes, \u0026#x26;p.Dislikes)\n\t\t\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n\t\t\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e, err\n\t\t}\n\t\tproducts = \u003cspan class=\"hljs-built_in\"\u003eappend\u003c/span\u003e(products, p)\n\t}\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e products, \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003e(s Store)\u003c/span\u003e\u003c/span\u003e CreateProduct(ctx context.Context, p Product) (Product, \u003cspan class=\"hljs-type\"\u003eerror\u003c/span\u003e) {\n\terr := s.db.QueryRow(context.Background(), \u003cspan class=\"hljs-string\"\u003e\"INSERT INTO products (name) VALUES ($1) RETURNING id\"\u003c/span\u003e, p.Name).Scan(\u0026#x26;p.ID)\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e p, err\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003e(s Store)\u003c/span\u003e\u003c/span\u003e RateProduct(ctx context.Context, id \u003cspan class=\"hljs-type\"\u003estring\u003c/span\u003e, like \u003cspan class=\"hljs-type\"\u003ebool\u003c/span\u003e) \u003cspan class=\"hljs-type\"\u003eerror\u003c/span\u003e {\n\tfield := \u003cspan class=\"hljs-string\"\u003e\"dislikes\"\u003c/span\u003e\n\t\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e like {\n\t\tfield = \u003cspan class=\"hljs-string\"\u003e\"likes\"\u003c/span\u003e\n\t}\n\tr, err := s.db.Exec(ctx, fmt.Sprintf(\u003cspan class=\"hljs-string\"\u003e\"UPDATE products SET %s = %s + 1 WHERE id = $1\"\u003c/span\u003e, field, field), id)\n\t\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n\t\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e err\n\t}\n\t\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e n := r.RowsAffected(); n == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e {\n\t\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e fmt.Errorf(\u003cspan class=\"hljs-string\"\u003e\"no product with id %s\"\u003c/span\u003e, id)\n\t}\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd in case we would want to run it, here is the \u003ccode\u003emain.go\u003c/code\u003e file:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e\u003cspan class=\"hljs-keyword\"\u003epackage\u003c/span\u003e main\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e (\n\t\u003cspan class=\"hljs-string\"\u003e\"log\"\u003c/span\u003e\n\n\t\u003cspan class=\"hljs-string\"\u003e\"example/postest/api\"\u003c/span\u003e\n\t\u003cspan class=\"hljs-string\"\u003e\"example/postest/store\"\u003c/span\u003e\n)\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n\ts, err := store.New(\u003cspan class=\"hljs-string\"\u003e\"postgres://reviews_user:pass@localhost:5432/reviews\"\u003c/span\u003e)\n\t\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n\t\tlog.Fatal(err)\n\t}\n\terr = s.Migrate()\n\t\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n\t\tlog.Fatal(err)\n\t}\n\tr := api.New(s)\n\n\tlog.Println(\u003cspan class=\"hljs-string\"\u003e\"Listening on :8080\"\u003c/span\u003e)\n\tr.Run(\u003cspan class=\"hljs-string\"\u003e\":8080\"\u003c/span\u003e)\n}\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"testing\"\u003eTesting\u003c/h2\u003e\n\u003cp\u003eNow, how to test it? When we test manually, we connect to some database, like in \u003ccode\u003emain.go\u003c/code\u003e example above, and try different requests. We will do similar from our automated tests.\u003c/p\u003e\n\u003cp\u003eBut first, create yet another package to aid with our test database container creation. Le'ts call it \u003ccode\u003etestdb\u003c/code\u003e. Testcontainers help to create any docker containers from Go, \u003ccode\u003etestdb\u003c/code\u003e will create PostgreSQL DB test container exactly for our needs.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e\u003cspan class=\"hljs-keyword\"\u003epackage\u003c/span\u003e testdb\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e (\n\t\u003cspan class=\"hljs-string\"\u003e\"context\"\u003c/span\u003e\n\t\u003cspan class=\"hljs-string\"\u003e\"fmt\"\u003c/span\u003e\n\n\t\u003cspan class=\"hljs-string\"\u003e\"github.com/testcontainers/testcontainers-go\"\u003c/span\u003e\n\t\u003cspan class=\"hljs-string\"\u003e\"github.com/testcontainers/testcontainers-go/wait\"\u003c/span\u003e\n)\n\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e TestDBContainer \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e {\n\ttestcontainers.Container\n\tcontext context.Context\n\tURI     \u003cspan class=\"hljs-type\"\u003estring\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// logConsumer is log consumer to propagate logs of container to stdout\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e TestLogConsumer \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e{}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003e(g TestLogConsumer)\u003c/span\u003e\u003c/span\u003e Accept(l testcontainers.Log) {\n\tfmt.Println(l.LogType, \u003cspan class=\"hljs-type\"\u003estring\u003c/span\u003e(l.Content))\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e logConsumer TestLogConsumer\n\n\u003cspan class=\"hljs-comment\"\u003e// We hard-code credentials here, since it's for one-time DB\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// so they are not very important\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e (\n\tdb       = \u003cspan class=\"hljs-string\"\u003e\"test_db\"\u003c/span\u003e\n\tuser     = \u003cspan class=\"hljs-string\"\u003e\"test_user\"\u003c/span\u003e\n\tpassword = \u003cspan class=\"hljs-string\"\u003e\"test_password\"\u003c/span\u003e\n)\n\n\u003cspan class=\"hljs-comment\"\u003e// Create container with our test database\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eNew\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(ctx context.Context)\u003c/span\u003e\u003c/span\u003e (*TestDBContainer, \u003cspan class=\"hljs-type\"\u003eerror\u003c/span\u003e) {\n\t\u003cspan class=\"hljs-comment\"\u003e// ContainerRequest describes Docker container we want to run\u003c/span\u003e\n\treq := testcontainers.ContainerRequest{\n\t\tImage:        \u003cspan class=\"hljs-string\"\u003e\"postgres:latest\"\u003c/span\u003e,\n\t\tExposedPorts: []\u003cspan class=\"hljs-type\"\u003estring\u003c/span\u003e{\u003cspan class=\"hljs-string\"\u003e\"5432/tcp\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"8080/tcp\"\u003c/span\u003e},\n\t\tEnv: \u003cspan class=\"hljs-keyword\"\u003emap\u003c/span\u003e[\u003cspan class=\"hljs-type\"\u003estring\u003c/span\u003e]\u003cspan class=\"hljs-type\"\u003estring\u003c/span\u003e{\n\t\t\t\u003cspan class=\"hljs-string\"\u003e\"POSTGRES_DB\"\u003c/span\u003e:       db,\n\t\t\t\u003cspan class=\"hljs-string\"\u003e\"POSTGRES_USER\"\u003c/span\u003e:     user,\n\t\t\t\u003cspan class=\"hljs-string\"\u003e\"POSTGRES_PASSWORD\"\u003c/span\u003e: password,\n\t\t},\n\t\tWaitingFor: wait.ForLog(\u003cspan class=\"hljs-string\"\u003e`listening on IPv4 address \"0.0.0.0\", port 5432`\u003c/span\u003e),\n\t}\n\t\u003cspan class=\"hljs-comment\"\u003e// Run container\u003c/span\u003e\n\tcontainer, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{\n\t\tContainerRequest: req,\n\t\tStarted:          \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// block this call until container is started\u003c/span\u003e\n\t})\n\t\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n\t\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e, err\n\t}\n\n\t\u003cspan class=\"hljs-comment\"\u003e// use logConsumer to print logs to stdout\u003c/span\u003e\n\terr = container.StartLogProducer(ctx)\n\t\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n\t\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e, err\n\t}\n\tcontainer.FollowOutput(logConsumer)\n\n\t\u003cspan class=\"hljs-comment\"\u003e// Get externally mapped port\u003c/span\u003e\n\tmappedPort, err := container.MappedPort(ctx, \u003cspan class=\"hljs-string\"\u003e\"5432\"\u003c/span\u003e)\n\t\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n\t\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e, err\n\t}\n\n\t\u003cspan class=\"hljs-comment\"\u003e// Get container host\u003c/span\u003e\n\thostIP, err := container.Host(ctx)\n\t\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n\t\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e, err\n\t}\n\n\t\u003cspan class=\"hljs-comment\"\u003e// Build a DB URL connection string\u003c/span\u003e\n\turi := fmt.Sprintf(\u003cspan class=\"hljs-string\"\u003e\"postgres://%s:%s@%s:%s/%s\"\u003c/span\u003e, user, password, hostIP, mappedPort.Port(), db)\n\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u0026#x26;TestDBContainer{\n\t\tContainer: container,\n\t\tURI:       uri,\n\t\tcontext:   ctx,\n\t}, \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// Stop the container\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003e(t *TestDBContainer)\u003c/span\u003e\u003c/span\u003e Close() \u003cspan class=\"hljs-type\"\u003eerror\u003c/span\u003e {\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e t.Container.Terminate(t.context)\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd don't forget to install testcontainers package itself:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003ego get github.com/testcontainers/testcontainers-go\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, let's add tests in \u003ccode\u003eapi/api_test.go\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e\u003cspan class=\"hljs-keyword\"\u003epackage\u003c/span\u003e api\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e (\n\t\u003cspan class=\"hljs-string\"\u003e\"context\"\u003c/span\u003e\n\t\u003cspan class=\"hljs-string\"\u003e\"io\"\u003c/span\u003e\n\t\u003cspan class=\"hljs-string\"\u003e\"io/ioutil\"\u003c/span\u003e\n\t\u003cspan class=\"hljs-string\"\u003e\"log\"\u003c/span\u003e\n\t\u003cspan class=\"hljs-string\"\u003e\"net/http\"\u003c/span\u003e\n\t\u003cspan class=\"hljs-string\"\u003e\"net/http/httptest\"\u003c/span\u003e\n\t\u003cspan class=\"hljs-string\"\u003e\"strings\"\u003c/span\u003e\n\t\u003cspan class=\"hljs-string\"\u003e\"testing\"\u003c/span\u003e\n\t\u003cspan class=\"hljs-string\"\u003e\"time\"\u003c/span\u003e\n\n\t\u003cspan class=\"hljs-string\"\u003e\"example/postest/store\"\u003c/span\u003e\n\t\u003cspan class=\"hljs-string\"\u003e\"example/postest/testdb\"\u003c/span\u003e\n\n\t\u003cspan class=\"hljs-string\"\u003e\"github.com/stretchr/testify/assert\"\u003c/span\u003e\n)\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eTestCreationAndRatingFlow\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(t *testing.T)\u003c/span\u003e\u003c/span\u003e {\n\t\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e err \u003cspan class=\"hljs-type\"\u003eerror\u003c/span\u003e\n\tctx, _ := context.WithTimeout(context.Background(), time.Second*\u003cspan class=\"hljs-number\"\u003e600\u003c/span\u003e)\n\ttestDB, err := testdb.New(ctx)\n\t\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n\t\tlog.Fatal(err)\n\t}\n\ts, err := store.New(testDB.URI)\n\t\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n\t\tlog.Fatal(err)\n\t}\n\terr = s.Migrate()\n\t\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n\t\tlog.Fatal(err)\n\t}\n\n\ta := New(s)\n\th := a.Handler()\n\n\tbody, status, err := doRequest(h, \u003cspan class=\"hljs-string\"\u003e\"GET\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"/products\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e)\n\tassert.Nil(t, err)\n\tassert.Equal(t, http.StatusOK, status)\n\tassert.JSONEq(t, \u003cspan class=\"hljs-string\"\u003e`[]`\u003c/span\u003e, body)\n\n\t\u003cspan class=\"hljs-comment\"\u003e// Test that product is created:\u003c/span\u003e\n\tbody, status, err = doRequest(h, \u003cspan class=\"hljs-string\"\u003e\"POST\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"/products\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e`{\"name\":\"apple\"}`\u003c/span\u003e)\n\tassert.Nil(t, err)\n\tassert.Equal(t, http.StatusCreated, status)\n\tassert.JSONEq(t, \u003cspan class=\"hljs-string\"\u003e`{\"id\":1,\"name\":\"apple\",\"likes\":0,\"dislikes\":0}`\u003c/span\u003e, body)\n\n\tbody, status, err = doRequest(h, \u003cspan class=\"hljs-string\"\u003e\"POST\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"/products\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e`{\"name\":\"banana\"}`\u003c/span\u003e)\n\tassert.Nil(t, err)\n\tassert.Equal(t, http.StatusCreated, status)\n\tassert.JSONEq(t, \u003cspan class=\"hljs-string\"\u003e`{\"id\":2,\"name\":\"banana\",\"likes\":0,\"dislikes\":0}`\u003c/span\u003e, body)\n\n\t\u003cspan class=\"hljs-comment\"\u003e// Now should return two products:\u003c/span\u003e\n\tbody, status, err = doRequest(h, \u003cspan class=\"hljs-string\"\u003e\"GET\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"/products\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e)\n\tassert.Nil(t, err)\n\tassert.Equal(t, http.StatusOK, status)\n\tassert.JSONEq(t, \u003cspan class=\"hljs-string\"\u003e`[\n\t\t{\"id\":1,\"name\":\"apple\",\"likes\":0,\"dislikes\":0},\n\t\t{\"id\":2,\"name\":\"banana\",\"likes\":0,\"dislikes\":0}\n\t]`\u003c/span\u003e, body)\n\n\t\u003cspan class=\"hljs-comment\"\u003e// Like banana:\u003c/span\u003e\n\tbody, status, err = doRequest(h, \u003cspan class=\"hljs-string\"\u003e\"POST\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"/products/2/like\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e)\n\tassert.Nil(t, err)\n\tassert.Equal(t, http.StatusOK, status)\n\n\t\u003cspan class=\"hljs-comment\"\u003e// Now banana should be at top:\u003c/span\u003e\n\tbody, status, err = doRequest(h, \u003cspan class=\"hljs-string\"\u003e\"GET\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"/products\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e)\n\tassert.JSONEq(t, \u003cspan class=\"hljs-string\"\u003e`[\n\t\t{\"id\":2,\"name\":\"banana\",\"likes\":1,\"dislikes\":0},\n\t\t{\"id\":1,\"name\":\"apple\",\"likes\":0,\"dislikes\":0}\n\t]`\u003c/span\u003e, body)\n\n\t\u003cspan class=\"hljs-comment\"\u003e// Like apple twice:\u003c/span\u003e\n\t_, _, _ = doRequest(h, \u003cspan class=\"hljs-string\"\u003e\"POST\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"/products/1/like\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e)\n\t_, _, _ = doRequest(h, \u003cspan class=\"hljs-string\"\u003e\"POST\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"/products/1/like\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e)\n\n\t\u003cspan class=\"hljs-comment\"\u003e// Now apple should be on top again:\u003c/span\u003e\n\tbody, status, err = doRequest(h, \u003cspan class=\"hljs-string\"\u003e\"GET\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"/products\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e)\n\tassert.JSONEq(t, \u003cspan class=\"hljs-string\"\u003e`[\n\t\t{\"id\":1,\"name\":\"apple\",\"likes\":2,\"dislikes\":0},\n\t\t{\"id\":2,\"name\":\"banana\",\"likes\":1,\"dislikes\":0}\n\t]`\u003c/span\u003e, body)\n\n\t\u003cspan class=\"hljs-comment\"\u003e// Like banana, dislike apple:\u003c/span\u003e\n\t_, _, _ = doRequest(h, \u003cspan class=\"hljs-string\"\u003e\"POST\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"/products/2/like\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e)\n\t_, _, _ = doRequest(h, \u003cspan class=\"hljs-string\"\u003e\"POST\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"/products/1/dislike\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e)\n\n\t\u003cspan class=\"hljs-comment\"\u003e// Now banana should be on top again:\u003c/span\u003e\n\tbody, status, err = doRequest(h, \u003cspan class=\"hljs-string\"\u003e\"GET\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"/products\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e)\n\tassert.JSONEq(t, \u003cspan class=\"hljs-string\"\u003e`[\n\t\t{\"id\":2,\"name\":\"banana\",\"likes\":2,\"dislikes\":0},\n\t\t{\"id\":1,\"name\":\"apple\",\"likes\":2,\"dislikes\":1}\n\t]`\u003c/span\u003e, body)\n\n\ttestDB.Close()\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// helper function to test handler using httptest recorder\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003edoRequest\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(h http.Handler, method, path, body \u003cspan class=\"hljs-type\"\u003estring\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e (content \u003cspan class=\"hljs-type\"\u003estring\u003c/span\u003e, status \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e, err \u003cspan class=\"hljs-type\"\u003eerror\u003c/span\u003e) {\n\t\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e bodyReader io.Reader\n\t\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e body != \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e {\n\t\tbodyReader = strings.NewReader(body)\n\t}\n\treq := httptest.NewRequest(method, path, bodyReader)\n\tw := httptest.NewRecorder()\n\th.ServeHTTP(w, req)\n\tres := w.Result()\n\t\u003cspan class=\"hljs-keyword\"\u003edefer\u003c/span\u003e res.Body.Close()\n\tdata, err := ioutil.ReadAll(res.Body)\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003estring\u003c/span\u003e(data), res.StatusCode, err\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere I did everything in one testcase. Here all the cases run from one function, one after another. Just to save myself some work like creating a lot of fixtures, so results of previous test are used in next ones.\u003c/p\u003e\n\u003cp\u003eWhen we would want to do multiple independent tests, but share DB (because creating DB container for each testcase takes forever), I suggest to use \u003ccode\u003eTestMain\u003c/code\u003e to create and cleanup database container. Just be careful so tests do not influence each others in bad ways.\u003c/p\u003e\n\u003ch2 id=\"debugging\"\u003eDebugging\u003c/h2\u003e\n\u003cp\u003eBut surprise! When we run the tests above, they fail. Banana with one like is not rated above apple. To debug that, I pause tests execution by inserting  \u003ccode\u003etime.Sleep(300 * time.Second)\u003c/code\u003e where needed.\u003c/p\u003e\n\u003cp\u003eWhile tests sleep, we could open their DB and check what's going on. \u003ccode\u003edocker ps\u003c/code\u003e will show you name of the PostgreSQL container. And then:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003edocker \u003cspan class=\"hljs-built_in\"\u003eexec\u003c/span\u003e -it \u003cspan class=\"hljs-variable\"\u003e$CONTAINER_NAME\u003c/span\u003e psql -U test_user test_db\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWill launch a \u003ccode\u003epsql\u003c/code\u003e client. There we could see that our like is stored successfully:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etest_db=# select * from products;\n id |  name  | likes | dislikes \n----+--------+-------+----------\n  1 | apple  |     0 |        0\n  2 | banana |     1 |        0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBut rating is not calculated properly:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etest_db=# select name, (likes + 1) / (likes + dislikes + 2) as rating from products;\n  name  | rating \n--------+--------\n apple  |      0\n banana |      0\n(2 rows)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eChecking case for apples \u003ccode\u003e(0 + 1) / (0 + 0 + 2)\u003c/code\u003e  we see that we have a problem caused by division:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etest_db=# select 1 / 2;\n ?column? \n----------\n        0\n(1 row)\n\ntest_db=# select 1.0 / 2.0;\n        ?column?        \n------------------------\n 0.50000000000000000000\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYeah, integer division! Open \u003ccode\u003estore/store.go\u003c/code\u003e and instead of\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\t\t\u003cspan class=\"hljs-keyword\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eBY\u003c/span\u003e (likes \u003cspan class=\"hljs-operator\"\u003e+\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) \u003cspan class=\"hljs-operator\"\u003e/\u003c/span\u003e (likes \u003cspan class=\"hljs-operator\"\u003e+\u003c/span\u003e dislikes \u003cspan class=\"hljs-operator\"\u003e+\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eDESC\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewrite\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\t\t\u003cspan class=\"hljs-keyword\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eBY\u003c/span\u003e (likes \u003cspan class=\"hljs-operator\"\u003e+\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e) \u003cspan class=\"hljs-operator\"\u003e/\u003c/span\u003e (likes \u003cspan class=\"hljs-operator\"\u003e+\u003c/span\u003e dislikes \u003cspan class=\"hljs-operator\"\u003e+\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2.0\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eDESC\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow tests should pass.\u003c/p\u003e\n\u003ch2 id=\"coverage\"\u003eCoverage\u003c/h2\u003e\n\u003cp\u003eLet's check how much of the code covered our tests:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e$ go \u003cspan class=\"hljs-built_in\"\u003etest\u003c/span\u003e -cover ./...\n?   \texample/postest\t[no \u003cspan class=\"hljs-built_in\"\u003etest\u003c/span\u003e files]\nok  \texample/postest/api\t(cached)\tcoverage: 71.4% of statements\n?   \texample/postest/store\t[no \u003cspan class=\"hljs-built_in\"\u003etest\u003c/span\u003e files]\n?   \texample/postest/testdb\t[no \u003cspan class=\"hljs-built_in\"\u003etest\u003c/span\u003e files]\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eInteresting here is that we wrote tests just for the \u003ccode\u003eapi\u003c/code\u003e package, almost 75% of it is covered, but we found a bug inside store package. So coverage report is a little bit misleading. Probably it was designed for unit tests, that do not reach outside of their package.\u003c/p\u003e\n\u003cp\u003eTo have better report do this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003ego \u003cspan class=\"hljs-built_in\"\u003etest\u003c/span\u003e -coverpkg=./... -coverprofile=profile.cov ./...\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eParameter \u003ccode\u003e-coverpkg\u003c/code\u003e tells go to record also the coverage of the other packages in folder. You could also pass \u003ccode\u003eall\u003c/code\u003e value there, but then it will record also coverage of dependencies (web framework, standard library, etc.). Seems too much, so I prefer \u003ccode\u003e./...\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis command still prints wrong report, but \u003ccode\u003eprofile.cov\u003c/code\u003e now contains correct results. To view them, run\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003ego tool cover -html=profile.cov\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt will open a page in browser with a drop-down selector that shows coverage for each file (\u003ccode\u003estore/store.go\u003c/code\u003e has 85.2%), and will highlight lines that still needs to be covered.\u003c/p\u003e\n\u003cp\u003eIn our example not covered are mostly error handling code like\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n                \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e err\n        }\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt executes when database itself has problems (or our query has errors). Such cases probably could be better covered with mocked DB (or not covered at all).\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eSo we saw that tests found a bug in SQL code itself. If we had just unit-tests that tested logic in Go code and mocked database, this bug would not have been detected.  Yes, in simple example like this query could have been tested manually. But imagine how many bugs are hiding when you build your query dynamically?\u003c/p\u003e\n\u003cp\u003eI have seen assertions made about final text of SQL query, but that is very brittle way to write test-cases. You don't know if your query will work, and on every logic change you need to change most of your test-cases.\u003c/p\u003e\n\u003cp\u003eDownside of writing automated tests like this are that they are waaaay slower than normal ones. Like you could go make a tea while they run, especially when you create multiple test databases. But still faster than manual, once you wrote them.\u003c/p\u003e\n\u003cp\u003eSo such integration testing stands in the middle between manual and unit tests. It's slower than unit-tests, but faster than humans. It potentially finds more bugs than unit-testing. But as any other kind of testing proves only that bugs exist, not that there are no bugs at all.\u003c/p\u003e"},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"testcontainers_go"},"buildId":"sW-wDccd-ZCyzGzfnKrfa","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>