<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Reverse engineering game archive of London Racer: World Challenge</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/b53cc6ef9e9e352d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b53cc6ef9e9e352d.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-959cc2ac3c742fb4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ec0fdebf93e8fc69.js" defer=""></script><script src="/_next/static/chunks/996-372da0b0d3708a80.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-959ba1136e063a38.js" defer=""></script><script src="/_next/static/EMWktbA1TX6NqXCAYKEiA/_buildManifest.js" defer=""></script><script src="/_next/static/EMWktbA1TX6NqXCAYKEiA/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><h1 id="top">Taras Bunyk</h1><nav><a href="/">Home</a><a href="http://bunyk.github.io/mandala/">Snowflake drawing</a><a href="/resume">Resume</a><a href="https://bunyk.wordpress.com/">Old blog (in Ukrainian)</a></nav><article><h1>Reverse engineering game archive of London Racer: World Challenge</h1><div><em>Published: 2022-02-12T18:45:07.000Z</em></div><div><p>"London Racer: World Challenge" is fun old racing game. I like it because of nostalgia (I last played it around 2005). And among other places you could also race in Berlin. Game mechanics reminds me of Super Tux Cart.</p>
<p>Wikipedia says that "Davilex closed the game division in 2005 because it was not profitable enough, and their games were generally not well received".  But it also says that Germans even made a movie based on a game <a href="https://de.wikipedia.org/wiki/Autobahnraser_(Film)">Autobahnraser</a>, so I would say that's a great success.</p>
<p>But unfortunately the game does not run on my computer, even with Wine.
It would be interesting to extract model of some Berlin streets from there. Or car models. Maybe I'll even manage to put them into Super Tux Cart, will see.</p>
<p>You could download it from <a href="https://www.myabandonware.com/game/london-racer-world-challenge-e5l">here</a>.</p>
<p>Apart from <code>WR.exe</code>, archive with game contains files with game data: <code>WR.idx</code> and <code>WR.img</code>
First one contains list of file names, and second one - their contents. Offsets are stored somewhere in idx, but format of idx file is not clear. <code>.img</code> file looks like just concatenated files of the game.</p>
<h2 id="extracting-from-img-file">Extracting from .img file</h2>
<p>Every <code>.nif</code> file seems to start with the string "NetImmerse File Format, Version 4.2.1.0". We could use that to split them:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'WR.img'</span>, <span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> f:
	data = f.read()

chunks = data.split(<span class="hljs-string">b'NetImmerse'</span>)

chunks = [<span class="hljs-string">b'NetImmerse'</span> + c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> chunks <span class="hljs-keyword">if</span> c.startswith(<span class="hljs-string">b' File Format'</span>)]

<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'some.nif'</span>, <span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> f:
	f.write(chunks[<span class="hljs-number">0</span>])
</code></pre>
<h2 id="installing-blender-and-niftools-addon">Installing Blender and NifTools Addon</h2>
<p>NetImmerse was popular game engine, used for such games as Morrowind, Fallout and many others. And there is huge community of modders that created tools to work with <code>.nif</code> files.</p>
<p>Here is <a href="https://blender-niftools-addon.readthedocs.io/en/latest/user/install.html">the instruction to install .nif addon for Blender</a></p>
<p>After doing what instruction says, <code>some.nif</code> will open, and show a model of wrench:</p>
<p><img src="/content/wrench_model.png" alt="Wrench model"></p>
<p>That is <code>repairsmall.nif</code> I would guess. In the game you hit that wrench to repair damage done to your car by other objects that you hit.</p>
<h2 id="decoding-idx">Decoding .idx</h2>
<p>Some other chunks would not open with the Blender addon, and It would be interesting to know which are which, so let's try to figure out the structure of .idx</p>
<h3 id="looking-for-offsets">Looking for offsets</h3>
<p>Offset of first <code>.nif</code> file was 0xFA4. Looking for byte with value A4 gives one at some distance after string <code>repairsmall.nif</code>. After it there is a byte 07. That means little-endian format.</p>
<p>While I was trying to calculate distances from filename field to offset field, I found the page that describes format for another version of racing game from the same developer - <a href="http://wiki.xentax.com/index.php/London_Racer:_Police_Madness_IDX">London Racer: Police Madness</a></p>
<p>It gives some important tips. Image file is indeed just concatenated files, but index is a little bit more complex. It contains also directories. That is the correct suggestion from that page. Another correct suggestion was that size of file is stored in index twice. But unfortunately offsets and sizes of the fields do not match.</p>
<p>I wrote some python snippets to load binary data, and do a search in it. To test hypothesis that file offset should have constant distance from file name.</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> struct 
<span class="hljs-keyword">import</span> string
<span class="hljs-keyword">import</span> re

<span class="hljs-keyword">def</span> <span class="hljs-title function_">load_file</span>(<span class="hljs-params">fn</span>): 
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(fn, <span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> f:
        <span class="hljs-keyword">return</span> f.read()

<span class="hljs-comment"># Find all offsets of pattern in data</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">all_offsets</span>(<span class="hljs-params">pattern, data</span>):
    <span class="hljs-keyword">return</span> [m.start() <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> re.finditer(pattern, data)]

img = load_file(<span class="hljs-string">'WR.img'</span>)
idx = load_file(<span class="hljs-string">'WR.idx'</span>)

nif_offsets = all_offsets(<span class="hljs-string">b'NetImmerse File Format'</span>, img)

<span class="hljs-comment"># offsets of nif file offsets in idx.file</span>
nif_offset_offsets = [
    idx.find(struct.pack(<span class="hljs-string">'&#x3C;i'</span>, o)) <span class="hljs-comment"># search for given integer in little-endian format</span>
    <span class="hljs-keyword">for</span> o <span class="hljs-keyword">in</span> nif_offsets
]

<span class="hljs-comment"># offsets of ends of names of niff files - 4 bytes</span>
nif_name_offsets = all_offsets(<span class="hljs-string">b'\.nif\x00'</span>, idx)


<span class="hljs-comment"># Distance between the two</span>
[b-a <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(nif_name_offsets[:<span class="hljs-number">10</span>], nif_offset_offsets[:<span class="hljs-number">10</span>])]
[<span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">18</span>, <span class="hljs-number">17</span>, <span class="hljs-number">20</span>, <span class="hljs-number">18</span>, <span class="hljs-number">20</span>, <span class="hljs-number">1420</span>, <span class="hljs-number">1428</span>, <span class="hljs-number">1436</span>]</code></pre>
<p>Hm, not always the same.</p>
<h3 id="looking-at-the-hex">Looking at the hex</h3>
<p>I also tried some hex editors. Hexinator is fancy one, where you could comment and mark different bytes with different colors. But it crashed for me, so I uninstalled it. Ghex is simple one, and I don't use hex editors so often, so I kept it. But lack of color was making it hard to look at all that numbers, so I wrote short function to pretty print binary.</p>
<pre><code class="hljs language-python">nocolor = <span class="hljs-string">"\033[0m"</span>
red = <span class="hljs-string">"\033[31m"</span>
green = <span class="hljs-string">"\033[92m"</span>

visible_charset = <span class="hljs-built_in">bytes</span>(string.digits + string.ascii_letters + string.punctuation + <span class="hljs-string">' '</span>, <span class="hljs-string">'ascii'</span>)
<span class="hljs-keyword">def</span> <span class="hljs-title function_">is_visible</span>(<span class="hljs-params">b</span>):
    <span class="hljs-keyword">return</span> b <span class="hljs-keyword">in</span> visible_charset

<span class="hljs-keyword">def</span> <span class="hljs-title function_">pprint</span>(<span class="hljs-params">data, columns=<span class="hljs-number">10</span>, column_width=<span class="hljs-number">4</span></span>):
    <span class="hljs-keyword">for</span> i, b <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(data):
        <span class="hljs-keyword">if</span> i % (column_width * columns) == <span class="hljs-number">0</span>:
            <span class="hljs-built_in">print</span>()
        <span class="hljs-keyword">if</span> i % column_width == <span class="hljs-number">0</span>:
            <span class="hljs-built_in">print</span>(end=<span class="hljs-string">'  '</span>)
        
        r = <span class="hljs-string">'%02X'</span> % b
        <span class="hljs-keyword">if</span> is_visible(b):
            r = <span class="hljs-string">'%s%2s%s'</span> % (green, <span class="hljs-built_in">chr</span>(b), nocolor)

        <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span>:
            r = <span class="hljs-string">'%s 0%s'</span> % (red, nocolor)

        <span class="hljs-built_in">print</span>(r, end=<span class="hljs-string">''</span>)
    <span class="hljs-built_in">print</span>()</code></pre>
<p>It prints string values in green, zero bytes in red, and everything else as hexadecimal numbers in white. In groups of 4 bytes:</p>
<p><img src="/content/idx_hex_view.png" alt="Hex view" title="HEX view of head of WR.idx file"></p>
<p>Grouping by 4 bytes helps the most. From there you see that after the name of the file there are two repeating groups of 4 bytes. For example after <code>wr.ini</code> - <code>840F 0 0</code> and again <code>840F 0 0</code>. After <code>repairsmall.nif</code> - <code>A7 8 0 0</code>. I checked - size of file with that wrench is 14503 bytes, which is <code>0x38A7</code> in hex or <code>A7 38 00 00</code> in little-endian format. That <code>8</code> is green, which means ASCII, and ASCII code of character '8' is  56 or 38 in hex.</p>
<p>Filenames end with byte <code>0</code> , like proper C strings, but if position of next byte is not divisible by 4, more zero bytes are added for padding. That explains small variations in distances between filenames and offsets of offsets.</p>
<p>After that two fields, goes another unknown 32-bit field, and then 32-bit offset of file. Then another unknown 4 bytes, and then 8 zero bytes. Or we could look at that from the other point of view, and say that each filename record starts from 8 zero bytes. Directory names also seems to be prefixed by 8 zero bytes. Apart from that, they seem to contain 8 bytes of data. Some of that bytes probably should be number of directories.</p>
<p>Since first string in index after the header seems to be file, some values preceding it are probably data for the root directory. Maybe <code>2</code> is number of objects in the root directory? <code>wr.ini</code> and <code>data</code>? Otherwise it's <code>01 008 0</code>, which corresponds to <code>524289</code> and seems too much.</p>
<h3 id="trying-to-unpack">Trying to unpack</h3>
<p>To summarize file structure:</p>
<ol>
<li>Header: 48 bytes</li>
<li>int32 - number of items in root folder</li>
<li>Then items</li>
</ol>
<p>Each item:</p>
<ol>
<li>1 byte - 1 = file, 0 - folder</li>
<li>3 unknown bytes</li>
<li>8 zeroes</li>
<li>Name, null-terminated string, padded with zero bytes to have total length a multiple of 4</li>
<li>Fields, depending on type</li>
</ol>
<p>Fields for file:</p>
<ol>
<li>int32 - size</li>
<li>int32 - size again, same value</li>
<li>int32 - unknown</li>
<li>int32 - offset</li>
</ol>
<p>Fields for folder:</p>
<ol>
<li>int32 - number of items</li>
</ol>
<p>Here is code to read structure like this:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IdxReader</span>():
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, filename</span>):
        self.file = <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">'rb'</span>)
        self.file.seek(<span class="hljs-number">48</span>) <span class="hljs-comment"># skip header</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_int</span>(<span class="hljs-params">self</span>):
        data = self.file.read(<span class="hljs-number">4</span>)
        decoded = struct.unpack(<span class="hljs-string">'&#x3C;l'</span>, data) <span class="hljs-comment"># unpack it as little-endian int</span>
        <span class="hljs-keyword">return</span> decoded[<span class="hljs-number">0</span>]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_string</span>(<span class="hljs-params">self</span>):
        res = []
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            c = self.file.read(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]
            <span class="hljs-keyword">if</span> c == <span class="hljs-number">0</span>:
                pad = self.file.tell() % <span class="hljs-number">4</span>
                <span class="hljs-keyword">if</span> pad > <span class="hljs-number">0</span>:
                    self.file.read(<span class="hljs-number">4</span> - pad)
                <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>.join(res)
            res.append(<span class="hljs-built_in">chr</span>(c))
        <span class="hljs-keyword">return</span> res

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_item</span>(<span class="hljs-params">self</span>):
        is_file = self.file.read(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>] <span class="hljs-comment"># type of item</span>
        self.file.read(<span class="hljs-number">3</span>) <span class="hljs-comment"># unknown bytes</span>
        self.file.read(<span class="hljs-number">8</span>) <span class="hljs-comment"># zeroes</span>
        name = self.read_string()
        <span class="hljs-built_in">print</span>(name)
        <span class="hljs-keyword">if</span> is_file == <span class="hljs-number">1</span>:
            size, offset = self.read_file_fields()
            <span class="hljs-built_in">print</span>(<span class="hljs-string">'\tfile'</span>, size, offset)
        <span class="hljs-keyword">else</span>:
            self.read_folder()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_folder</span>(<span class="hljs-params">self</span>):
        n = self.read_int()
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'\tfolder'</span>, n)
        res = []
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
            entry = self.read_item()
            res.append(entry)
        <span class="hljs-keyword">return</span> res

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_file_fields</span>(<span class="hljs-params">self</span>):
        data = self.file.read(<span class="hljs-number">16</span>)
        size1, size2, offset = struct.unpack(<span class="hljs-string">'&#x3C;llxxxxl'</span>, data)
        <span class="hljs-keyword">assert</span> size1 == size2
        <span class="hljs-keyword">return</span> size1, offset

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> (<span class="hljs-string">'root'</span>, self.read_folder())

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self, <span class="hljs-built_in">type</span>, value, traceback</span>):
        self.file.close()</code></pre>
<p>It fails, because data for file <code>b_lights.nif</code> have additional 4 bytes.  I suspect this is because before that, unknown field between size and offset had value 1, and for this file it is 2. Probably that means additional fields.</p>
<p>After fixing that, by replacing method <code>read_file_fields</code> with</p>
<pre><code class="hljs language-python">        data = self.file.read(<span class="hljs-number">16</span>)
        size1, size2, pad, offset = struct.unpack(<span class="hljs-string">'&#x3C;llll'</span>, data)
        self.file.read((pad - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span>) <span class="hljs-comment"># skip some unknown values</span>
        <span class="hljs-keyword">return</span> size1, offset</code></pre>
<p><code>.idx</code> file seems to be read without problems.</p>
<h2 id="unpacking-archive">Unpacking archive</h2>
<p>I put the final code of unpacker in <a href="https://gist.github.com/bunyk/f17e991cd9566b7fe6dc82ff2d5f9992">this gist</a>, to not overload the post with code.</p>
<p>Only the models from <code>data/nif</code> folder are loading in Blender, models from <code>tracks</code> and <code>vehicle</code> folder crash it, or give error like this:</p>
<pre><code>Executing - Niftools : Blender Niftools Addon v0.0.13(running on Blender 2.82 (sub 7), PyFFI 2.2.4.dev3)
Importing /home/tbunyk/projects/lrwc/unpacked/data/vehicle/b_cop01.nif
NIF file version: 4020100
Reading file
Game set to 'DARK_AGE_OF_CAMELOT', but multiple games qualified
Importing data
Scale Correction set to 0.10000000149011612
Skipped unsupported root block type '&#x3C;struct 'NiPixelData'>' (corrupted nif?).
Finished
</code></pre>
<p>Probably I need to debug Blender Niftools Addon, or maybe check if there is open ticket about this, but that would be another story.</p>
<h2 id="see-also">See also</h2>
<ul>
<li><a href="http://wiki.xentax.com/index.php/DGTEFF">THE DEFINITIVE GUIDE TO EXPLORING FILE FORMATS</a> - provided a lot of helpful advice. For example it said that strings could be padded, so values align, which nudged me display bytes in groups of 4.</li>
</ul></div></article><div><div id="disqus_thread"></div></div><nav><a href="/">Home</a><a href="#top">Back to top</a></nav><footer>Â© <!-- -->2022<!-- --> Bunyk Taras. Built with Next.js</footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"reverse_engineering_game_archive","title":"Reverse engineering game archive of London Racer: World Challenge","date":"2022-02-12T18:45:07.000Z","updated_at":"2022-02-12T17:58:04+01:00","content":"\u003cp\u003e\"London Racer: World Challenge\" is fun old racing game. I like it because of nostalgia (I last played it around 2005). And among other places you could also race in Berlin. Game mechanics reminds me of Super Tux Cart.\u003c/p\u003e\n\u003cp\u003eWikipedia says that \"Davilex closed the game division in 2005 because it was not profitable enough, and their games were generally not well received\".  But it also says that Germans even made a movie based on a game \u003ca href=\"https://de.wikipedia.org/wiki/Autobahnraser_(Film)\"\u003eAutobahnraser\u003c/a\u003e, so I would say that's a great success.\u003c/p\u003e\n\u003cp\u003eBut unfortunately the game does not run on my computer, even with Wine.\nIt would be interesting to extract model of some Berlin streets from there. Or car models. Maybe I'll even manage to put them into Super Tux Cart, will see.\u003c/p\u003e\n\u003cp\u003eYou could download it from \u003ca href=\"https://www.myabandonware.com/game/london-racer-world-challenge-e5l\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eApart from \u003ccode\u003eWR.exe\u003c/code\u003e, archive with game contains files with game data: \u003ccode\u003eWR.idx\u003c/code\u003e and \u003ccode\u003eWR.img\u003c/code\u003e\nFirst one contains list of file names, and second one - their contents. Offsets are stored somewhere in idx, but format of idx file is not clear. \u003ccode\u003e.img\u003c/code\u003e file looks like just concatenated files of the game.\u003c/p\u003e\n\u003ch2 id=\"extracting-from-img-file\"\u003eExtracting from .img file\u003c/h2\u003e\n\u003cp\u003eEvery \u003ccode\u003e.nif\u003c/code\u003e file seems to start with the string \"NetImmerse File Format, Version 4.2.1.0\". We could use that to split them:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eopen\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'WR.img'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'rb'\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e f:\n\tdata = f.read()\n\nchunks = data.split(\u003cspan class=\"hljs-string\"\u003eb'NetImmerse'\u003c/span\u003e)\n\nchunks = [\u003cspan class=\"hljs-string\"\u003eb'NetImmerse'\u003c/span\u003e + c \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e c \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e chunks \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e c.startswith(\u003cspan class=\"hljs-string\"\u003eb' File Format'\u003c/span\u003e)]\n\n\u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eopen\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'some.nif'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'wb'\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e f:\n\tf.write(chunks[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e])\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"installing-blender-and-niftools-addon\"\u003eInstalling Blender and NifTools Addon\u003c/h2\u003e\n\u003cp\u003eNetImmerse was popular game engine, used for such games as Morrowind, Fallout and many others. And there is huge community of modders that created tools to work with \u003ccode\u003e.nif\u003c/code\u003e files.\u003c/p\u003e\n\u003cp\u003eHere is \u003ca href=\"https://blender-niftools-addon.readthedocs.io/en/latest/user/install.html\"\u003ethe instruction to install .nif addon for Blender\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eAfter doing what instruction says, \u003ccode\u003esome.nif\u003c/code\u003e will open, and show a model of wrench:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/content/wrench_model.png\" alt=\"Wrench model\"\u003e\u003c/p\u003e\n\u003cp\u003eThat is \u003ccode\u003erepairsmall.nif\u003c/code\u003e I would guess. In the game you hit that wrench to repair damage done to your car by other objects that you hit.\u003c/p\u003e\n\u003ch2 id=\"decoding-idx\"\u003eDecoding .idx\u003c/h2\u003e\n\u003cp\u003eSome other chunks would not open with the Blender addon, and It would be interesting to know which are which, so let's try to figure out the structure of .idx\u003c/p\u003e\n\u003ch3 id=\"looking-for-offsets\"\u003eLooking for offsets\u003c/h3\u003e\n\u003cp\u003eOffset of first \u003ccode\u003e.nif\u003c/code\u003e file was 0xFA4. Looking for byte with value A4 gives one at some distance after string \u003ccode\u003erepairsmall.nif\u003c/code\u003e. After it there is a byte 07. That means little-endian format.\u003c/p\u003e\n\u003cp\u003eWhile I was trying to calculate distances from filename field to offset field, I found the page that describes format for another version of racing game from the same developer - \u003ca href=\"http://wiki.xentax.com/index.php/London_Racer:_Police_Madness_IDX\"\u003eLondon Racer: Police Madness\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eIt gives some important tips. Image file is indeed just concatenated files, but index is a little bit more complex. It contains also directories. That is the correct suggestion from that page. Another correct suggestion was that size of file is stored in index twice. But unfortunately offsets and sizes of the fields do not match.\u003c/p\u003e\n\u003cp\u003eI wrote some python snippets to load binary data, and do a search in it. To test hypothesis that file offset should have constant distance from file name.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e struct \n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e string\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e re\n\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eload_file\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efn\u003c/span\u003e): \n    \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eopen\u003c/span\u003e(fn, \u003cspan class=\"hljs-string\"\u003e'rb'\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e f:\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e f.read()\n\n\u003cspan class=\"hljs-comment\"\u003e# Find all offsets of pattern in data\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eall_offsets\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003epattern, data\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [m.start() \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e m \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e re.finditer(pattern, data)]\n\nimg = load_file(\u003cspan class=\"hljs-string\"\u003e'WR.img'\u003c/span\u003e)\nidx = load_file(\u003cspan class=\"hljs-string\"\u003e'WR.idx'\u003c/span\u003e)\n\nnif_offsets = all_offsets(\u003cspan class=\"hljs-string\"\u003eb'NetImmerse File Format'\u003c/span\u003e, img)\n\n\u003cspan class=\"hljs-comment\"\u003e# offsets of nif file offsets in idx.file\u003c/span\u003e\nnif_offset_offsets = [\n    idx.find(struct.pack(\u003cspan class=\"hljs-string\"\u003e'\u0026#x3C;i'\u003c/span\u003e, o)) \u003cspan class=\"hljs-comment\"\u003e# search for given integer in little-endian format\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e o \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e nif_offsets\n]\n\n\u003cspan class=\"hljs-comment\"\u003e# offsets of ends of names of niff files - 4 bytes\u003c/span\u003e\nnif_name_offsets = all_offsets(\u003cspan class=\"hljs-string\"\u003eb'\\.nif\\x00'\u003c/span\u003e, idx)\n\n\n\u003cspan class=\"hljs-comment\"\u003e# Distance between the two\u003c/span\u003e\n[b-a \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e a, b \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ezip\u003c/span\u003e(nif_name_offsets[:\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e], nif_offset_offsets[:\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e])]\n[\u003cspan class=\"hljs-number\"\u003e17\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e19\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e18\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e17\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e18\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1420\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1428\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1436\u003c/span\u003e]\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHm, not always the same.\u003c/p\u003e\n\u003ch3 id=\"looking-at-the-hex\"\u003eLooking at the hex\u003c/h3\u003e\n\u003cp\u003eI also tried some hex editors. Hexinator is fancy one, where you could comment and mark different bytes with different colors. But it crashed for me, so I uninstalled it. Ghex is simple one, and I don't use hex editors so often, so I kept it. But lack of color was making it hard to look at all that numbers, so I wrote short function to pretty print binary.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003enocolor = \u003cspan class=\"hljs-string\"\u003e\"\\033[0m\"\u003c/span\u003e\nred = \u003cspan class=\"hljs-string\"\u003e\"\\033[31m\"\u003c/span\u003e\ngreen = \u003cspan class=\"hljs-string\"\u003e\"\\033[92m\"\u003c/span\u003e\n\nvisible_charset = \u003cspan class=\"hljs-built_in\"\u003ebytes\u003c/span\u003e(string.digits + string.ascii_letters + string.punctuation + \u003cspan class=\"hljs-string\"\u003e' '\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'ascii'\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eis_visible\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eb\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e b \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e visible_charset\n\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003epprint\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edata, columns=\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, column_width=\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i, b \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eenumerate\u003c/span\u003e(data):\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e i % (column_width * columns) == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e:\n            \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e()\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e i % column_width == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e:\n            \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(end=\u003cspan class=\"hljs-string\"\u003e'  '\u003c/span\u003e)\n        \n        r = \u003cspan class=\"hljs-string\"\u003e'%02X'\u003c/span\u003e % b\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e is_visible(b):\n            r = \u003cspan class=\"hljs-string\"\u003e'%s%2s%s'\u003c/span\u003e % (green, \u003cspan class=\"hljs-built_in\"\u003echr\u003c/span\u003e(b), nocolor)\n\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e b == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e:\n            r = \u003cspan class=\"hljs-string\"\u003e'%s 0%s'\u003c/span\u003e % (red, nocolor)\n\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(r, end=\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e)\n    \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e()\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt prints string values in green, zero bytes in red, and everything else as hexadecimal numbers in white. In groups of 4 bytes:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/content/idx_hex_view.png\" alt=\"Hex view\" title=\"HEX view of head of WR.idx file\"\u003e\u003c/p\u003e\n\u003cp\u003eGrouping by 4 bytes helps the most. From there you see that after the name of the file there are two repeating groups of 4 bytes. For example after \u003ccode\u003ewr.ini\u003c/code\u003e - \u003ccode\u003e840F 0 0\u003c/code\u003e and again \u003ccode\u003e840F 0 0\u003c/code\u003e. After \u003ccode\u003erepairsmall.nif\u003c/code\u003e - \u003ccode\u003eA7 8 0 0\u003c/code\u003e. I checked - size of file with that wrench is 14503 bytes, which is \u003ccode\u003e0x38A7\u003c/code\u003e in hex or \u003ccode\u003eA7 38 00 00\u003c/code\u003e in little-endian format. That \u003ccode\u003e8\u003c/code\u003e is green, which means ASCII, and ASCII code of character '8' is  56 or 38 in hex.\u003c/p\u003e\n\u003cp\u003eFilenames end with byte \u003ccode\u003e0\u003c/code\u003e , like proper C strings, but if position of next byte is not divisible by 4, more zero bytes are added for padding. That explains small variations in distances between filenames and offsets of offsets.\u003c/p\u003e\n\u003cp\u003eAfter that two fields, goes another unknown 32-bit field, and then 32-bit offset of file. Then another unknown 4 bytes, and then 8 zero bytes. Or we could look at that from the other point of view, and say that each filename record starts from 8 zero bytes. Directory names also seems to be prefixed by 8 zero bytes. Apart from that, they seem to contain 8 bytes of data. Some of that bytes probably should be number of directories.\u003c/p\u003e\n\u003cp\u003eSince first string in index after the header seems to be file, some values preceding it are probably data for the root directory. Maybe \u003ccode\u003e2\u003c/code\u003e is number of objects in the root directory? \u003ccode\u003ewr.ini\u003c/code\u003e and \u003ccode\u003edata\u003c/code\u003e? Otherwise it's \u003ccode\u003e01 008 0\u003c/code\u003e, which corresponds to \u003ccode\u003e524289\u003c/code\u003e and seems too much.\u003c/p\u003e\n\u003ch3 id=\"trying-to-unpack\"\u003eTrying to unpack\u003c/h3\u003e\n\u003cp\u003eTo summarize file structure:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eHeader: 48 bytes\u003c/li\u003e\n\u003cli\u003eint32 - number of items in root folder\u003c/li\u003e\n\u003cli\u003eThen items\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eEach item:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e1 byte - 1 = file, 0 - folder\u003c/li\u003e\n\u003cli\u003e3 unknown bytes\u003c/li\u003e\n\u003cli\u003e8 zeroes\u003c/li\u003e\n\u003cli\u003eName, null-terminated string, padded with zero bytes to have total length a multiple of 4\u003c/li\u003e\n\u003cli\u003eFields, depending on type\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eFields for file:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eint32 - size\u003c/li\u003e\n\u003cli\u003eint32 - size again, same value\u003c/li\u003e\n\u003cli\u003eint32 - unknown\u003c/li\u003e\n\u003cli\u003eint32 - offset\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eFields for folder:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eint32 - number of items\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eHere is code to read structure like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIdxReader\u003c/span\u003e():\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, filename\u003c/span\u003e):\n        self.file = \u003cspan class=\"hljs-built_in\"\u003eopen\u003c/span\u003e(filename, \u003cspan class=\"hljs-string\"\u003e'rb'\u003c/span\u003e)\n        self.file.seek(\u003cspan class=\"hljs-number\"\u003e48\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e# skip header\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eread_int\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e):\n        data = self.file.read(\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e)\n        decoded = struct.unpack(\u003cspan class=\"hljs-string\"\u003e'\u0026#x3C;l'\u003c/span\u003e, data) \u003cspan class=\"hljs-comment\"\u003e# unpack it as little-endian int\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e decoded[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eread_string\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e):\n        res = []\n        \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e:\n            c = self.file.read(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e c == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e:\n                pad = self.file.tell() % \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e\n                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e pad \u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e:\n                    self.file.read(\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e - pad)\n                \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e.join(res)\n            res.append(\u003cspan class=\"hljs-built_in\"\u003echr\u003c/span\u003e(c))\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e res\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eread_item\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e):\n        is_file = self.file.read(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] \u003cspan class=\"hljs-comment\"\u003e# type of item\u003c/span\u003e\n        self.file.read(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e# unknown bytes\u003c/span\u003e\n        self.file.read(\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e# zeroes\u003c/span\u003e\n        name = self.read_string()\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(name)\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e is_file == \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e:\n            size, offset = self.read_file_fields()\n            \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'\\tfile'\u003c/span\u003e, size, offset)\n        \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e:\n            self.read_folder()\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eread_folder\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e):\n        n = self.read_int()\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'\\tfolder'\u003c/span\u003e, n)\n        res = []\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003erange\u003c/span\u003e(n):\n            entry = self.read_item()\n            res.append(entry)\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e res\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eread_file_fields\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e):\n        data = self.file.read(\u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e)\n        size1, size2, offset = struct.unpack(\u003cspan class=\"hljs-string\"\u003e'\u0026#x3C;llxxxxl'\u003c/span\u003e, data)\n        \u003cspan class=\"hljs-keyword\"\u003eassert\u003c/span\u003e size1 == size2\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e size1, offset\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__enter__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e):\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\u003cspan class=\"hljs-string\"\u003e'root'\u003c/span\u003e, self.read_folder())\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__exit__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, \u003cspan class=\"hljs-built_in\"\u003etype\u003c/span\u003e, value, traceback\u003c/span\u003e):\n        self.file.close()\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt fails, because data for file \u003ccode\u003eb_lights.nif\u003c/code\u003e have additional 4 bytes.  I suspect this is because before that, unknown field between size and offset had value 1, and for this file it is 2. Probably that means additional fields.\u003c/p\u003e\n\u003cp\u003eAfter fixing that, by replacing method \u003ccode\u003eread_file_fields\u003c/code\u003e with\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e        data = self.file.read(\u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e)\n        size1, size2, pad, offset = struct.unpack(\u003cspan class=\"hljs-string\"\u003e'\u0026#x3C;llll'\u003c/span\u003e, data)\n        self.file.read((pad - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) * \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e# skip some unknown values\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e size1, offset\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e.idx\u003c/code\u003e file seems to be read without problems.\u003c/p\u003e\n\u003ch2 id=\"unpacking-archive\"\u003eUnpacking archive\u003c/h2\u003e\n\u003cp\u003eI put the final code of unpacker in \u003ca href=\"https://gist.github.com/bunyk/f17e991cd9566b7fe6dc82ff2d5f9992\"\u003ethis gist\u003c/a\u003e, to not overload the post with code.\u003c/p\u003e\n\u003cp\u003eOnly the models from \u003ccode\u003edata/nif\u003c/code\u003e folder are loading in Blender, models from \u003ccode\u003etracks\u003c/code\u003e and \u003ccode\u003evehicle\u003c/code\u003e folder crash it, or give error like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eExecuting - Niftools : Blender Niftools Addon v0.0.13(running on Blender 2.82 (sub 7), PyFFI 2.2.4.dev3)\nImporting /home/tbunyk/projects/lrwc/unpacked/data/vehicle/b_cop01.nif\nNIF file version: 4020100\nReading file\nGame set to 'DARK_AGE_OF_CAMELOT', but multiple games qualified\nImporting data\nScale Correction set to 0.10000000149011612\nSkipped unsupported root block type '\u0026#x3C;struct 'NiPixelData'\u003e' (corrupted nif?).\nFinished\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eProbably I need to debug Blender Niftools Addon, or maybe check if there is open ticket about this, but that would be another story.\u003c/p\u003e\n\u003ch2 id=\"see-also\"\u003eSee also\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"http://wiki.xentax.com/index.php/DGTEFF\"\u003eTHE DEFINITIVE GUIDE TO EXPLORING FILE FORMATS\u003c/a\u003e - provided a lot of helpful advice. For example it said that strings could be padded, so values align, which nudged me display bytes in groups of 4.\u003c/li\u003e\n\u003c/ul\u003e"},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"reverse_engineering_game_archive"},"buildId":"EMWktbA1TX6NqXCAYKEiA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>