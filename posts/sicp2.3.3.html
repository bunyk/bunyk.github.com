<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>SICP 2.3.3 Representing sets</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/b53cc6ef9e9e352d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b53cc6ef9e9e352d.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-959cc2ac3c742fb4.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ec0fdebf93e8fc69.js" defer=""></script><script src="/_next/static/chunks/996-372da0b0d3708a80.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-959ba1136e063a38.js" defer=""></script><script src="/_next/static/sW-wDccd-ZCyzGzfnKrfa/_buildManifest.js" defer=""></script><script src="/_next/static/sW-wDccd-ZCyzGzfnKrfa/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><h1 id="top">Taras Bunyk</h1><nav><a href="/">Home</a><a href="http://bunyk.github.io/mandala/">Snowflake drawing</a><a href="/resume">Resume</a><a href="https://bunyk.wordpress.com/">Old blog (in Ukrainian)</a></nav><article><h1>SICP 2.3.3 Representing sets</h1><div><em>Published: 2020-07-28T21:59:22.000Z</em></div><div><p>This was more boring in comparison to previous section, probably because it required writing less code, and just writing more explanations. Writing is thinking, so I tried to do that. Or maybe it was boring because sets are not as exciting as symbolic differentiation. At least when you have high level language.</p>
<h2 id="exercise-259">Exercise 2.59</h2>
<pre><code class="hljs language-scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> (<span class="hljs-name">element-of-set?</span> x set)
  (<span class="hljs-name"><span class="hljs-built_in">cond</span></span> ((<span class="hljs-name"><span class="hljs-built_in">null?</span></span> set) false)
        ((<span class="hljs-name"><span class="hljs-built_in">equal?</span></span> x (<span class="hljs-name"><span class="hljs-built_in">car</span></span> set)) true)
        (<span class="hljs-name"><span class="hljs-built_in">else</span></span> (<span class="hljs-name">element-of-set?</span> x (<span class="hljs-name"><span class="hljs-built_in">cdr</span></span> set)))))

(<span class="hljs-name"><span class="hljs-built_in">define</span></span> (<span class="hljs-name">adjoin-set</span> x set)
  (<span class="hljs-name"><span class="hljs-built_in">if</span></span> (<span class="hljs-name">element-of-set?</span> x set)
      set
      (<span class="hljs-name"><span class="hljs-built_in">cons</span></span> x set)))

(<span class="hljs-name"><span class="hljs-built_in">define</span></span> (<span class="hljs-name">union-set</span> set1 set2)
  (<span class="hljs-name">fold-left</span>
    (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (union next) (<span class="hljs-name">adjoin-set</span> next union))
    set1
    set2
  )
)</code></pre>
<h2 id="exercise-260">Exercise 2.60</h2>
<pre><code class="hljs language-scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> (<span class="hljs-name">element-of-set?</span> x set)
  (<span class="hljs-name"><span class="hljs-built_in">cond</span></span> ((<span class="hljs-name"><span class="hljs-built_in">null?</span></span> set) false)
        ((<span class="hljs-name"><span class="hljs-built_in">equal?</span></span> x (<span class="hljs-name"><span class="hljs-built_in">car</span></span> set)) true)
        (<span class="hljs-name"><span class="hljs-built_in">else</span></span> (<span class="hljs-name">element-of-set?</span> x (<span class="hljs-name"><span class="hljs-built_in">cdr</span></span> set)))))</code></pre>
<p>O(n), as unique one, but here list could be way longer, so less performant.</p>
<pre><code class="hljs language-scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> (<span class="hljs-name">adjoin-set</span> x set)
  (<span class="hljs-name"><span class="hljs-built_in">cons</span></span> x set)
)</code></pre>
<p>O(1), lot better than unique one ( O(n)), because we not checking uniqueness.</p>
<pre><code class="hljs language-scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> (<span class="hljs-name">union-set</span> set1 set2)
  (<span class="hljs-name"><span class="hljs-built_in">append</span></span> set1 set2)
)</code></pre>
<p>Append has complexity O(n) = O(len(set1)) if I'm not mistaken. O(n), better than O(n2).</p>
<pre><code class="hljs language-scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> (<span class="hljs-name">intersection-set</span> set1 set2)
  (<span class="hljs-name"><span class="hljs-built_in">cond</span></span> ((<span class="hljs-name"><span class="hljs-built_in">or</span></span> (<span class="hljs-name"><span class="hljs-built_in">null?</span></span> set1) (<span class="hljs-name"><span class="hljs-built_in">null?</span></span> set2)) '())
        ((<span class="hljs-name">element-of-set?</span> (<span class="hljs-name"><span class="hljs-built_in">car</span></span> set1) set2)        
         (<span class="hljs-name"><span class="hljs-built_in">cons</span></span> (<span class="hljs-name"><span class="hljs-built_in">car</span></span> set1)
               (<span class="hljs-name">intersection-set</span> (<span class="hljs-name"><span class="hljs-built_in">cdr</span></span> set1) set2)))
        (<span class="hljs-name"><span class="hljs-built_in">else</span></span> (<span class="hljs-name">intersection-set</span> (<span class="hljs-name"><span class="hljs-built_in">cdr</span></span> set1) set2))))</code></pre>
<p>Intersection has same implementation and as a result same asymptotic complexity O(n2), but we expect n to be a lot larger.</p>
<p>So, this approach would suit applications where we will do a lot of adjoins and unions, and not much checking for element or intersections.</p>
<h2 id="exercise-261">Exercise 2.61</h2>
<pre><code class="hljs language-scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> (<span class="hljs-name">adjoin-set</span> x set)
  (<span class="hljs-name"><span class="hljs-built_in">cond</span></span> ((<span class="hljs-name"><span class="hljs-built_in">or</span></span> (<span class="hljs-name"><span class="hljs-built_in">null?</span></span> set) (<span class="hljs-name"><span class="hljs-built_in">&#x3C;</span></span> x (<span class="hljs-name"><span class="hljs-built_in">car</span></span> set))) (<span class="hljs-name"><span class="hljs-built_in">cons</span></span> x set))
        ((<span class="hljs-name"><span class="hljs-built_in">=</span></span> x (<span class="hljs-name"><span class="hljs-built_in">car</span></span> set)) set)
        (<span class="hljs-name"><span class="hljs-built_in">else</span></span> (<span class="hljs-name"><span class="hljs-built_in">cons</span></span> (<span class="hljs-name"><span class="hljs-built_in">car</span></span> set) (<span class="hljs-name">adjoin-set</span> x (<span class="hljs-name"><span class="hljs-built_in">cdr</span></span> set))))))

(<span class="hljs-name">adjoin-set</span> <span class="hljs-number">0</span> (<span class="hljs-name"><span class="hljs-built_in">list</span></span> <span class="hljs-number">1</span> <span class="hljs-number">3</span>))
(<span class="hljs-name">adjoin-set</span> <span class="hljs-number">1</span> (<span class="hljs-name"><span class="hljs-built_in">list</span></span> <span class="hljs-number">1</span> <span class="hljs-number">3</span>))
(<span class="hljs-name">adjoin-set</span> <span class="hljs-number">2</span> (<span class="hljs-name"><span class="hljs-built_in">list</span></span> <span class="hljs-number">1</span> <span class="hljs-number">3</span>))
(<span class="hljs-name">adjoin-set</span> <span class="hljs-number">4</span> (<span class="hljs-name"><span class="hljs-built_in">list</span></span> <span class="hljs-number">1</span> <span class="hljs-number">3</span>))</code></pre>
<h2 id="exercise-262">Exercise 2.62</h2>
<pre><code class="hljs language-scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> (<span class="hljs-name">union-set</span> set1 set2)
    (<span class="hljs-name"><span class="hljs-built_in">cond</span></span>
        ((<span class="hljs-name"><span class="hljs-built_in">null?</span></span> set1) set2)
        ((<span class="hljs-name"><span class="hljs-built_in">null?</span></span> set2) set1)
        ((<span class="hljs-name"><span class="hljs-built_in">&#x3C;</span></span> (<span class="hljs-name"><span class="hljs-built_in">car</span></span> set1) (<span class="hljs-name"><span class="hljs-built_in">car</span></span> set2)) (<span class="hljs-name"><span class="hljs-built_in">cons</span></span> (<span class="hljs-name"><span class="hljs-built_in">car</span></span> set1) (<span class="hljs-name">union-set</span> (<span class="hljs-name"><span class="hljs-built_in">cdr</span></span> set1) set2)))
        (<span class="hljs-name"><span class="hljs-built_in">else</span></span> (<span class="hljs-name"><span class="hljs-built_in">cons</span></span> (<span class="hljs-name"><span class="hljs-built_in">car</span></span> set2) (<span class="hljs-name">union-set</span> set1 (<span class="hljs-name"><span class="hljs-built_in">cdr</span></span> set2))))
    )
)
(<span class="hljs-name">union-set</span> (<span class="hljs-name"><span class="hljs-built_in">list</span></span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>) (<span class="hljs-name"><span class="hljs-built_in">list</span></span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>))
(<span class="hljs-name">union-set</span> (<span class="hljs-name"><span class="hljs-built_in">list</span></span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>) (<span class="hljs-name"><span class="hljs-built_in">list</span></span> <span class="hljs-number">1</span> <span class="hljs-number">4</span>))</code></pre>
<h2 id="exercise-263">Exercise 2.63</h2>
<p>a. Yes, they give same results by traversing tree from left to right.</p>
<p>b. One without <code>append</code> is better. For the second one <code>copy-to-list</code> is called for right subtree first, and then process conses current tree entry to result, then <code>copy-to-list</code> is called recursively to cons left subtree to the resulting list.</p>
<p>In case with append, we compute <code>tree->list1</code> for both subtrees simultaniously, then iterate over result for left subtree inside <code>append</code>.  Append takes O(n) time, where n is length of left argument. It is processing half of nodes in each level in the tree, which is approximately O(n log(n)).</p>
<h2 id="exercise-264">Exercise 2.64</h2>
<pre><code class="hljs language-scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> (<span class="hljs-name">list->tree</span> elements)
  (<span class="hljs-name"><span class="hljs-built_in">car</span></span> (<span class="hljs-name">partial-tree</span> elements (<span class="hljs-name"><span class="hljs-built_in">length</span></span> elements))))

(<span class="hljs-name"><span class="hljs-built_in">define</span></span> (<span class="hljs-name">partial-tree</span> elts n)
  (<span class="hljs-name"><span class="hljs-built_in">if</span></span> (<span class="hljs-name"><span class="hljs-built_in">=</span></span> n <span class="hljs-number">0</span>)
      (<span class="hljs-name"><span class="hljs-built_in">cons</span></span> '() elts)
      (<span class="hljs-name"><span class="hljs-built_in">let</span></span> ((<span class="hljs-name">left-size</span> (<span class="hljs-name"><span class="hljs-built_in">quotient</span></span> (<span class="hljs-name"><span class="hljs-built_in">-</span></span> n <span class="hljs-number">1</span>) <span class="hljs-number">2</span>)))
        (<span class="hljs-name"><span class="hljs-built_in">let</span></span> ((<span class="hljs-name">left-result</span> (<span class="hljs-name">partial-tree</span> elts left-size)))
          (<span class="hljs-name"><span class="hljs-built_in">let</span></span> ((<span class="hljs-name">left-tree</span> (<span class="hljs-name"><span class="hljs-built_in">car</span></span> left-result))
                (<span class="hljs-name">non-left-elts</span> (<span class="hljs-name"><span class="hljs-built_in">cdr</span></span> left-result))
                (<span class="hljs-name">right-size</span> (<span class="hljs-name"><span class="hljs-built_in">-</span></span> n (<span class="hljs-name"><span class="hljs-built_in">+</span></span> left-size <span class="hljs-number">1</span>))))
            (<span class="hljs-name"><span class="hljs-built_in">let</span></span> ((<span class="hljs-name">this-entry</span> (<span class="hljs-name"><span class="hljs-built_in">car</span></span> non-left-elts))
                  (<span class="hljs-name">right-result</span> (<span class="hljs-name">partial-tree</span> (<span class="hljs-name"><span class="hljs-built_in">cdr</span></span> non-left-elts)
                                              right-size)))
              (<span class="hljs-name"><span class="hljs-built_in">let</span></span> ((<span class="hljs-name">right-tree</span> (<span class="hljs-name"><span class="hljs-built_in">car</span></span> right-result))
                    (<span class="hljs-name">remaining-elts</span> (<span class="hljs-name"><span class="hljs-built_in">cdr</span></span> right-result)))
                (<span class="hljs-name"><span class="hljs-built_in">cons</span></span> (<span class="hljs-name">make-tree</span> this-entry left-tree right-tree)
                      remaining-elts))))))))</code></pre>
<p><code>partial-tree</code> takes as arguments <code>elts</code> - list of elements, and integer <code>n</code> and returns pair whose <code>car</code> is balanced tree containing the first <code>n</code> elements of the list and <code>cdr</code> is the list of elements not included in the tree.</p>
<p>If we need to construct tree with 0 elements, we just return empty tree and list provided to us. Otherwise, we will have tree with one element in root, and subtrees. Size of subtrees will be (n-1) / 2 (remaining amount of elements appriximately equally split for each subtree). First we build left subtree and obtain remaining elements. First of the remaining elements goes into root of our tree, the rest - to building right subtree. After we have both subtrees attached to tree with root element, we return it, and what was left in list of elements from building right subtree.</p>
<p>So, when we have list <code>(1 3 5 7 9 11)</code>, we will have following tree:</p>
<pre><code>(5
    (1
        ()
        (3 () ())
    )
    (9
        (7 () ())
        (11 () ())
    )
)
</code></pre>
<p>b. What is the order of growth in the number of steps required by list->tree to convert a list of n elements?</p>
<p>partial-tree is called once for n = 0. For n > 0, it is called X(n), where X(n) = 2 + X( (n-1) / 2) + X(n - 1 - (n-1)/2 = (n-1)/2) => X(n) = 2 + X((n-1)/2). If X is identity function - equation is true, so X(n) = n. Order of growth is linear.</p>
<h2 id="exercise-265">Exercise 2.65</h2>
<p>Finally coding and not writing essays. I'm bad at essays (probably need another textbook on this topic, but how to test myself?)</p>
<p>I imagine we convert both trees to ordered lists, then use operations on ordered lists described in previous section, then convert back to trees. All of this operations take O(n).</p>
<pre><code class="hljs language-scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> (<span class="hljs-name">union-set</span> s1 s2)
  (<span class="hljs-name">list->tree</span> (<span class="hljs-name">list-union-set</span> (<span class="hljs-name">tree->list2</span> s1) (<span class="hljs-name">tree->list2</span>)))
)</code></pre>
<p>Same for intersection, just call different function. I'm even not going to test this code, as it will be more effort than writing it.</p>
<h2 id="exercise-266">Exercise 2.66</h2>
<pre><code class="hljs language-scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> (<span class="hljs-name">lookup</span> given-key set-of-records)
  (<span class="hljs-name"><span class="hljs-built_in">cond</span></span> ((<span class="hljs-name"><span class="hljs-built_in">null?</span></span> set-of-records) false)
        ((<span class="hljs-name"><span class="hljs-built_in">=</span></span> given-key (<span class="hljs-name">key</span> (<span class="hljs-name">entry</span> set-of-records)))
         (<span class="hljs-name">entry</span> set-of-records))
        ((<span class="hljs-name"><span class="hljs-built_in">&#x3C;</span></span> given-key (<span class="hljs-name">key</span> (<span class="hljs-name">entry</span> set-of-records)))
         (<span class="hljs-name">lookup</span> (<span class="hljs-name">left-branch</span> set-of-records)))
        (<span class="hljs-name"><span class="hljs-built_in">else</span></span>
         (<span class="hljs-name">lookup</span> (<span class="hljs-name">right-branch</span> set-of-records)))))</code></pre></div></article><div><div id="disqus_thread"></div></div><nav><a href="/">Home</a><a href="#top">Back to top</a></nav><footer>Â© <!-- -->2022<!-- --> Bunyk Taras. Built with Next.js</footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":"sicp2.3.3","title":"SICP 2.3.3 Representing sets","date":"2020-07-28T21:59:22.000Z","tags":["SICP"],"updated_at":"2021-04-20T00:38:16+02:00","content":"\u003cp\u003eThis was more boring in comparison to previous section, probably because it required writing less code, and just writing more explanations. Writing is thinking, so I tried to do that. Or maybe it was boring because sets are not as exciting as symbolic differentiation. At least when you have high level language.\u003c/p\u003e\n\u003ch2 id=\"exercise-259\"\u003eExercise 2.59\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-scheme\"\u003e(\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003edefine\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eelement-of-set?\u003c/span\u003e x set)\n  (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003econd\u003c/span\u003e\u003c/span\u003e ((\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003enull?\u003c/span\u003e\u003c/span\u003e set) false)\n        ((\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003eequal?\u003c/span\u003e\u003c/span\u003e x (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecar\u003c/span\u003e\u003c/span\u003e set)) true)\n        (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003eelse\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eelement-of-set?\u003c/span\u003e x (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecdr\u003c/span\u003e\u003c/span\u003e set)))))\n\n(\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003edefine\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eadjoin-set\u003c/span\u003e x set)\n  (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003eif\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eelement-of-set?\u003c/span\u003e x set)\n      set\n      (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003econs\u003c/span\u003e\u003c/span\u003e x set)))\n\n(\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003edefine\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eunion-set\u003c/span\u003e set1 set2)\n  (\u003cspan class=\"hljs-name\"\u003efold-left\u003c/span\u003e\n    (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003elambda\u003c/span\u003e\u003c/span\u003e (union next) (\u003cspan class=\"hljs-name\"\u003eadjoin-set\u003c/span\u003e next union))\n    set1\n    set2\n  )\n)\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"exercise-260\"\u003eExercise 2.60\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-scheme\"\u003e(\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003edefine\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eelement-of-set?\u003c/span\u003e x set)\n  (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003econd\u003c/span\u003e\u003c/span\u003e ((\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003enull?\u003c/span\u003e\u003c/span\u003e set) false)\n        ((\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003eequal?\u003c/span\u003e\u003c/span\u003e x (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecar\u003c/span\u003e\u003c/span\u003e set)) true)\n        (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003eelse\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eelement-of-set?\u003c/span\u003e x (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecdr\u003c/span\u003e\u003c/span\u003e set)))))\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eO(n), as unique one, but here list could be way longer, so less performant.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-scheme\"\u003e(\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003edefine\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eadjoin-set\u003c/span\u003e x set)\n  (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003econs\u003c/span\u003e\u003c/span\u003e x set)\n)\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eO(1), lot better than unique one ( O(n)), because we not checking uniqueness.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-scheme\"\u003e(\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003edefine\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eunion-set\u003c/span\u003e set1 set2)\n  (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003eappend\u003c/span\u003e\u003c/span\u003e set1 set2)\n)\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAppend has complexity O(n) = O(len(set1)) if I'm not mistaken. O(n), better than O(n2).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-scheme\"\u003e(\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003edefine\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eintersection-set\u003c/span\u003e set1 set2)\n  (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003econd\u003c/span\u003e\u003c/span\u003e ((\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003eor\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003enull?\u003c/span\u003e\u003c/span\u003e set1) (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003enull?\u003c/span\u003e\u003c/span\u003e set2)) '())\n        ((\u003cspan class=\"hljs-name\"\u003eelement-of-set?\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecar\u003c/span\u003e\u003c/span\u003e set1) set2)        \n         (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003econs\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecar\u003c/span\u003e\u003c/span\u003e set1)\n               (\u003cspan class=\"hljs-name\"\u003eintersection-set\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecdr\u003c/span\u003e\u003c/span\u003e set1) set2)))\n        (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003eelse\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eintersection-set\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecdr\u003c/span\u003e\u003c/span\u003e set1) set2))))\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIntersection has same implementation and as a result same asymptotic complexity O(n2), but we expect n to be a lot larger.\u003c/p\u003e\n\u003cp\u003eSo, this approach would suit applications where we will do a lot of adjoins and unions, and not much checking for element or intersections.\u003c/p\u003e\n\u003ch2 id=\"exercise-261\"\u003eExercise 2.61\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-scheme\"\u003e(\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003edefine\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eadjoin-set\u003c/span\u003e x set)\n  (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003econd\u003c/span\u003e\u003c/span\u003e ((\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003eor\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003enull?\u003c/span\u003e\u003c/span\u003e set) (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003e\u0026#x3C;\u003c/span\u003e\u003c/span\u003e x (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecar\u003c/span\u003e\u003c/span\u003e set))) (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003econs\u003c/span\u003e\u003c/span\u003e x set))\n        ((\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003e=\u003c/span\u003e\u003c/span\u003e x (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecar\u003c/span\u003e\u003c/span\u003e set)) set)\n        (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003eelse\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003econs\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecar\u003c/span\u003e\u003c/span\u003e set) (\u003cspan class=\"hljs-name\"\u003eadjoin-set\u003c/span\u003e x (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecdr\u003c/span\u003e\u003c/span\u003e set))))))\n\n(\u003cspan class=\"hljs-name\"\u003eadjoin-set\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003elist\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e))\n(\u003cspan class=\"hljs-name\"\u003eadjoin-set\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003elist\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e))\n(\u003cspan class=\"hljs-name\"\u003eadjoin-set\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003elist\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e))\n(\u003cspan class=\"hljs-name\"\u003eadjoin-set\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003elist\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e))\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"exercise-262\"\u003eExercise 2.62\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-scheme\"\u003e(\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003edefine\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eunion-set\u003c/span\u003e set1 set2)\n    (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003econd\u003c/span\u003e\u003c/span\u003e\n        ((\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003enull?\u003c/span\u003e\u003c/span\u003e set1) set2)\n        ((\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003enull?\u003c/span\u003e\u003c/span\u003e set2) set1)\n        ((\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003e\u0026#x3C;\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecar\u003c/span\u003e\u003c/span\u003e set1) (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecar\u003c/span\u003e\u003c/span\u003e set2)) (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003econs\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecar\u003c/span\u003e\u003c/span\u003e set1) (\u003cspan class=\"hljs-name\"\u003eunion-set\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecdr\u003c/span\u003e\u003c/span\u003e set1) set2)))\n        (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003eelse\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003econs\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecar\u003c/span\u003e\u003c/span\u003e set2) (\u003cspan class=\"hljs-name\"\u003eunion-set\u003c/span\u003e set1 (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecdr\u003c/span\u003e\u003c/span\u003e set2))))\n    )\n)\n(\u003cspan class=\"hljs-name\"\u003eunion-set\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003elist\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e) (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003elist\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e))\n(\u003cspan class=\"hljs-name\"\u003eunion-set\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003elist\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e) (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003elist\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e))\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"exercise-263\"\u003eExercise 2.63\u003c/h2\u003e\n\u003cp\u003ea. Yes, they give same results by traversing tree from left to right.\u003c/p\u003e\n\u003cp\u003eb. One without \u003ccode\u003eappend\u003c/code\u003e is better. For the second one \u003ccode\u003ecopy-to-list\u003c/code\u003e is called for right subtree first, and then process conses current tree entry to result, then \u003ccode\u003ecopy-to-list\u003c/code\u003e is called recursively to cons left subtree to the resulting list.\u003c/p\u003e\n\u003cp\u003eIn case with append, we compute \u003ccode\u003etree-\u003elist1\u003c/code\u003e for both subtrees simultaniously, then iterate over result for left subtree inside \u003ccode\u003eappend\u003c/code\u003e.  Append takes O(n) time, where n is length of left argument. It is processing half of nodes in each level in the tree, which is approximately O(n log(n)).\u003c/p\u003e\n\u003ch2 id=\"exercise-264\"\u003eExercise 2.64\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-scheme\"\u003e(\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003edefine\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003elist-\u003etree\u003c/span\u003e elements)\n  (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecar\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003epartial-tree\u003c/span\u003e elements (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003elength\u003c/span\u003e\u003c/span\u003e elements))))\n\n(\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003edefine\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003epartial-tree\u003c/span\u003e elts n)\n  (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003eif\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003e=\u003c/span\u003e\u003c/span\u003e n \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n      (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003econs\u003c/span\u003e\u003c/span\u003e '() elts)\n      (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003elet\u003c/span\u003e\u003c/span\u003e ((\u003cspan class=\"hljs-name\"\u003eleft-size\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003equotient\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003e-\u003c/span\u003e\u003c/span\u003e n \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)))\n        (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003elet\u003c/span\u003e\u003c/span\u003e ((\u003cspan class=\"hljs-name\"\u003eleft-result\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003epartial-tree\u003c/span\u003e elts left-size)))\n          (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003elet\u003c/span\u003e\u003c/span\u003e ((\u003cspan class=\"hljs-name\"\u003eleft-tree\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecar\u003c/span\u003e\u003c/span\u003e left-result))\n                (\u003cspan class=\"hljs-name\"\u003enon-left-elts\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecdr\u003c/span\u003e\u003c/span\u003e left-result))\n                (\u003cspan class=\"hljs-name\"\u003eright-size\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003e-\u003c/span\u003e\u003c/span\u003e n (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003e+\u003c/span\u003e\u003c/span\u003e left-size \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e))))\n            (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003elet\u003c/span\u003e\u003c/span\u003e ((\u003cspan class=\"hljs-name\"\u003ethis-entry\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecar\u003c/span\u003e\u003c/span\u003e non-left-elts))\n                  (\u003cspan class=\"hljs-name\"\u003eright-result\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003epartial-tree\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecdr\u003c/span\u003e\u003c/span\u003e non-left-elts)\n                                              right-size)))\n              (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003elet\u003c/span\u003e\u003c/span\u003e ((\u003cspan class=\"hljs-name\"\u003eright-tree\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecar\u003c/span\u003e\u003c/span\u003e right-result))\n                    (\u003cspan class=\"hljs-name\"\u003eremaining-elts\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecdr\u003c/span\u003e\u003c/span\u003e right-result)))\n                (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003econs\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003emake-tree\u003c/span\u003e this-entry left-tree right-tree)\n                      remaining-elts))))))))\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003epartial-tree\u003c/code\u003e takes as arguments \u003ccode\u003eelts\u003c/code\u003e - list of elements, and integer \u003ccode\u003en\u003c/code\u003e and returns pair whose \u003ccode\u003ecar\u003c/code\u003e is balanced tree containing the first \u003ccode\u003en\u003c/code\u003e elements of the list and \u003ccode\u003ecdr\u003c/code\u003e is the list of elements not included in the tree.\u003c/p\u003e\n\u003cp\u003eIf we need to construct tree with 0 elements, we just return empty tree and list provided to us. Otherwise, we will have tree with one element in root, and subtrees. Size of subtrees will be (n-1) / 2 (remaining amount of elements appriximately equally split for each subtree). First we build left subtree and obtain remaining elements. First of the remaining elements goes into root of our tree, the rest - to building right subtree. After we have both subtrees attached to tree with root element, we return it, and what was left in list of elements from building right subtree.\u003c/p\u003e\n\u003cp\u003eSo, when we have list \u003ccode\u003e(1 3 5 7 9 11)\u003c/code\u003e, we will have following tree:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e(5\n    (1\n        ()\n        (3 () ())\n    )\n    (9\n        (7 () ())\n        (11 () ())\n    )\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eb. What is the order of growth in the number of steps required by list-\u003etree to convert a list of n elements?\u003c/p\u003e\n\u003cp\u003epartial-tree is called once for n = 0. For n \u003e 0, it is called X(n), where X(n) = 2 + X( (n-1) / 2) + X(n - 1 - (n-1)/2 = (n-1)/2) =\u003e X(n) = 2 + X((n-1)/2). If X is identity function - equation is true, so X(n) = n. Order of growth is linear.\u003c/p\u003e\n\u003ch2 id=\"exercise-265\"\u003eExercise 2.65\u003c/h2\u003e\n\u003cp\u003eFinally coding and not writing essays. I'm bad at essays (probably need another textbook on this topic, but how to test myself?)\u003c/p\u003e\n\u003cp\u003eI imagine we convert both trees to ordered lists, then use operations on ordered lists described in previous section, then convert back to trees. All of this operations take O(n).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-scheme\"\u003e(\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003edefine\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eunion-set\u003c/span\u003e s1 s2)\n  (\u003cspan class=\"hljs-name\"\u003elist-\u003etree\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003elist-union-set\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003etree-\u003elist2\u003c/span\u003e s1) (\u003cspan class=\"hljs-name\"\u003etree-\u003elist2\u003c/span\u003e)))\n)\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSame for intersection, just call different function. I'm even not going to test this code, as it will be more effort than writing it.\u003c/p\u003e\n\u003ch2 id=\"exercise-266\"\u003eExercise 2.66\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-scheme\"\u003e(\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003edefine\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003elookup\u003c/span\u003e given-key set-of-records)\n  (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003econd\u003c/span\u003e\u003c/span\u003e ((\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003enull?\u003c/span\u003e\u003c/span\u003e set-of-records) false)\n        ((\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003e=\u003c/span\u003e\u003c/span\u003e given-key (\u003cspan class=\"hljs-name\"\u003ekey\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eentry\u003c/span\u003e set-of-records)))\n         (\u003cspan class=\"hljs-name\"\u003eentry\u003c/span\u003e set-of-records))\n        ((\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003e\u0026#x3C;\u003c/span\u003e\u003c/span\u003e given-key (\u003cspan class=\"hljs-name\"\u003ekey\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eentry\u003c/span\u003e set-of-records)))\n         (\u003cspan class=\"hljs-name\"\u003elookup\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eleft-branch\u003c/span\u003e set-of-records)))\n        (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-built_in\"\u003eelse\u003c/span\u003e\u003c/span\u003e\n         (\u003cspan class=\"hljs-name\"\u003elookup\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eright-branch\u003c/span\u003e set-of-records)))))\u003c/code\u003e\u003c/pre\u003e"},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"sicp2.3.3"},"buildId":"sW-wDccd-ZCyzGzfnKrfa","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>