<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>SICP 2.3.3 Representing sets</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/688040b3fc223486cedc.css" as="style"/><link rel="stylesheet" href="/_next/static/css/688040b3fc223486cedc.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/webpack-ab63730ce14ffb2d4de2.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework-77b689d02b4bf42ce2e0.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons-131aad2d92e69c360009.js" as="script"/><link rel="preload" href="/_next/static/chunks/main-4f9408d32df08544de44.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-d383b5fdcc7af26c9ab8.js" as="script"/><link rel="preload" href="/_next/static/chunks/762-bec077d9715dbffe23e5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/%5Bid%5D-4d391b18df3a2ccf9664.js" as="script"/></head><body><div id="__next"><div class="MuiContainer-root MuiContainer-maxWidthMd"><div class="MuiToolbar-root MuiToolbar-regular jss1 MuiToolbar-gutters"><h1 class="MuiTypography-root jss2 MuiTypography-h5 MuiTypography-noWrap" aligh="center">Taras Bunyk</h1></div><nav class="MuiToolbar-root MuiToolbar-dense jss3 MuiToolbar-gutters"><a href="/">Home</a><a href="/resume">Resume</a><a href="https://bunyk.wordpress.com/">Old blog (in Ukrainian)</a></nav><div class="MuiGrid-root MuiGrid-container MuiGrid-spacing-xs-5"><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-12 MuiGrid-grid-md-9"><div class="MuiPaper-root MuiCard-root MuiPaper-elevation1 MuiPaper-rounded"><div class="MuiCardHeader-root"><div class="MuiCardHeader-content"><span class="MuiTypography-root MuiCardHeader-title MuiTypography-h5 MuiTypography-displayBlock">SICP 2.3.3 Representing sets</span><span class="MuiTypography-root MuiCardHeader-subheader MuiTypography-body1 MuiTypography-colorTextSecondary MuiTypography-displayBlock">Published: 2020-07-28 Tags: SICP</span></div></div><div class="MuiCardContent-root"><p>This was more boring in comparison to previous section, probably because it required writing less code, and just writing more explanations. Writing is thinking, so I tried to do that. Or maybe it was boring because sets are not as exciting as symbolic differentiation. At least when you have high level language.</p>
<h2>Exercise 2.59</h2>
<pre><code class="hljs language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">element-of-set?</span> x set)
  (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-builtin-name">null?</span></span> set) false)
        ((<span class="hljs-name"><span class="hljs-builtin-name">equal?</span></span> x (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> set)) true)
        (<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name">element-of-set?</span> x (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> set)))))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">adjoin-set</span> x set)
  (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name">element-of-set?</span> x set)
      set
      (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> x set)))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">union-set</span> set1 set2)
  (<span class="hljs-name">fold-left</span>
    (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (union next) (<span class="hljs-name">adjoin-set</span> next union))
    set1
    set2
  )
)</code></pre>
<h2>Exercise 2.60</h2>
<pre><code class="hljs language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">element-of-set?</span> x set)
  (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-builtin-name">null?</span></span> set) false)
        ((<span class="hljs-name"><span class="hljs-builtin-name">equal?</span></span> x (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> set)) true)
        (<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name">element-of-set?</span> x (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> set)))))</code></pre>
<p>O(n), as unique one, but here list could be way longer, so less performant.</p>
<pre><code class="hljs language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">adjoin-set</span> x set)
  (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> x set)
)</code></pre>
<p>O(1), lot better than unique one ( O(n)), because we not checking uniqueness.</p>
<pre><code class="hljs language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">union-set</span> set1 set2)
  (<span class="hljs-name"><span class="hljs-builtin-name">append</span></span> set1 set2)
)</code></pre>
<p>Append has complexity O(n) = O(len(set1)) if I'm not mistaken. O(n), better than O(n2).</p>
<pre><code class="hljs language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">intersection-set</span> set1 set2)
  (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-builtin-name">or</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">null?</span></span> set1) (<span class="hljs-name"><span class="hljs-builtin-name">null?</span></span> set2)) '())
        ((<span class="hljs-name">element-of-set?</span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> set1) set2)        
         (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> set1)
               (<span class="hljs-name">intersection-set</span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> set1) set2)))
        (<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name">intersection-set</span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> set1) set2))))</code></pre>
<p>Intersection has same implementation and as a result same asymptotic complexity O(n2), but we expect n to be a lot larger.</p>
<p>So, this approach would suit applications where we will do a lot of adjoins and unions, and not much checking for element or intersections.</p>
<h2>Exercise 2.61</h2>
<pre><code class="hljs language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">adjoin-set</span> x set)
  (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-builtin-name">or</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">null?</span></span> set) (<span class="hljs-name"><span class="hljs-builtin-name">&#x3C;</span></span> x (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> set))) (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> x set))
        ((<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> x (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> set)) set)
        (<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> set) (<span class="hljs-name">adjoin-set</span> x (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> set))))))

(<span class="hljs-name">adjoin-set</span> <span class="hljs-number">0</span> (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> <span class="hljs-number">1</span> <span class="hljs-number">3</span>))
(<span class="hljs-name">adjoin-set</span> <span class="hljs-number">1</span> (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> <span class="hljs-number">1</span> <span class="hljs-number">3</span>))
(<span class="hljs-name">adjoin-set</span> <span class="hljs-number">2</span> (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> <span class="hljs-number">1</span> <span class="hljs-number">3</span>))
(<span class="hljs-name">adjoin-set</span> <span class="hljs-number">4</span> (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> <span class="hljs-number">1</span> <span class="hljs-number">3</span>))</code></pre>
<h2>Exercise 2.62</h2>
<pre><code class="hljs language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">union-set</span> set1 set2)
    (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span>
        ((<span class="hljs-name"><span class="hljs-builtin-name">null?</span></span> set1) set2)
        ((<span class="hljs-name"><span class="hljs-builtin-name">null?</span></span> set2) set1)
        ((<span class="hljs-name"><span class="hljs-builtin-name">&#x3C;</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> set1) (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> set2)) (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> set1) (<span class="hljs-name">union-set</span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> set1) set2)))
        (<span class="hljs-name"><span class="hljs-builtin-name">else</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> set2) (<span class="hljs-name">union-set</span> set1 (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> set2))))
    )
)
(<span class="hljs-name">union-set</span> (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>) (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>))
(<span class="hljs-name">union-set</span> (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>) (<span class="hljs-name"><span class="hljs-builtin-name">list</span></span> <span class="hljs-number">1</span> <span class="hljs-number">4</span>))</code></pre>
<h2>Exercise 2.63</h2>
<p>a. Yes, they give same results by traversing tree from left to right.</p>
<p>b. One without <code>append</code> is better. For the second one <code>copy-to-list</code> is called for right subtree first, and then process conses current tree entry to result, then <code>copy-to-list</code> is called recursively to cons left subtree to the resulting list.</p>
<p>In case with append, we compute <code>tree->list1</code> for both subtrees simultaniously, then iterate over result for left subtree inside <code>append</code>.  Append takes O(n) time, where n is length of left argument. It is processing half of nodes in each level in the tree, which is approximately O(n log(n)).</p>
<h2>Exercise 2.64</h2>
<pre><code class="hljs language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">list->tree</span> elements)
  (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> (<span class="hljs-name">partial-tree</span> elements (<span class="hljs-name"><span class="hljs-builtin-name">length</span></span> elements))))

(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">partial-tree</span> elts n)
  (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> n <span class="hljs-number">0</span>)
      (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> '() elts)
      (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ((<span class="hljs-name">left-size</span> (<span class="hljs-name"><span class="hljs-builtin-name">quotient</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> n <span class="hljs-number">1</span>) <span class="hljs-number">2</span>)))
        (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ((<span class="hljs-name">left-result</span> (<span class="hljs-name">partial-tree</span> elts left-size)))
          (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ((<span class="hljs-name">left-tree</span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> left-result))
                (<span class="hljs-name">non-left-elts</span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> left-result))
                (<span class="hljs-name">right-size</span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> n (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> left-size <span class="hljs-number">1</span>))))
            (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ((<span class="hljs-name">this-entry</span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> non-left-elts))
                  (<span class="hljs-name">right-result</span> (<span class="hljs-name">partial-tree</span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> non-left-elts)
                                              right-size)))
              (<span class="hljs-name"><span class="hljs-builtin-name">let</span></span> ((<span class="hljs-name">right-tree</span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> right-result))
                    (<span class="hljs-name">remaining-elts</span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> right-result)))
                (<span class="hljs-name"><span class="hljs-builtin-name">cons</span></span> (<span class="hljs-name">make-tree</span> this-entry left-tree right-tree)
                      remaining-elts))))))))</code></pre>
<p><code>partial-tree</code> takes as arguments <code>elts</code> - list of elements, and integer <code>n</code> and returns pair whose <code>car</code> is balanced tree containing the first <code>n</code> elements of the list and <code>cdr</code> is the list of elements not included in the tree.</p>
<p>If we need to construct tree with 0 elements, we just return empty tree and list provided to us. Otherwise, we will have tree with one element in root, and subtrees. Size of subtrees will be (n-1) / 2 (remaining amount of elements appriximately equally split for each subtree). First we build left subtree and obtain remaining elements. First of the remaining elements goes into root of our tree, the rest - to building right subtree. After we have both subtrees attached to tree with root element, we return it, and what was left in list of elements from building right subtree.</p>
<p>So, when we have list <code>(1 3 5 7 9 11)</code>, we will have following tree:</p>
<pre><code>(5
    (1
        ()
        (3 () ())
    )
    (9
        (7 () ())
        (11 () ())
    )
)
</code></pre>
<p>b. What is the order of growth in the number of steps required by list->tree to convert a list of n elements?</p>
<p>partial-tree is called once for n = 0. For n > 0, it is called X(n), where X(n) = 2 + X( (n-1) / 2) + X(n - 1 - (n-1)/2 = (n-1)/2) => X(n) = 2 + X((n-1)/2). If X is identity function - equation is true, so X(n) = n. Order of growth is linear.</p>
<h2>Exercise 2.65</h2>
<p>Finally coding and not writing essays. I'm bad at essays (probably need another textbook on this topic, but how to test myself?)</p>
<p>I imagine we convert both trees to ordered lists, then use operations on ordered lists described in previous section, then convert back to trees. All of this operations take O(n).</p>
<pre><code class="hljs language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">union-set</span> s1 s2)
  (<span class="hljs-name">list->tree</span> (<span class="hljs-name">list-union-set</span> (<span class="hljs-name">tree->list2</span> s1) (<span class="hljs-name">tree->list2</span>)))
)</code></pre>
<p>Same for intersection, just call different function. I'm even not going to test this code, as it will be more effort than writing it.</p>
<h2>Exercise 2.66</h2>
<pre><code class="hljs language-scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">lookup</span> given-key set-of-records)
  (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-builtin-name">null?</span></span> set-of-records) false)
        ((<span class="hljs-name"><span class="hljs-builtin-name">=</span></span> given-key (<span class="hljs-name">key</span> (<span class="hljs-name">entry</span> set-of-records)))
         (<span class="hljs-name">entry</span> set-of-records))
        ((<span class="hljs-name"><span class="hljs-builtin-name">&#x3C;</span></span> given-key (<span class="hljs-name">key</span> (<span class="hljs-name">entry</span> set-of-records)))
         (<span class="hljs-name">lookup</span> (<span class="hljs-name">left-branch</span> set-of-records)))
        (<span class="hljs-name"><span class="hljs-builtin-name">else</span></span>
         (<span class="hljs-name">lookup</span> (<span class="hljs-name">right-branch</span> set-of-records)))))</code></pre></div></div></div><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-12 MuiGrid-grid-md-3"><h6 class="MuiTypography-root jss5 MuiTypography-h6 MuiTypography-gutterBottom">Archives</h6><ul><li><a href="/month/2018-12/page/1">2018-12</a> <span title="posts count">(<!-- -->1<!-- -->)</span></li><li><a href="/month/2020-06/page/1">2020-06</a> <span title="posts count">(<!-- -->7<!-- -->)</span></li><li><a href="/month/2020-07/page/1">2020-07</a> <span title="posts count">(<!-- -->10<!-- -->)</span></li><li><a href="/month/2020-08/page/1">2020-08</a> <span title="posts count">(<!-- -->2<!-- -->)</span></li><li><a href="/month/2020-09/page/1">2020-09</a> <span title="posts count">(<!-- -->2<!-- -->)</span></li><li><a href="/month/2020-12/page/1">2020-12</a> <span title="posts count">(<!-- -->1<!-- -->)</span></li><li><a href="/month/2021-01/page/1">2021-01</a> <span title="posts count">(<!-- -->4<!-- -->)</span></li></ul><h6 class="MuiTypography-root jss5 MuiTypography-h6 MuiTypography-gutterBottom">Topics</h6><ul><li><a href="/tag/MOOC/page/1">MOOC</a> <span title="posts count">(<!-- -->2<!-- -->)</span></li><li><a href="/tag/SICP/page/1">SICP</a> <span title="posts count">(<!-- -->20<!-- -->)</span></li><li><a href="/tag/ideas/page/1">ideas</a> <span title="posts count">(<!-- -->1<!-- -->)</span></li><li><a href="/tag/notes/page/1">notes</a> <span title="posts count">(<!-- -->5<!-- -->)</span></li><li><a href="/tag/on%20writing/page/1">on writing</a> <span title="posts count">(<!-- -->3<!-- -->)</span></li></ul></div><p class="MuiTypography-root MuiTypography-body2 MuiTypography-colorTextSecondary MuiTypography-alignCenter">© <!-- -->2021<!-- --> Bunyk Taras. Built with Material UI &amp; Next.js</p></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"id":"sicp2.3.3","title":"SICP 2.3.3 Representing sets","date":"2020-07-28","tags":["SICP"],"excerpt":"\u003cp\u003eThis was more boring in comparison to previous section, probably because it required writing less code, and just writing more explanations. Writing is thinking, so I tried to do that. Or maybe it was boring because sets are not as exciting as symbolic differentiation. At least when you have high level language.\u003c/p\u003e","content":"\u003cp\u003eThis was more boring in comparison to previous section, probably because it required writing less code, and just writing more explanations. Writing is thinking, so I tried to do that. Or maybe it was boring because sets are not as exciting as symbolic differentiation. At least when you have high level language.\u003c/p\u003e\n\u003ch2\u003eExercise 2.59\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-scheme\"\u003e(\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003edefine\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eelement-of-set?\u003c/span\u003e x set)\n  (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003econd\u003c/span\u003e\u003c/span\u003e ((\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003enull?\u003c/span\u003e\u003c/span\u003e set) false)\n        ((\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003eequal?\u003c/span\u003e\u003c/span\u003e x (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003ecar\u003c/span\u003e\u003c/span\u003e set)) true)\n        (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003eelse\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eelement-of-set?\u003c/span\u003e x (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003ecdr\u003c/span\u003e\u003c/span\u003e set)))))\n\n(\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003edefine\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eadjoin-set\u003c/span\u003e x set)\n  (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003eif\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eelement-of-set?\u003c/span\u003e x set)\n      set\n      (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003econs\u003c/span\u003e\u003c/span\u003e x set)))\n\n(\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003edefine\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eunion-set\u003c/span\u003e set1 set2)\n  (\u003cspan class=\"hljs-name\"\u003efold-left\u003c/span\u003e\n    (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003elambda\u003c/span\u003e\u003c/span\u003e (union next) (\u003cspan class=\"hljs-name\"\u003eadjoin-set\u003c/span\u003e next union))\n    set1\n    set2\n  )\n)\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eExercise 2.60\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-scheme\"\u003e(\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003edefine\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eelement-of-set?\u003c/span\u003e x set)\n  (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003econd\u003c/span\u003e\u003c/span\u003e ((\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003enull?\u003c/span\u003e\u003c/span\u003e set) false)\n        ((\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003eequal?\u003c/span\u003e\u003c/span\u003e x (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003ecar\u003c/span\u003e\u003c/span\u003e set)) true)\n        (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003eelse\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eelement-of-set?\u003c/span\u003e x (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003ecdr\u003c/span\u003e\u003c/span\u003e set)))))\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eO(n), as unique one, but here list could be way longer, so less performant.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-scheme\"\u003e(\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003edefine\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eadjoin-set\u003c/span\u003e x set)\n  (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003econs\u003c/span\u003e\u003c/span\u003e x set)\n)\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eO(1), lot better than unique one ( O(n)), because we not checking uniqueness.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-scheme\"\u003e(\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003edefine\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eunion-set\u003c/span\u003e set1 set2)\n  (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003eappend\u003c/span\u003e\u003c/span\u003e set1 set2)\n)\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAppend has complexity O(n) = O(len(set1)) if I'm not mistaken. O(n), better than O(n2).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-scheme\"\u003e(\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003edefine\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eintersection-set\u003c/span\u003e set1 set2)\n  (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003econd\u003c/span\u003e\u003c/span\u003e ((\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003eor\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003enull?\u003c/span\u003e\u003c/span\u003e set1) (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003enull?\u003c/span\u003e\u003c/span\u003e set2)) '())\n        ((\u003cspan class=\"hljs-name\"\u003eelement-of-set?\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003ecar\u003c/span\u003e\u003c/span\u003e set1) set2)        \n         (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003econs\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003ecar\u003c/span\u003e\u003c/span\u003e set1)\n               (\u003cspan class=\"hljs-name\"\u003eintersection-set\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003ecdr\u003c/span\u003e\u003c/span\u003e set1) set2)))\n        (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003eelse\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eintersection-set\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003ecdr\u003c/span\u003e\u003c/span\u003e set1) set2))))\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIntersection has same implementation and as a result same asymptotic complexity O(n2), but we expect n to be a lot larger.\u003c/p\u003e\n\u003cp\u003eSo, this approach would suit applications where we will do a lot of adjoins and unions, and not much checking for element or intersections.\u003c/p\u003e\n\u003ch2\u003eExercise 2.61\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-scheme\"\u003e(\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003edefine\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eadjoin-set\u003c/span\u003e x set)\n  (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003econd\u003c/span\u003e\u003c/span\u003e ((\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003eor\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003enull?\u003c/span\u003e\u003c/span\u003e set) (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003e\u0026#x3C;\u003c/span\u003e\u003c/span\u003e x (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003ecar\u003c/span\u003e\u003c/span\u003e set))) (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003econs\u003c/span\u003e\u003c/span\u003e x set))\n        ((\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003e=\u003c/span\u003e\u003c/span\u003e x (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003ecar\u003c/span\u003e\u003c/span\u003e set)) set)\n        (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003eelse\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003econs\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003ecar\u003c/span\u003e\u003c/span\u003e set) (\u003cspan class=\"hljs-name\"\u003eadjoin-set\u003c/span\u003e x (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003ecdr\u003c/span\u003e\u003c/span\u003e set))))))\n\n(\u003cspan class=\"hljs-name\"\u003eadjoin-set\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003elist\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e))\n(\u003cspan class=\"hljs-name\"\u003eadjoin-set\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003elist\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e))\n(\u003cspan class=\"hljs-name\"\u003eadjoin-set\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003elist\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e))\n(\u003cspan class=\"hljs-name\"\u003eadjoin-set\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003elist\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e))\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eExercise 2.62\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-scheme\"\u003e(\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003edefine\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eunion-set\u003c/span\u003e set1 set2)\n    (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003econd\u003c/span\u003e\u003c/span\u003e\n        ((\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003enull?\u003c/span\u003e\u003c/span\u003e set1) set2)\n        ((\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003enull?\u003c/span\u003e\u003c/span\u003e set2) set1)\n        ((\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003e\u0026#x3C;\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003ecar\u003c/span\u003e\u003c/span\u003e set1) (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003ecar\u003c/span\u003e\u003c/span\u003e set2)) (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003econs\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003ecar\u003c/span\u003e\u003c/span\u003e set1) (\u003cspan class=\"hljs-name\"\u003eunion-set\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003ecdr\u003c/span\u003e\u003c/span\u003e set1) set2)))\n        (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003eelse\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003econs\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003ecar\u003c/span\u003e\u003c/span\u003e set2) (\u003cspan class=\"hljs-name\"\u003eunion-set\u003c/span\u003e set1 (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003ecdr\u003c/span\u003e\u003c/span\u003e set2))))\n    )\n)\n(\u003cspan class=\"hljs-name\"\u003eunion-set\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003elist\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e) (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003elist\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e))\n(\u003cspan class=\"hljs-name\"\u003eunion-set\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003elist\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e) (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003elist\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e))\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eExercise 2.63\u003c/h2\u003e\n\u003cp\u003ea. Yes, they give same results by traversing tree from left to right.\u003c/p\u003e\n\u003cp\u003eb. One without \u003ccode\u003eappend\u003c/code\u003e is better. For the second one \u003ccode\u003ecopy-to-list\u003c/code\u003e is called for right subtree first, and then process conses current tree entry to result, then \u003ccode\u003ecopy-to-list\u003c/code\u003e is called recursively to cons left subtree to the resulting list.\u003c/p\u003e\n\u003cp\u003eIn case with append, we compute \u003ccode\u003etree-\u003elist1\u003c/code\u003e for both subtrees simultaniously, then iterate over result for left subtree inside \u003ccode\u003eappend\u003c/code\u003e.  Append takes O(n) time, where n is length of left argument. It is processing half of nodes in each level in the tree, which is approximately O(n log(n)).\u003c/p\u003e\n\u003ch2\u003eExercise 2.64\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-scheme\"\u003e(\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003edefine\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003elist-\u003etree\u003c/span\u003e elements)\n  (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003ecar\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003epartial-tree\u003c/span\u003e elements (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003elength\u003c/span\u003e\u003c/span\u003e elements))))\n\n(\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003edefine\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003epartial-tree\u003c/span\u003e elts n)\n  (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003eif\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003e=\u003c/span\u003e\u003c/span\u003e n \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n      (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003econs\u003c/span\u003e\u003c/span\u003e '() elts)\n      (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003elet\u003c/span\u003e\u003c/span\u003e ((\u003cspan class=\"hljs-name\"\u003eleft-size\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003equotient\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003e-\u003c/span\u003e\u003c/span\u003e n \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)))\n        (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003elet\u003c/span\u003e\u003c/span\u003e ((\u003cspan class=\"hljs-name\"\u003eleft-result\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003epartial-tree\u003c/span\u003e elts left-size)))\n          (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003elet\u003c/span\u003e\u003c/span\u003e ((\u003cspan class=\"hljs-name\"\u003eleft-tree\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003ecar\u003c/span\u003e\u003c/span\u003e left-result))\n                (\u003cspan class=\"hljs-name\"\u003enon-left-elts\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003ecdr\u003c/span\u003e\u003c/span\u003e left-result))\n                (\u003cspan class=\"hljs-name\"\u003eright-size\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003e-\u003c/span\u003e\u003c/span\u003e n (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003e+\u003c/span\u003e\u003c/span\u003e left-size \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e))))\n            (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003elet\u003c/span\u003e\u003c/span\u003e ((\u003cspan class=\"hljs-name\"\u003ethis-entry\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003ecar\u003c/span\u003e\u003c/span\u003e non-left-elts))\n                  (\u003cspan class=\"hljs-name\"\u003eright-result\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003epartial-tree\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003ecdr\u003c/span\u003e\u003c/span\u003e non-left-elts)\n                                              right-size)))\n              (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003elet\u003c/span\u003e\u003c/span\u003e ((\u003cspan class=\"hljs-name\"\u003eright-tree\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003ecar\u003c/span\u003e\u003c/span\u003e right-result))\n                    (\u003cspan class=\"hljs-name\"\u003eremaining-elts\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003ecdr\u003c/span\u003e\u003c/span\u003e right-result)))\n                (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003econs\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003emake-tree\u003c/span\u003e this-entry left-tree right-tree)\n                      remaining-elts))))))))\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003epartial-tree\u003c/code\u003e takes as arguments \u003ccode\u003eelts\u003c/code\u003e - list of elements, and integer \u003ccode\u003en\u003c/code\u003e and returns pair whose \u003ccode\u003ecar\u003c/code\u003e is balanced tree containing the first \u003ccode\u003en\u003c/code\u003e elements of the list and \u003ccode\u003ecdr\u003c/code\u003e is the list of elements not included in the tree.\u003c/p\u003e\n\u003cp\u003eIf we need to construct tree with 0 elements, we just return empty tree and list provided to us. Otherwise, we will have tree with one element in root, and subtrees. Size of subtrees will be (n-1) / 2 (remaining amount of elements appriximately equally split for each subtree). First we build left subtree and obtain remaining elements. First of the remaining elements goes into root of our tree, the rest - to building right subtree. After we have both subtrees attached to tree with root element, we return it, and what was left in list of elements from building right subtree.\u003c/p\u003e\n\u003cp\u003eSo, when we have list \u003ccode\u003e(1 3 5 7 9 11)\u003c/code\u003e, we will have following tree:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e(5\n    (1\n        ()\n        (3 () ())\n    )\n    (9\n        (7 () ())\n        (11 () ())\n    )\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eb. What is the order of growth in the number of steps required by list-\u003etree to convert a list of n elements?\u003c/p\u003e\n\u003cp\u003epartial-tree is called once for n = 0. For n \u003e 0, it is called X(n), where X(n) = 2 + X( (n-1) / 2) + X(n - 1 - (n-1)/2 = (n-1)/2) =\u003e X(n) = 2 + X((n-1)/2). If X is identity function - equation is true, so X(n) = n. Order of growth is linear.\u003c/p\u003e\n\u003ch2\u003eExercise 2.65\u003c/h2\u003e\n\u003cp\u003eFinally coding and not writing essays. I'm bad at essays (probably need another textbook on this topic, but how to test myself?)\u003c/p\u003e\n\u003cp\u003eI imagine we convert both trees to ordered lists, then use operations on ordered lists described in previous section, then convert back to trees. All of this operations take O(n).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-scheme\"\u003e(\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003edefine\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eunion-set\u003c/span\u003e s1 s2)\n  (\u003cspan class=\"hljs-name\"\u003elist-\u003etree\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003elist-union-set\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003etree-\u003elist2\u003c/span\u003e s1) (\u003cspan class=\"hljs-name\"\u003etree-\u003elist2\u003c/span\u003e)))\n)\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSame for intersection, just call different function. I'm even not going to test this code, as it will be more effort than writing it.\u003c/p\u003e\n\u003ch2\u003eExercise 2.66\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-scheme\"\u003e(\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003edefine\u003c/span\u003e\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003elookup\u003c/span\u003e given-key set-of-records)\n  (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003econd\u003c/span\u003e\u003c/span\u003e ((\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003enull?\u003c/span\u003e\u003c/span\u003e set-of-records) false)\n        ((\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003e=\u003c/span\u003e\u003c/span\u003e given-key (\u003cspan class=\"hljs-name\"\u003ekey\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eentry\u003c/span\u003e set-of-records)))\n         (\u003cspan class=\"hljs-name\"\u003eentry\u003c/span\u003e set-of-records))\n        ((\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003e\u0026#x3C;\u003c/span\u003e\u003c/span\u003e given-key (\u003cspan class=\"hljs-name\"\u003ekey\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eentry\u003c/span\u003e set-of-records)))\n         (\u003cspan class=\"hljs-name\"\u003elookup\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eleft-branch\u003c/span\u003e set-of-records)))\n        (\u003cspan class=\"hljs-name\"\u003e\u003cspan class=\"hljs-builtin-name\"\u003eelse\u003c/span\u003e\u003c/span\u003e\n         (\u003cspan class=\"hljs-name\"\u003elookup\u003c/span\u003e (\u003cspan class=\"hljs-name\"\u003eright-branch\u003c/span\u003e set-of-records)))))\u003c/code\u003e\u003c/pre\u003e"},"archives":[{"url":"/month/2018-12/page/1","id":"2018-12","count":1,"title":"2018-12"},{"url":"/month/2020-06/page/1","id":"2020-06","count":7,"title":"2020-06"},{"url":"/month/2020-07/page/1","id":"2020-07","count":10,"title":"2020-07"},{"url":"/month/2020-08/page/1","id":"2020-08","count":2,"title":"2020-08"},{"url":"/month/2020-09/page/1","id":"2020-09","count":2,"title":"2020-09"},{"url":"/month/2020-12/page/1","id":"2020-12","count":1,"title":"2020-12"},{"url":"/month/2021-01/page/1","id":"2021-01","count":4,"title":"2021-01"}],"topics":[{"url":"/tag/MOOC/page/1","id":"MOOC","title":"MOOC","count":2},{"url":"/tag/SICP/page/1","id":"SICP","title":"SICP","count":20},{"url":"/tag/ideas/page/1","id":"ideas","title":"ideas","count":1},{"url":"/tag/notes/page/1","id":"notes","title":"notes","count":5},{"url":"/tag/on writing/page/1","id":"on writing","title":"on writing","count":3}]},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"sicp2.3.3"},"buildId":"Zn0comZmfh30_fMqSLkCB","isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-8683bd742a84c1edd48c.js"></script><script src="/_next/static/chunks/webpack-ab63730ce14ffb2d4de2.js" async=""></script><script src="/_next/static/chunks/framework-77b689d02b4bf42ce2e0.js" async=""></script><script src="/_next/static/chunks/commons-131aad2d92e69c360009.js" async=""></script><script src="/_next/static/chunks/main-4f9408d32df08544de44.js" async=""></script><script src="/_next/static/chunks/pages/_app-d383b5fdcc7af26c9ab8.js" async=""></script><script src="/_next/static/chunks/762-bec077d9715dbffe23e5.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-4d391b18df3a2ccf9664.js" async=""></script><script src="/_next/static/Zn0comZmfh30_fMqSLkCB/_buildManifest.js" async=""></script><script src="/_next/static/Zn0comZmfh30_fMqSLkCB/_ssgManifest.js" async=""></script></body></html>