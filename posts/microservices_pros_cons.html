<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>To split or not to split? What are microservices and should you use them.</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/f969c0c492dd18a0081f.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f969c0c492dd18a0081f.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-fb76148cfcfb42ca18eb.js" defer=""></script><script src="/_next/static/chunks/framework-2191d16384373197bc0a.js" defer=""></script><script src="/_next/static/chunks/main-89e612c37cd79392e22d.js" defer=""></script><script src="/_next/static/chunks/pages/_app-459ac92bde4bcd5c6050.js" defer=""></script><script src="/_next/static/chunks/762-0f685813c4b6ace6d024.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-338567653ad135dab1d7.js" defer=""></script><script src="/_next/static/vTIm-6E4fBbgVLRlj9tfU/_buildManifest.js" defer=""></script><script src="/_next/static/vTIm-6E4fBbgVLRlj9tfU/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="MuiContainer-root MuiContainer-maxWidthMd"><div class="MuiToolbar-root MuiToolbar-regular jss1 MuiToolbar-gutters"><h1 class="MuiTypography-root jss2 MuiTypography-h5 MuiTypography-noWrap" aligh="center">Taras Bunyk</h1></div><nav class="MuiToolbar-root MuiToolbar-dense jss3 MuiToolbar-gutters"><a href="/">Home</a><a href="http://bunyk.github.io/mandala/">Snowflake drawing</a><a href="/resume">Resume</a><a href="https://bunyk.wordpress.com/">Old blog (in Ukrainian)</a></nav><div class="MuiGrid-root MuiGrid-container MuiGrid-spacing-xs-5"><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-12 MuiGrid-grid-md-9"><div class="MuiPaper-root MuiCard-root MuiPaper-elevation1 MuiPaper-rounded"><div class="MuiCardHeader-root"><div class="MuiCardHeader-content"><span class="MuiTypography-root MuiCardHeader-title MuiTypography-h5 MuiTypography-displayBlock">To split or not to split? What are microservices and should you use them.</span><span class="MuiTypography-root MuiCardHeader-subheader MuiTypography-body1 MuiTypography-colorTextSecondary MuiTypography-displayBlock">Published: 2021-01-08 Tags: notes</span></div></div><div class="MuiCardContent-root"><p>Notes from reading early 2nd edition release of book <strong>Building Microservices</strong> by <em>Sam Newman</em>.</p>
<h2>Microservices</h2>
<p><strong>Microservices</strong> are independently releasable services modelled around business domain. <strong>Services</strong> are programs that encapsulate some functionality and make it available to other services over network.</p>
<p>There is related concept of Service Oriented Architecture (SOA). Microservices is one of the approaches to SOA in the same way as Scrum is one of the Agile approaches to development. In SOA you have multiple services that collaborate with each other, but they are not necessary independently deployable. For microservices independent deployment is a must.</p>
<p>Independent deployment means that you could deploy your microservices without having to deploy any other service. This could be achieved by designing service boundaries properly.</p>
<p>To have proper boundaries, you should model your services around business domain, so the changes that involve different services become less likely.</p>
<p>Popular 3-layer architecture of front-end (UI), back-end (business logic) and storage (Database), is contrast to this, because most of the time adding some new feature involves changing each layer. For example to display new field, it needs to be added to UI, to back-end for processing, and to database schema. But this architecture is so popular because of Conway's law: "Any organization that designs a system will produce a design whose structure is a copy of the organization's communication structure", and the fact that organisations often had developers grouped into departments by their qualification - database administration, UI design, etc... Instead it's better to build around business departments - warehouse, sales, accounting, etc...</p>
<p>From the outside of the service boundary microservice should look like a black box. It should hide as much information as possible and share as little as possible. Information could be shared by API endpoints or messages in message queues. Each microservice should own their own state. Sharing single database between different microservices is a big no no. This is intended to make changing internal implementation very easy, and is similar to concept of encapsulation in OOP.</p>
<p>What size should microservices be? Well, small, so they could be easily understood, but there is no exact measure. Size should depend on purpose and architecture and is not very important concern.</p>
<p>Microservices require some supporting tech:</p>
<ul>
<li>Log aggregation</li>
<li>Distributed tracing</li>
<li>Containers and orchestration</li>
<li>Streaming (event queues)</li>
<li>Cloud infrastructure</li>
</ul>
<h2>Monoliths</h2>
<p><strong>Monolith</strong> is opposite concept - anything that is not independently deployed. Monolith could be implemented in many ways: it could be developed as single application, it could be built from multiple independently developed modules or it could be <strong>distributed monolith</strong>: bunch of services that does not share code, and could be located on different hosts but still have to be de deployed together.</p>
<p>Contrary to popular opinion that monolith is a bad thing and often associated with legacy, it is not legacy. Actually, it should be default choice, and you should have reasons to not use monolith.</p>
<p>Monoliths have lots of serious advantages, like simplicity, avoiding problems of distributed systems, better code reuse inside monolith (if you need function, you just call it, no need for copy-paste or creating external library).</p>
<h2>How to choose?</h2>
<h3>Advantages of microservices</h3>
<p>You should use microservices if you want to allow developers independently work on their parts of the software, so they don't get in each ones way. One developer could want to do a deployment to fix a bug, but other could want to wait with deployment, because there is unfixed bug in master branch that needs to be fixed first. If you have company with hundreds of employees, you should definitely consider them.</p>
<ul>
<li>They allow <strong>heterogenity</strong>. You will not be constrained by one language or framework.</li>
<li><strong>Robustness</strong>. Failure of one microservices should cause less harm than failure of whole monolith and not bring system down.</li>
<li><strong>Precise scallability</strong>. You scale only what needs to be scaled. If you see that you need more performance, you could start more instances of the service that is bottleneck, and not deploy whole app couple of times.</li>
<li><strong>Faster deployment</strong>. Deploying one-line change in million-code app will take more time and resources than in small microservice.</li>
</ul>
<h3>Pain points</h3>
<p>You should better not use microservices for new products and in startups where domain is not yet precisely defined and could quickly change. If your team consists only from 5 people, you definitely don't need them.</p>
<ul>
<li><strong>More overhead work</strong> to develop and support microservices.</li>
<li>Problems with <strong>data consistency</strong></li>
<li><strong>Techology overload</strong></li>
<li><strong>Hard to develop</strong>. You will no longer be able to run whole system on your local machine.</li>
<li><strong>Hard to do reporting</strong> and queries across data in different services.</li>
<li><strong>Hard to troubleshoot and monitor</strong>. To find failure in a system you will need to look into multiple services.</li>
<li><strong>Hard to test</strong>. It is hard to create fixtures and environment to run system test. Often false positives would be caused by configuration of test environment.</li>
<li><strong>Increased latency</strong>. What before would have been call to a function or reading a RAM, now would be a network request, which significantly slows things down.</li>
</ul></div></div></div><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-12 MuiGrid-grid-md-3"><h6 class="MuiTypography-root jss5 MuiTypography-h6 MuiTypography-gutterBottom">Archives</h6><ul><li><a href="/month/2021-10/page/1">2021-10</a> <span title="posts count">(<!-- -->1<!-- -->)</span></li><li><a href="/month/2021-01/page/1">2021-01</a> <span title="posts count">(<!-- -->4<!-- -->)</span></li><li><a href="/month/2020-12/page/1">2020-12</a> <span title="posts count">(<!-- -->1<!-- -->)</span></li><li><a href="/month/2020-09/page/1">2020-09</a> <span title="posts count">(<!-- -->2<!-- -->)</span></li><li><a href="/month/2020-08/page/1">2020-08</a> <span title="posts count">(<!-- -->2<!-- -->)</span></li><li><a href="/month/2020-07/page/1">2020-07</a> <span title="posts count">(<!-- -->10<!-- -->)</span></li><li><a href="/month/2020-06/page/1">2020-06</a> <span title="posts count">(<!-- -->7<!-- -->)</span></li><li><a href="/month/2018-12/page/1">2018-12</a> <span title="posts count">(<!-- -->1<!-- -->)</span></li></ul><h6 class="MuiTypography-root jss5 MuiTypography-h6 MuiTypography-gutterBottom">Topics</h6><ul><li><a href="/tag/MOOC/page/1">MOOC</a> <span title="posts count">(<!-- -->2<!-- -->)</span></li><li><a href="/tag/SICP/page/1">SICP</a> <span title="posts count">(<!-- -->20<!-- -->)</span></li><li><a href="/tag/asm/page/1">asm</a> <span title="posts count">(<!-- -->1<!-- -->)</span></li><li><a href="/tag/ideas/page/1">ideas</a> <span title="posts count">(<!-- -->1<!-- -->)</span></li><li><a href="/tag/notes/page/1">notes</a> <span title="posts count">(<!-- -->6<!-- -->)</span></li><li><a href="/tag/on%20writing/page/1">on writing</a> <span title="posts count">(<!-- -->3<!-- -->)</span></li></ul></div><p class="MuiTypography-root MuiTypography-body2 MuiTypography-colorTextSecondary MuiTypography-alignCenter">© <!-- -->2021<!-- --> Bunyk Taras. Built with Material UI &amp; Next.js</p></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"id":"microservices_pros_cons","title":"To split or not to split? What are microservices and should you use them.","date":"2021-01-08","tags":["notes"],"excerpt":"\u003cp\u003eNotes from reading early 2nd edition release of book \u003cstrong\u003eBuilding Microservices\u003c/strong\u003e by \u003cem\u003eSam Newman\u003c/em\u003e.\u003c/p\u003e","content":"\u003cp\u003eNotes from reading early 2nd edition release of book \u003cstrong\u003eBuilding Microservices\u003c/strong\u003e by \u003cem\u003eSam Newman\u003c/em\u003e.\u003c/p\u003e\n\u003ch2\u003eMicroservices\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eMicroservices\u003c/strong\u003e are independently releasable services modelled around business domain. \u003cstrong\u003eServices\u003c/strong\u003e are programs that encapsulate some functionality and make it available to other services over network.\u003c/p\u003e\n\u003cp\u003eThere is related concept of Service Oriented Architecture (SOA). Microservices is one of the approaches to SOA in the same way as Scrum is one of the Agile approaches to development. In SOA you have multiple services that collaborate with each other, but they are not necessary independently deployable. For microservices independent deployment is a must.\u003c/p\u003e\n\u003cp\u003eIndependent deployment means that you could deploy your microservices without having to deploy any other service. This could be achieved by designing service boundaries properly.\u003c/p\u003e\n\u003cp\u003eTo have proper boundaries, you should model your services around business domain, so the changes that involve different services become less likely.\u003c/p\u003e\n\u003cp\u003ePopular 3-layer architecture of front-end (UI), back-end (business logic) and storage (Database), is contrast to this, because most of the time adding some new feature involves changing each layer. For example to display new field, it needs to be added to UI, to back-end for processing, and to database schema. But this architecture is so popular because of Conway's law: \"Any organization that designs a system will produce a design whose structure is a copy of the organization's communication structure\", and the fact that organisations often had developers grouped into departments by their qualification - database administration, UI design, etc... Instead it's better to build around business departments - warehouse, sales, accounting, etc...\u003c/p\u003e\n\u003cp\u003eFrom the outside of the service boundary microservice should look like a black box. It should hide as much information as possible and share as little as possible. Information could be shared by API endpoints or messages in message queues. Each microservice should own their own state. Sharing single database between different microservices is a big no no. This is intended to make changing internal implementation very easy, and is similar to concept of encapsulation in OOP.\u003c/p\u003e\n\u003cp\u003eWhat size should microservices be? Well, small, so they could be easily understood, but there is no exact measure. Size should depend on purpose and architecture and is not very important concern.\u003c/p\u003e\n\u003cp\u003eMicroservices require some supporting tech:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLog aggregation\u003c/li\u003e\n\u003cli\u003eDistributed tracing\u003c/li\u003e\n\u003cli\u003eContainers and orchestration\u003c/li\u003e\n\u003cli\u003eStreaming (event queues)\u003c/li\u003e\n\u003cli\u003eCloud infrastructure\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eMonoliths\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eMonolith\u003c/strong\u003e is opposite concept - anything that is not independently deployed. Monolith could be implemented in many ways: it could be developed as single application, it could be built from multiple independently developed modules or it could be \u003cstrong\u003edistributed monolith\u003c/strong\u003e: bunch of services that does not share code, and could be located on different hosts but still have to be de deployed together.\u003c/p\u003e\n\u003cp\u003eContrary to popular opinion that monolith is a bad thing and often associated with legacy, it is not legacy. Actually, it should be default choice, and you should have reasons to not use monolith.\u003c/p\u003e\n\u003cp\u003eMonoliths have lots of serious advantages, like simplicity, avoiding problems of distributed systems, better code reuse inside monolith (if you need function, you just call it, no need for copy-paste or creating external library).\u003c/p\u003e\n\u003ch2\u003eHow to choose?\u003c/h2\u003e\n\u003ch3\u003eAdvantages of microservices\u003c/h3\u003e\n\u003cp\u003eYou should use microservices if you want to allow developers independently work on their parts of the software, so they don't get in each ones way. One developer could want to do a deployment to fix a bug, but other could want to wait with deployment, because there is unfixed bug in master branch that needs to be fixed first. If you have company with hundreds of employees, you should definitely consider them.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThey allow \u003cstrong\u003eheterogenity\u003c/strong\u003e. You will not be constrained by one language or framework.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRobustness\u003c/strong\u003e. Failure of one microservices should cause less harm than failure of whole monolith and not bring system down.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePrecise scallability\u003c/strong\u003e. You scale only what needs to be scaled. If you see that you need more performance, you could start more instances of the service that is bottleneck, and not deploy whole app couple of times.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eFaster deployment\u003c/strong\u003e. Deploying one-line change in million-code app will take more time and resources than in small microservice.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003ePain points\u003c/h3\u003e\n\u003cp\u003eYou should better not use microservices for new products and in startups where domain is not yet precisely defined and could quickly change. If your team consists only from 5 people, you definitely don't need them.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eMore overhead work\u003c/strong\u003e to develop and support microservices.\u003c/li\u003e\n\u003cli\u003eProblems with \u003cstrong\u003edata consistency\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTechology overload\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eHard to develop\u003c/strong\u003e. You will no longer be able to run whole system on your local machine.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eHard to do reporting\u003c/strong\u003e and queries across data in different services.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eHard to troubleshoot and monitor\u003c/strong\u003e. To find failure in a system you will need to look into multiple services.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eHard to test\u003c/strong\u003e. It is hard to create fixtures and environment to run system test. Often false positives would be caused by configuration of test environment.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eIncreased latency\u003c/strong\u003e. What before would have been call to a function or reading a RAM, now would be a network request, which significantly slows things down.\u003c/li\u003e\n\u003c/ul\u003e"},"archives":[{"url":"/month/2021-10/page/1","id":"2021-10","count":1,"title":"2021-10"},{"url":"/month/2021-01/page/1","id":"2021-01","count":4,"title":"2021-01"},{"url":"/month/2020-12/page/1","id":"2020-12","count":1,"title":"2020-12"},{"url":"/month/2020-09/page/1","id":"2020-09","count":2,"title":"2020-09"},{"url":"/month/2020-08/page/1","id":"2020-08","count":2,"title":"2020-08"},{"url":"/month/2020-07/page/1","id":"2020-07","count":10,"title":"2020-07"},{"url":"/month/2020-06/page/1","id":"2020-06","count":7,"title":"2020-06"},{"url":"/month/2018-12/page/1","id":"2018-12","count":1,"title":"2018-12"}],"topics":[{"url":"/tag/MOOC/page/1","id":"MOOC","title":"MOOC","count":2},{"url":"/tag/SICP/page/1","id":"SICP","title":"SICP","count":20},{"url":"/tag/asm/page/1","id":"asm","title":"asm","count":1},{"url":"/tag/ideas/page/1","id":"ideas","title":"ideas","count":1},{"url":"/tag/notes/page/1","id":"notes","title":"notes","count":6},{"url":"/tag/on writing/page/1","id":"on writing","title":"on writing","count":3}]},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"microservices_pros_cons"},"buildId":"vTIm-6E4fBbgVLRlj9tfU","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>