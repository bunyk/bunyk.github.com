<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Taras Bunyk</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/f969c0c492dd18a0081f.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f969c0c492dd18a0081f.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-fb76148cfcfb42ca18eb.js" defer=""></script><script src="/_next/static/chunks/framework-2191d16384373197bc0a.js" defer=""></script><script src="/_next/static/chunks/main-89e612c37cd79392e22d.js" defer=""></script><script src="/_next/static/chunks/pages/_app-459ac92bde4bcd5c6050.js" defer=""></script><script src="/_next/static/chunks/762-0f685813c4b6ace6d024.js" defer=""></script><script src="/_next/static/chunks/493-1b1d0a0a11d8c4d6a4cd.js" defer=""></script><script src="/_next/static/chunks/pages/tag/%5Btag%5D/page/%5Bpage%5D-a53b3777b3d6f2750a6c.js" defer=""></script><script src="/_next/static/vTIm-6E4fBbgVLRlj9tfU/_buildManifest.js" defer=""></script><script src="/_next/static/vTIm-6E4fBbgVLRlj9tfU/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="MuiContainer-root MuiContainer-maxWidthMd"><div class="MuiToolbar-root MuiToolbar-regular jss1 MuiToolbar-gutters"><h1 class="MuiTypography-root jss2 MuiTypography-h5 MuiTypography-noWrap" aligh="center">Taras Bunyk</h1></div><nav class="MuiToolbar-root MuiToolbar-dense jss3 MuiToolbar-gutters"><a href="/">Home</a><a href="http://bunyk.github.io/mandala/">Snowflake drawing</a><a href="/resume">Resume</a><a href="https://bunyk.wordpress.com/">Old blog (in Ukrainian)</a></nav><div class="MuiGrid-root MuiGrid-container MuiGrid-spacing-xs-5"><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-12 MuiGrid-grid-md-9"><div class="MuiPaper-root MuiCard-root jss6 MuiPaper-elevation1 MuiPaper-rounded"><div class="MuiCardHeader-root"><div class="MuiCardHeader-content"><span class="MuiTypography-root MuiCardHeader-title MuiTypography-h5 MuiTypography-displayBlock">Bare metal &quot;Hello, world!&quot;</span><span class="MuiTypography-root MuiCardHeader-subheader MuiTypography-body1 MuiTypography-colorTextSecondary MuiTypography-displayBlock">Published: 2021-10-23 Tags: notes, asm</span></div></div><div class="MuiCardContent-root"><p>From time to time I get an itch to write. I mean code. Everything: video games, search engines, operating systems. Many of my old friends <a href="https://danbst.wordpress.com/2009/12/26/helloworld_os_boot_sector/">wrote their own OSes</a> (or at least bare-metal code), and I have FOMO.</p>
<p>Recently I bought eBook reader with bigger screen than my Kindle. So I went on treasure hunt over internet to fill it with all the awesome free books that I wanted to read, but was not reading, because they did not fit to that tiny Kindle screen. And I found some unfinished free book: <a href="https://www.cs.bham.ac.uk/~exr/lectures/opsys/10_11/lectures/os-dev.pdf">"Writing a Simple Operating System - from Scratch" by Nick Blundel (2010)</a>. It retriggered that itch to write OS, or at least code that runs without OS again.</p>
<p>Here I'll post notes of my journey, skipping boring parts like explaining benefits of hexadecimal notation.</p></div><div class="MuiCardActions-root MuiCardActions-spacing"><a class="MuiButtonBase-root MuiButton-root MuiButton-text" tabindex="0" aria-disabled="false" href="/posts/bare_metal_hello_world"><span class="MuiButton-label">More</span></a></div></div><button class="MuiButtonBase-root MuiButton-root MuiButton-text Mui-disabled Mui-disabled" tabindex="-1" type="button" disabled=""><span class="MuiButton-label">1</span></button></div><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-12 MuiGrid-grid-md-3"><h6 class="MuiTypography-root jss5 MuiTypography-h6 MuiTypography-gutterBottom">Archives</h6><ul><li><a href="/month/2021-10/page/1">2021-10</a> <span title="posts count">(<!-- -->1<!-- -->)</span></li><li><a href="/month/2021-01/page/1">2021-01</a> <span title="posts count">(<!-- -->4<!-- -->)</span></li><li><a href="/month/2020-12/page/1">2020-12</a> <span title="posts count">(<!-- -->1<!-- -->)</span></li><li><a href="/month/2020-09/page/1">2020-09</a> <span title="posts count">(<!-- -->2<!-- -->)</span></li><li><a href="/month/2020-08/page/1">2020-08</a> <span title="posts count">(<!-- -->2<!-- -->)</span></li><li><a href="/month/2020-07/page/1">2020-07</a> <span title="posts count">(<!-- -->10<!-- -->)</span></li><li><a href="/month/2020-06/page/1">2020-06</a> <span title="posts count">(<!-- -->7<!-- -->)</span></li><li><a href="/month/2018-12/page/1">2018-12</a> <span title="posts count">(<!-- -->1<!-- -->)</span></li></ul><h6 class="MuiTypography-root jss5 MuiTypography-h6 MuiTypography-gutterBottom">Topics</h6><ul><li><a href="/tag/MOOC/page/1">MOOC</a> <span title="posts count">(<!-- -->2<!-- -->)</span></li><li><a href="/tag/SICP/page/1">SICP</a> <span title="posts count">(<!-- -->20<!-- -->)</span></li><li><a href="/tag/asm/page/1">asm</a> <span title="posts count">(<!-- -->1<!-- -->)</span></li><li><a href="/tag/ideas/page/1">ideas</a> <span title="posts count">(<!-- -->1<!-- -->)</span></li><li><a href="/tag/notes/page/1">notes</a> <span title="posts count">(<!-- -->6<!-- -->)</span></li><li><a href="/tag/on%20writing/page/1">on writing</a> <span title="posts count">(<!-- -->3<!-- -->)</span></li></ul></div><p class="MuiTypography-root MuiTypography-body2 MuiTypography-colorTextSecondary MuiTypography-alignCenter">© <!-- -->2021<!-- --> Bunyk Taras. Built with Material UI &amp; Next.js</p></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"pageNumber":"1","posts":[{"id":"bare_metal_hello_world","title":"Bare metal \"Hello, world!\"","date":"2021-10-23","toc":true,"tags":["notes","asm"],"excerpt":"\u003cp\u003eFrom time to time I get an itch to write. I mean code. Everything: video games, search engines, operating systems. Many of my old friends \u003ca href=\"https://danbst.wordpress.com/2009/12/26/helloworld_os_boot_sector/\"\u003ewrote their own OSes\u003c/a\u003e (or at least bare-metal code), and I have FOMO.\u003c/p\u003e\n\u003cp\u003eRecently I bought eBook reader with bigger screen than my Kindle. So I went on treasure hunt over internet to fill it with all the awesome free books that I wanted to read, but was not reading, because they did not fit to that tiny Kindle screen. And I found some unfinished free book: \u003ca href=\"https://www.cs.bham.ac.uk/~exr/lectures/opsys/10_11/lectures/os-dev.pdf\"\u003e\"Writing a Simple Operating System - from Scratch\" by Nick Blundel (2010)\u003c/a\u003e. It retriggered that itch to write OS, or at least code that runs without OS again.\u003c/p\u003e\n\u003cp\u003eHere I'll post notes of my journey, skipping boring parts like explaining benefits of hexadecimal notation.\u003c/p\u003e","content":"\u003cp\u003eFrom time to time I get an itch to write. I mean code. Everything: video games, search engines, operating systems. Many of my old friends \u003ca href=\"https://danbst.wordpress.com/2009/12/26/helloworld_os_boot_sector/\"\u003ewrote their own OSes\u003c/a\u003e (or at least bare-metal code), and I have FOMO.\u003c/p\u003e\n\u003cp\u003eRecently I bought eBook reader with bigger screen than my Kindle. So I went on treasure hunt over internet to fill it with all the awesome free books that I wanted to read, but was not reading, because they did not fit to that tiny Kindle screen. And I found some unfinished free book: \u003ca href=\"https://www.cs.bham.ac.uk/~exr/lectures/opsys/10_11/lectures/os-dev.pdf\"\u003e\"Writing a Simple Operating System - from Scratch\" by Nick Blundel (2010)\u003c/a\u003e. It retriggered that itch to write OS, or at least code that runs without OS again.\u003c/p\u003e\n\u003cp\u003eHere I'll post notes of my journey, skipping boring parts like explaining benefits of hexadecimal notation.\u003c/p\u003e\n\u003ch2\u003eInstalling tools\u003c/h2\u003e\n\u003cp\u003eFirst things that we need are assembler and VM to run code produced by that assembler, because I would not risk running code written by me on bare metal, and risk formatting my disk.\u003c/p\u003e\n\u003cp\u003eBook uses Netwide Assembler (NASM) and QEMU as VM. To install them with \u003ccode\u003eapt\u003c/code\u003e, run:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003esudo apt-get install qemu-system-x86 nasm\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOr select installation variant for your system:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.qemu.org/download/\"\u003eQEMU\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.nasm.us/\"\u003eNASM\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBook also has alternative to use Bochs emulator, but I prefer Qemu, because it does not require config file to run\u003c/p\u003e\n\u003cp\u003eTo view a binary file, which is sometimes useful, you could use:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003eod -t x1 -A n boot_sect.bin\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eod\u003c/code\u003e stands for \"octal dump\" (but could dump other formats), \u003ccode\u003e-t x1\u003c/code\u003e stands for \"type (\u003ccode\u003e-t\u003c/code\u003e) hexadecimal (\u003ccode\u003ex\u003c/code\u003e), 1 byte per number\", and \u003ccode\u003e-A n\u003c/code\u003e stands for \"addresses no\" (don't print byte offsets).\u003c/p\u003e\n\u003ch2\u003eNot yet hello world\u003c/h2\u003e\n\u003cp\u003eSo, every tutorial starts from printing hello world to the screen, but this one will finish with it.\u003c/p\u003e\n\u003cp\u003eInstead, we start from code that just runs, and does nothing else, at all:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-x86asm\"\u003e\u003cspan class=\"hljs-comment\"\u003e; infinite loop bootsector\u003c/span\u003e\n\u003cspan class=\"hljs-symbol\"\u003e\nloop:\u003c/span\u003e                 \u003cspan class=\"hljs-comment\"\u003e; define a label (address in code)\u003c/span\u003e\n\t\u003cspan class=\"hljs-keyword\"\u003ejmp\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eloop\u003c/span\u003e          \u003cspan class=\"hljs-comment\"\u003e; go execute code starting from instruction at label\u003c/span\u003e\n\n\u003cspan class=\"hljs-built_in\"\u003etimes\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e510\u003c/span\u003e-($-$$) \u003cspan class=\"hljs-built_in\"\u003edb\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e; pad with zeroes, so whole sector is 512 bytes\u003c/span\u003e\n\n\u003cspan class=\"hljs-built_in\"\u003edw\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0xaa55\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e; last two bytes are magic number to mark this as boot sector\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAssembler is full of abbreviations:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ejmp\u003c/code\u003e stands for jump. It is instruction for CPU to do something.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edb\u003c/code\u003e probably stands for \"define byte\". This is pseudo-instruction of NASM, that says to just put something into particular address in memory.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edw\u003c/code\u003e probably stands for \"define word\" (two bytes)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eInteresting, how, unlike in high-level languages, assembler code translates 1 to 1 to bytes that will be loaded to computer memory. Where data, like magic numbers are mixed with instructions.\u003c/p\u003e\n\u003cp\u003eTo compile:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003enasm boot_sect.asm -f bin -o boot_sect.bin\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo run:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003eqemu-system-x86_64 boot_sect.bin\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eRegisters\u003c/h2\u003e\n\u003cp\u003eWhen we program CPU, instead of using variables, we use \u003cem\u003eregisters\u003c/em\u003e to store our data. Each x86 CPU has 4 general purpose registers: \u003ccode\u003eax\u003c/code\u003e , \u003ccode\u003ebx\u003c/code\u003e, \u003ccode\u003ecx\u003c/code\u003e, \u003ccode\u003edx\u003c/code\u003e, able to store \u003cem\u003eword\u003c/em\u003e, or 16 bits of data. They are way faster to read or write than memory. Also, each byte of register could be referenced separately, as \u003ccode\u003eah\u003c/code\u003e (high) and \u003ccode\u003eal\u003c/code\u003e (low).\u003c/p\u003e\n\u003cp\u003eInstruction \u003ccode\u003emov\u003c/code\u003e moves data from and to register:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003emov ax, 123\u003c/code\u003e - set value of \u003ccode\u003eax\u003c/code\u003e to decimal \u003ccode\u003e123\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emov ax, 0xabcd\u003c/code\u003e - set value of \u003ccode\u003eax\u003c/code\u003e to hexadecimal \u003ccode\u003eabcd\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emov ax, 'a'\u003c/code\u003e - set value of \u003ccode\u003eax\u003c/code\u003e to ASCII code of \u003ccode\u003e'a'\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emov bx, ax\u003c/code\u003e  - copy value of \u003ccode\u003eax\u003c/code\u003e   to \u003ccode\u003ebx\u003c/code\u003e (equivalent of \u003ccode\u003ebx = ax;\u003c/code\u003e in higher-level languages)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eInterrupts\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003eInterrupts\u003c/em\u003e are like a callbacks of CPU. They allow it to interrupt what it currently runs, and run some other code to handle interrupt, before continuing with current task. They are raised by software instruction (for example \u003ccode\u003eint 0x10\u003c/code\u003e) , or by some device requiring action (input some data, etc..)\u003c/p\u003e\n\u003cp\u003eEach interrupt has a number, that is used as index to table set-up by BIOS at the start of memory (address \u003ccode\u003e0x0\u003c/code\u003e), that contains pointers to \u003cem\u003einterrupt service routines (ISRs)\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eSince BIOS has a log of ISRs, they are they are entry points to a set of handlers, indexed with \u003ccode\u003eax\u003c/code\u003e register. \u003ccode\u003eint 0x10\u003c/code\u003e calls a screen-related ISR defined by \u003ccode\u003eax\u003c/code\u003e, and \u003ccode\u003eint 0x13\u003c/code\u003e - disk related IO. They both have inside something like \u003ccode\u003eswitch\u003c/code\u003e statement, that branches depending by \u003ccode\u003eax\u003c/code\u003e value.\u003c/p\u003e\n\u003ch2\u003eHell!\u003c/h2\u003e\n\u003cp\u003eTo print a character on the screen, we need to set \u003ccode\u003eah\u003c/code\u003e to \u003ccode\u003e0xe\u003c/code\u003e (teletype mode screen), \u003ccode\u003eal\u003c/code\u003e to ascii code of character to print, and call \u003ccode\u003eint 0x10\u003c/code\u003e. We could set \u003ccode\u003eah\u003c/code\u003e once per al characters, and then just change \u003ccode\u003eal\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAnd this is how to write bootsector that prints \"Hell!\" on the screen using BIOS interrupt:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-x86asm\"\u003e\u003cspan class=\"hljs-keyword\"\u003emov\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003eah\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0x0e\u003c/span\u003e \t\u003cspan class=\"hljs-comment\"\u003e; teletype mode for BIOS interrupt \u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003emov\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eal\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'H'\u003c/span\u003e \t\u003cspan class=\"hljs-comment\"\u003e; char to print\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0x10\u003c/span\u003e \t\t\u003cspan class=\"hljs-comment\"\u003e; call interrupt to print char\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003emov\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eal\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'e'\u003c/span\u003e \n\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0x10\u003c/span\u003e \n\u003cspan class=\"hljs-keyword\"\u003emov\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eal\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'l'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0x10\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003emov\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eal\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'l'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0x10\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003emov\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eal\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'!'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003ejmp\u003c/span\u003e $\n\n\u003cspan class=\"hljs-built_in\"\u003etimes\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e510\u003c/span\u003e-($-$$) \u003cspan class=\"hljs-built_in\"\u003edb\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e; pad with zeroes\u003c/span\u003e\n\n\u003cspan class=\"hljs-built_in\"\u003edw\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0xaa55\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e; magic number to mark this as boot sector\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt prints \"Hell!\" because \"Hello, world!\" would be too much work. Until we implement strings.\u003c/p\u003e\n\u003cp\u003eOr, one cool trick. Since we are so low level, we could look at binary produced, and figure out that  code\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-x86asm\"\u003e\u003cspan class=\"hljs-keyword\"\u003emov\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eal\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'H'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0x10\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eis compiled to \u003ccode\u003eb0 48 cd 10\u003c/code\u003e, where 48 is ASCII code of \u003ccode\u003e'H'\u003c/code\u003e. So we could write code to print \"Hell\", like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-x86asm\"\u003e\u003cspan class=\"hljs-built_in\"\u003edb\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0xb0\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'H'\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0xcd\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0x10\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003edb\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0xb0\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'e'\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0xcd\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0x10\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003edb\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0xb0\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'l'\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0xcd\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0x10\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003edb\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0xb0\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'l'\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0xcd\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0x10\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLower than that would be just rewiring cables on plugboard.\u003c/p\u003e\n\u003ch2\u003eMemory\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003elabel:\u003c/code\u003e could be seen as constant that stores index of byte in memory from which instruction (or bytes defined by \u003ccode\u003edb\u003c/code\u003e) after it starts.\u003c/p\u003e\n\u003cp\u003eThe problem is, BIOS loads code of boot sector to address \u003ccode\u003e0x7c00\u003c/code\u003e, because beginning of memory is already taken by ISRs, if you remember. To offset our addresses, we could tell assembler that our program will be located there by using directive \u003ccode\u003e[org 0x7c00]\u003c/code\u003e.  We could also do pointer arithmetic manually, be we will do it for more interesting things, which is to print \"Hello, world!\".\u003c/p\u003e\n\u003cp\u003eSo we could put bunch of bytes somewhere after our code using \u003ccode\u003edb \"Hello world!\"\u003c/code\u003e, mark their address using \u003ccode\u003emsg:\u003c/code\u003e, and then use \u003ccode\u003emsg\u003c/code\u003e to set value of \u003ccode\u003eah\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eJust if we will use \u003ccode\u003emv al, msg\u003c/code\u003e, it will put into \u003ccode\u003eal\u003c/code\u003e address marked by \u003ccode\u003emsg\u003c/code\u003e, and later print ASCII value of it. If we want to do pointer dereferencing, we use square brackets \u003ccode\u003emv al, [msg]\u003c/code\u003e. NASM also could do pointer arithmetic for you. This, for example, prints \"Hel\":\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-x86asm\"\u003e[org \u003cspan class=\"hljs-number\"\u003e0x7c00\u003c/span\u003e] \u003cspan class=\"hljs-comment\"\u003e; Memory offset of boot sector\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003emov\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003eah\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0x0e\u003c/span\u003e\u003cspan class=\"hljs-comment\"\u003e; teletype mode\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003emov\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eal\u003c/span\u003e, [msg] \u003cspan class=\"hljs-comment\"\u003e; put value from memory address msg to al\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0x10\u003c/span\u003e \t\n\u003cspan class=\"hljs-keyword\"\u003emov\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eal\u003c/span\u003e, [msg+\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] \u003cspan class=\"hljs-comment\"\u003e; put value from memory address msg+1 to al\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0x10\u003c/span\u003e \t\n\u003cspan class=\"hljs-keyword\"\u003emov\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eal\u003c/span\u003e, [msg+\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e]\n\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0x10\u003c/span\u003e \t\n\n\u003cspan class=\"hljs-keyword\"\u003ejmp\u003c/span\u003e $ \u003cspan class=\"hljs-comment\"\u003e; loop forever\u003c/span\u003e\n\u003cspan class=\"hljs-symbol\"\u003e\nmsg:\u003c/span\u003e \n\u003cspan class=\"hljs-built_in\"\u003edb\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Hello world!\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-built_in\"\u003etimes\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e510\u003c/span\u003e-($-$$) \u003cspan class=\"hljs-built_in\"\u003edb\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e; pad with zeroes\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003edw\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0xaa55\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e; magic number to mark this as boot sector\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eControl structures\u003c/h2\u003e\n\u003cp\u003eIn language C, string is sequence of bytes that ends with byte 0. If we create our string like this, we could write code that loops over addresses starting from beginning of string, and stops when reaches zero character.\u003c/p\u003e\n\u003cp\u003eWe already know how to do infinite loops:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-x86asm\"\u003e\u003cspan class=\"hljs-symbol\"\u003eloop:\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003ejmp\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eloop\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e; or shorter equivalent:\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003ejmp\u003c/span\u003e $\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo program loops that end, we need conditional jumps, and comparison instruction.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ecmp x, y\u003c/code\u003e, compares \u003ccode\u003ex\u003c/code\u003e with \u003ccode\u003ey\u003c/code\u003e, and sets result into special \u003ccode\u003eflags\u003c/code\u003e register. Now, there are instruction that jump depending on the comparison result stored in that register:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eje\u003c/code\u003e - jump if equal\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ejne\u003c/code\u003e - if not equal\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ejl\u003c/code\u003e - less than\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ejle\u003c/code\u003e - less than or equal\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ejg\u003c/code\u003e - greater\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ejge\u003c/code\u003e - greater or equal\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAnd we need a little bit of arithmetic:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003einc ax\u003c/code\u003e - increments \u003ccode\u003eax\u003c/code\u003e (`ax++``)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eadd ax, 2\u003c/code\u003e - adds 2 (or any other value you wish) to \u003ccode\u003eax\u003c/code\u003e (\u003ccode\u003eax+=2\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eHello world, finally\u003c/h2\u003e\n\u003cp\u003ePutting it all together:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-x86asm\"\u003e[org \u003cspan class=\"hljs-number\"\u003e0x7c00\u003c/span\u003e] \u003cspan class=\"hljs-comment\"\u003e; Memory offset of boot sector\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003emov\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003eah\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0x0e\u003c/span\u003e\u003cspan class=\"hljs-comment\"\u003e; teletype mode\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003emov\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ebx\u003c/span\u003e, msg \u003cspan class=\"hljs-comment\"\u003e; put address of message to bx\u003c/span\u003e\n\u003cspan class=\"hljs-symbol\"\u003e\nloop:\u003c/span\u003e\n\t\u003cspan class=\"hljs-keyword\"\u003emov\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eal\u003c/span\u003e, [\u003cspan class=\"hljs-built_in\"\u003ebx\u003c/span\u003e] \u003cspan class=\"hljs-comment\"\u003e; prepare to print character to which bx points now\u003c/span\u003e\n\n\t\u003cspan class=\"hljs-keyword\"\u003ecmp\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eal\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e    \u003cspan class=\"hljs-comment\"\u003e; is it 0?\u003c/span\u003e\n\t\u003cspan class=\"hljs-keyword\"\u003eje\u003c/span\u003e finish    \u003cspan class=\"hljs-comment\"\u003e; if yes - jump to finish\u003c/span\u003e\n\n\t\u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0x10\u003c/span\u003e \t \u003cspan class=\"hljs-comment\"\u003e; print current character\u003c/span\u003e\n\n\t\u003cspan class=\"hljs-keyword\"\u003einc\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ebx\u003c/span\u003e \t\t \u003cspan class=\"hljs-comment\"\u003e; go to next byte\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003ejmp\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eloop\u003c/span\u003e\n\u003cspan class=\"hljs-symbol\"\u003e\nfinish:\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003ejmp\u003c/span\u003e $ \u003cspan class=\"hljs-comment\"\u003e; loop forever\u003c/span\u003e\n\u003cspan class=\"hljs-symbol\"\u003e\nmsg:\u003c/span\u003e \n\u003cspan class=\"hljs-built_in\"\u003edb\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Hello, world!\"\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n\n\u003cspan class=\"hljs-built_in\"\u003etimes\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e510\u003c/span\u003e-($-$$) \u003cspan class=\"hljs-built_in\"\u003edb\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e; pad with zeroes\u003c/span\u003e\n\n\u003cspan class=\"hljs-built_in\"\u003edw\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0xaa55\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e; magic number to mark this as boot sector\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you forget to jump to finish, and make infinite loop, you could print content of whole memory. Which of course will be trash once you went over \"Hello, world!\", all the zeroes and magic number.\u003c/p\u003e\n\u003cp\u003eNext level from here, would probably be to try to fit \"fizz buzz\" into boot sector, or load more sectors.\u003c/p\u003e"}],"pages":1,"archives":[{"url":"/month/2021-10/page/1","id":"2021-10","count":1,"title":"2021-10"},{"url":"/month/2021-01/page/1","id":"2021-01","count":4,"title":"2021-01"},{"url":"/month/2020-12/page/1","id":"2020-12","count":1,"title":"2020-12"},{"url":"/month/2020-09/page/1","id":"2020-09","count":2,"title":"2020-09"},{"url":"/month/2020-08/page/1","id":"2020-08","count":2,"title":"2020-08"},{"url":"/month/2020-07/page/1","id":"2020-07","count":10,"title":"2020-07"},{"url":"/month/2020-06/page/1","id":"2020-06","count":7,"title":"2020-06"},{"url":"/month/2018-12/page/1","id":"2018-12","count":1,"title":"2018-12"}],"topics":[{"url":"/tag/MOOC/page/1","id":"MOOC","title":"MOOC","count":2},{"url":"/tag/SICP/page/1","id":"SICP","title":"SICP","count":20},{"url":"/tag/asm/page/1","id":"asm","title":"asm","count":1},{"url":"/tag/ideas/page/1","id":"ideas","title":"ideas","count":1},{"url":"/tag/notes/page/1","id":"notes","title":"notes","count":6},{"url":"/tag/on writing/page/1","id":"on writing","title":"on writing","count":3}],"tag":"asm"},"__N_SSG":true},"page":"/tag/[tag]/page/[page]","query":{"tag":"asm","page":"1"},"buildId":"vTIm-6E4fBbgVLRlj9tfU","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>