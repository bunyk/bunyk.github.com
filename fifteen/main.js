// Generated by CoffeeScript 1.6.1
(function() {
  var $, FIELD_SIZE, Field, TILE_MARGIN, TILE_SIZE, draw_field, get_svg, onkeydown, rand03, sign;

  $ = jQuery;

  FIELD_SIZE = 400;

  TILE_SIZE = FIELD_SIZE / 4;

  TILE_MARGIN = 4;

  $(function() {
    var field, svg;
    $('.widget_block').show();
    svg = get_svg();
    field = new Field;
    draw_field(svg, field);
    return d3.select("body").on("keydown", function() {
      return onkeydown(d3.event.keyCode, field, svg);
    });
  });

  onkeydown = function(keyCode, field, svg) {
    if (keyCode === 32) {
      field.shuffle();
      return draw_field(svg, field);
    }
  };

  draw_field = function(svg, field) {
    var tileenter, tiles;
    tiles = svg.selectAll('.tile').data(field.get_tiles_data());
    tileenter = tiles.enter().append('g');
    tileenter.attr('class', 'tile');
    tileenter.append('rect').attr('y', TILE_MARGIN).attr('x', TILE_MARGIN).attr('width', TILE_SIZE - TILE_MARGIN * 2).attr('height', TILE_SIZE - TILE_MARGIN * 2).attr('ry', 10).attr('rx', 10).attr('stroke-width', 5).attr('stroke', '#000').attr('fill', '#ccc');
    tileenter.append('text').attr('x', TILE_SIZE / 2).attr('y', TILE_SIZE / 2).attr('font-size', 47).attr('font-family', "Cursive").attr('text-anchor', "middle").attr('dominant-baseline', "middle");
    tiles.transition().attr('transform', function(d) {
      return "translate(" + d.x + ", " + d.y + ")";
    });
    tiles.select('text').text(function(d) {
      return d.id;
    });
    tiles.on('click', function(d) {
      field.move_tiles(d.id);
      return draw_field(svg, field);
    });
    return tiles.exit().remove();
  };

  get_svg = function() {
    var panel, svg;
    panel = d3.select('.widget_block');
    return svg = panel.append('svg').attr('width', FIELD_SIZE).attr('height', FIELD_SIZE).style('border', 'solid black 5px');
  };

  rand03 = function() {
    return Math.floor(Math.random() * 4);
  };

  sign = function(x) {
    if (x < 0) {
      return -1;
    } else {
      return 1;
    }
  };

  Field = (function() {

    function Field() {
      this.tiles = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 0]];
    }

    Field.prototype.shuffle = function() {
      var a_x, a_y, b_x, b_y, i, _i, _ref, _results;
      _results = [];
      for (i = _i = 0; _i <= 100; i = ++_i) {
        a_x = rand03();
        a_y = rand03();
        b_x = rand03();
        b_y = rand03();
        _results.push((_ref = [this.tiles[b_y][b_x], this.tiles[a_y][a_x]], this.tiles[a_y][a_x] = _ref[0], this.tiles[b_y][b_x] = _ref[1], _ref));
      }
      return _results;
    };

    Field.prototype.get_tile_coords = function(id) {
      var x, y, _i, _j;
      for (y = _i = 0; _i <= 3; y = ++_i) {
        for (x = _j = 0; _j <= 3; x = ++_j) {
          if (this.tiles[y][x] === id) {
            return {
              x: x,
              y: y
            };
          }
        }
      }
    };

    Field.prototype.get_tiles_data = function() {
      var data, x, y, _i, _j;
      data = [];
      for (y = _i = 0; _i <= 3; y = ++_i) {
        for (x = _j = 0; _j <= 3; x = ++_j) {
          if (this.tiles[y][x]) {
            data.push({
              x: x * TILE_SIZE,
              y: y * TILE_SIZE,
              id: this.tiles[y][x]
            });
          }
        }
      }
      return _.sortBy(data, function(d) {
        return d.id;
      });
    };

    Field.prototype.move_tiles = function(id) {
      var empty_cell, move_cell, move_x, move_y, x, y, _i, _j, _ref, _ref1, _ref2, _ref3;
      empty_cell = this.get_tile_coords(0);
      move_cell = this.get_tile_coords(id);
      move_x = empty_cell.x - move_cell.x;
      move_y = empty_cell.y - move_cell.y;
      if (move_x === 0) {
        x = empty_cell.x;
        for (y = _i = _ref = empty_cell.y, _ref1 = move_cell.y; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; y = _ref <= _ref1 ? ++_i : --_i) {
          this.tiles[y][x] = this.tiles[y - sign(move_y)][x];
        }
        this.tiles[move_cell.y][x] = 0;
        return;
      }
      if (move_y === 0) {
        y = empty_cell.y;
        for (x = _j = _ref2 = empty_cell.x, _ref3 = move_cell.x; _ref2 <= _ref3 ? _j < _ref3 : _j > _ref3; x = _ref2 <= _ref3 ? ++_j : --_j) {
          this.tiles[y][x] = this.tiles[y][x - sign(move_x)];
        }
        this.tiles[y][move_cell.x] = 0;
      }
    };

    return Field;

  })();

}).call(this);
