{"pageProps":{"id":"testcontainers_go","title":"Testing go code with real database using testcontainers","date":"2022-06-29T08:34:06.000Z","tags":["go"],"updated_at":"2022-10-25T16:53:30+02:00","content":"<p>Unit tests are a good thing. They run fast, and allow you to be more confident that you have not broken logic that they verify. If you find a bug, and write a test that reproduces it, you could make sure that bug will not return. They try to, for example, when some developer that comes after you wants to simplify your code, and misses a corner case.</p>\n<p>But unit tests usually test some unit (usually function) of your program in isolation, therefore the name. They mock all the dependencies, including database connection. That has its advantages, but also downsides. Sometimes, your back-end code is just a glue between HTTP and database,  and a lot of your logic is implemented directly in the database. Bugs could hide in the database and in the interface to database (especially if you try to build query dynamically). And it would be nice to be able to automatically verify that your queries will work with your DB.</p>\n<p>To do that in Python world, you usually have some ORM, which connects to PostgreSQL on production, and to in-memory SQLite when running tests. ORM generates different SQL for that cases, but if you are not running super complex queries, you could be confident enough that behavior of code will be the similar in tests and in live environment.</p>\n<p>I though that similar thing is impossible in Go where it's not common to use ORM. Until my teammate with Java background introduced <a href=\"https://golang.testcontainers.org/\"><code>testcontainers</code></a> library to our projects. Here is a <a href=\"https://engineering.zalando.com/posts/2021/02/integration-tests-with-testcontainers.html\">post about testcontainers for Java devs on engineering blog of my company</a>.</p>\n<p>Now let's see how to write automated tests that verify the correct end to end behavior of an app, by creating a PostgreSQL DB in a container.</p>\n<h2 id=\"example-service\">Example service</h2>\n<p>Let's imagine that we are building the rating service. It stores products (or restaurants, blog articles, Stack Overflow comments, whatever). And users leave feedback in a form of a like or dislike. It will have following, simplified API:</p>\n<ul>\n<li><code>POST /products {name: 'Go'}</code> - creates a new product with given name</li>\n<li><code>GET /products</code> returns products ordered by rating <code>[{id: 1, name: 'postgres' likes: 20, dislikes: 0}, {id: 2, name: 'MariaDB' likes: 15, dislikes: 6}, ...]</code></li>\n<li><code>POST /products/:id:/like</code> - adds a new like for a product</li>\n<li><code>POST /products/:id:/dislike</code> - adds a dislike</li>\n</ul>\n<p>When computing rating, we would use <a href=\"https://en.wikipedia.org/wiki/Rule_of_succession\">rule of succession</a> to make sure that product with one like (100% of likes), is not rated higher than product with 99 likes and 1 dislike (99% of likes). For that, we assume that there are always one additional \"prior\" like and one \"prior\" dislike for each product. So products with zero explicit likes or dislikes, have 50% positive rating, and having one like increases that percent to 66%. The more feedback the product gets, the less impact this prior implicit feedback has on final rating.</p>\n<p>For the sake of simplicity, we skip authorization and other details like getting product by id, pagination, or limiting number of likes per product per user. So we could implement functionality quickly and focus on building tests.</p>\n<h2 id=\"implementation\">Implementation</h2>\n<p>Start a new go project called <code>postest</code>, and add two dependencies:</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-built_in\">mkdir</span> postest\ngo mod init example/postest\ngo get github.com/gin-gonic/gin <span class=\"hljs-comment\"># for API</span>\ngo get github.com/jackc/pgx/v4  <span class=\"hljs-comment\"># for storage</span>\n<span class=\"hljs-built_in\">mkdir</span> api\n<span class=\"hljs-built_in\">mkdir</span> store</code></pre>\n<p>Database schema has just one table that looks like this:</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> IF <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">EXISTS</span> products (\n\tid SERIAL <span class=\"hljs-keyword\">PRIMARY</span> KEY,\n\tname <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">255</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>,\n\tlikes <span class=\"hljs-type\">INT</span> <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-number\">0</span>,\n\tdislikes <span class=\"hljs-type\">INT</span> <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-number\">0</span>\n)</code></pre>\n<p>And when we select from it, we will use rule of succession to order results like this:</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> (likes <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">1</span>) <span class=\"hljs-operator\">/</span> (likes <span class=\"hljs-operator\">+</span> dislikes <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">2</span>) <span class=\"hljs-keyword\">DESC</span></code></pre>\n<p>So if you have apples with 1 like and 0 dislikes, and bananas with 9 likes and 1 dislike, you will get value (1 + 1) / (1 + 0 + 2) = 0.666 for apples, and (9 + 1) / (9 + 1 + 2) = 0.833 for bananas, so bananas will go higher in ranking.</p>\n<p>Now, below I'll just put listings of code for <code>api</code> and <code>store</code> packages, and <code>main.go</code>, so you could follow along. If you just want to read - scroll until the <a href=\"#testing\">testing section</a>.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> api\n\n<span class=\"hljs-keyword\">import</span> (\n\t<span class=\"hljs-string\">\"net/http\"</span>\n\n\t<span class=\"hljs-string\">\"github.com/gin-gonic/gin\"</span>\n\n\t<span class=\"hljs-string\">\"example/postest/store\"</span>\n)\n\n<span class=\"hljs-keyword\">type</span> api <span class=\"hljs-keyword\">struct</span> {\n\tstore store.Store\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">New</span><span class=\"hljs-params\">(s store.Store)</span></span> *gin.Engine {\n\ta := api{store: s}\n\tr := gin.Default()\n\tr.GET(<span class=\"hljs-string\">\"/products\"</span>, a.getProducts)\n\tr.POST(<span class=\"hljs-string\">\"/products\"</span>, a.createProduct)\n\tr.POST(<span class=\"hljs-string\">\"/products/:id/like\"</span>, a.likeProduct)\n\tr.POST(<span class=\"hljs-string\">\"/products/:id/dislike\"</span>, a.dislikeProduct)\n\t<span class=\"hljs-keyword\">return</span> r\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(a api)</span></span> getProducts(c *gin.Context) {\n\tproducts, err := a.store.GetProducts(c.Request.Context())\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\tc.JSON(http.StatusInternalServerError, gin.H{<span class=\"hljs-string\">\"error\"</span>: err.Error()})\n\t\t<span class=\"hljs-keyword\">return</span>\n\t}\n\tc.IndentedJSON(http.StatusOK, products)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(a api)</span></span> createProduct(c *gin.Context) {\n\t<span class=\"hljs-keyword\">var</span> p store.Product\n\t<span class=\"hljs-keyword\">if</span> err := c.ShouldBindJSON(&#x26;p); err != <span class=\"hljs-literal\">nil</span> {\n\t\tc.JSON(http.StatusBadRequest, gin.H{<span class=\"hljs-string\">\"error\"</span>: err.Error()})\n\t\t<span class=\"hljs-keyword\">return</span>\n\t}\n\tp, err := a.store.CreateProduct(c.Request.Context(), p)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\tc.JSON(http.StatusInternalServerError, gin.H{<span class=\"hljs-string\">\"error\"</span>: err.Error()})\n\t\t<span class=\"hljs-keyword\">return</span>\n\t}\n\tc.JSON(http.StatusCreated, p)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(a api)</span></span> likeProduct(c *gin.Context) {\n\ta.rateProduct(c, <span class=\"hljs-literal\">true</span>)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(a api)</span></span> dislikeProduct(c *gin.Context) {\n\ta.rateProduct(c, <span class=\"hljs-literal\">false</span>)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(a api)</span></span> rateProduct(c *gin.Context, like <span class=\"hljs-type\">bool</span>) {\n\tid := c.Param(<span class=\"hljs-string\">\"id\"</span>)\n\t<span class=\"hljs-keyword\">if</span> err := a.store.RateProduct(c.Request.Context(), id, like); err != <span class=\"hljs-literal\">nil</span> {\n\t\tc.JSON(http.StatusInternalServerError, gin.H{<span class=\"hljs-string\">\"error\"</span>: err.Error()})\n\t\t<span class=\"hljs-keyword\">return</span>\n\t}\n\tc.Status(http.StatusOK)\n}</code></pre>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> store\n\n<span class=\"hljs-keyword\">import</span> (\n\t<span class=\"hljs-string\">\"context\"</span>\n\t<span class=\"hljs-string\">\"fmt\"</span>\n\n\t<span class=\"hljs-string\">\"github.com/jackc/pgx/v4/pgxpool\"</span>\n)\n\n<span class=\"hljs-keyword\">type</span> Product <span class=\"hljs-keyword\">struct</span> {\n\tID       <span class=\"hljs-type\">int</span>    <span class=\"hljs-string\">`json:\"id\"`</span>\n\tName     <span class=\"hljs-type\">string</span> <span class=\"hljs-string\">`json:\"name\"`</span>\n\tLikes    <span class=\"hljs-type\">int</span>    <span class=\"hljs-string\">`json:\"likes\"`</span>\n\tDislikes <span class=\"hljs-type\">int</span>    <span class=\"hljs-string\">`json:\"dislikes\"`</span>\n}\n\n<span class=\"hljs-keyword\">type</span> Store <span class=\"hljs-keyword\">struct</span> {\n\tdb *pgxpool.Pool\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">New</span><span class=\"hljs-params\">(dsn <span class=\"hljs-type\">string</span>)</span></span> (s Store, err <span class=\"hljs-type\">error</span>) {\n\ts.db, err = pgxpool.Connect(context.Background(), dsn)\n\t<span class=\"hljs-keyword\">return</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(s Store)</span></span> Migrate() <span class=\"hljs-type\">error</span> {\n\t_, err := s.db.Exec(context.Background(), <span class=\"hljs-string\">`\n\t\tCREATE TABLE IF NOT EXISTS products (\n\t\t\tid SERIAL PRIMARY KEY,\n\t\t\tname VARCHAR(255) NOT NULL,\n\t\t\tlikes INT NOT NULL DEFAULT 0,\n\t\t\tdislikes INT NOT NULL DEFAULT 0\n\t\t)\n\t`</span>)\n\t<span class=\"hljs-keyword\">return</span> err\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(s Store)</span></span> GetProducts(ctx context.Context) ([]Product, <span class=\"hljs-type\">error</span>) {\n\t<span class=\"hljs-keyword\">var</span> products []Product\n\trows, err := s.db.Query(ctx, <span class=\"hljs-string\">`\n\t\tSELECT id, name, likes, dislikes\n\t\tFROM products\n\t\tORDER BY (likes + 1) / (likes + dislikes + 2) DESC\n\t`</span>)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, err\n\t}\n\t<span class=\"hljs-keyword\">defer</span> rows.Close()\n\t<span class=\"hljs-keyword\">for</span> rows.Next() {\n\t\t<span class=\"hljs-keyword\">var</span> p Product\n\t\terr = rows.Scan(&#x26;p.ID, &#x26;p.Name, &#x26;p.Likes, &#x26;p.Dislikes)\n\t\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, err\n\t\t}\n\t\tproducts = <span class=\"hljs-built_in\">append</span>(products, p)\n\t}\n\t<span class=\"hljs-keyword\">return</span> products, <span class=\"hljs-literal\">nil</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(s Store)</span></span> CreateProduct(ctx context.Context, p Product) (Product, <span class=\"hljs-type\">error</span>) {\n\terr := s.db.QueryRow(context.Background(), <span class=\"hljs-string\">\"INSERT INTO products (name) VALUES ($1) RETURNING id\"</span>, p.Name).Scan(&#x26;p.ID)\n\t<span class=\"hljs-keyword\">return</span> p, err\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(s Store)</span></span> RateProduct(ctx context.Context, id <span class=\"hljs-type\">string</span>, like <span class=\"hljs-type\">bool</span>) <span class=\"hljs-type\">error</span> {\n\tfield := <span class=\"hljs-string\">\"dislikes\"</span>\n\t<span class=\"hljs-keyword\">if</span> like {\n\t\tfield = <span class=\"hljs-string\">\"likes\"</span>\n\t}\n\tr, err := s.db.Exec(ctx, fmt.Sprintf(<span class=\"hljs-string\">\"UPDATE products SET %s = %s + 1 WHERE id = $1\"</span>, field, field), id)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> err\n\t}\n\t<span class=\"hljs-keyword\">if</span> n := r.RowsAffected(); n == <span class=\"hljs-number\">0</span> {\n\t\t<span class=\"hljs-keyword\">return</span> fmt.Errorf(<span class=\"hljs-string\">\"no product with id %s\"</span>, id)\n\t}\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n}</code></pre>\n<p>And in case we would want to run it, here is the <code>main.go</code> file:</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> (\n\t<span class=\"hljs-string\">\"log\"</span>\n\n\t<span class=\"hljs-string\">\"example/postest/api\"</span>\n\t<span class=\"hljs-string\">\"example/postest/store\"</span>\n)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\ts, err := store.New(<span class=\"hljs-string\">\"postgres://reviews_user:pass@localhost:5432/reviews\"</span>)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\tlog.Fatal(err)\n\t}\n\terr = s.Migrate()\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\tlog.Fatal(err)\n\t}\n\tr := api.New(s)\n\n\tlog.Println(<span class=\"hljs-string\">\"Listening on :8080\"</span>)\n\tr.Run(<span class=\"hljs-string\">\":8080\"</span>)\n}</code></pre>\n<h2 id=\"testing\">Testing</h2>\n<p>Now, how to test it? When we test manually, we connect to some database, like in <code>main.go</code> example above, and try different requests. We will do similar from our automated tests.</p>\n<p>But first, create yet another package to aid with our test database container creation. Le'ts call it <code>testdb</code>. Testcontainers help to create any docker containers from Go, <code>testdb</code> will create PostgreSQL DB test container exactly for our needs.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> testdb\n\n<span class=\"hljs-keyword\">import</span> (\n\t<span class=\"hljs-string\">\"context\"</span>\n\t<span class=\"hljs-string\">\"fmt\"</span>\n\n\t<span class=\"hljs-string\">\"github.com/testcontainers/testcontainers-go\"</span>\n\t<span class=\"hljs-string\">\"github.com/testcontainers/testcontainers-go/wait\"</span>\n)\n\n<span class=\"hljs-keyword\">type</span> TestDBContainer <span class=\"hljs-keyword\">struct</span> {\n\ttestcontainers.Container\n\tcontext context.Context\n\tURI     <span class=\"hljs-type\">string</span>\n}\n\n<span class=\"hljs-comment\">// logConsumer is log consumer to propagate logs of container to stdout</span>\n<span class=\"hljs-keyword\">type</span> TestLogConsumer <span class=\"hljs-keyword\">struct</span>{}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(g TestLogConsumer)</span></span> Accept(l testcontainers.Log) {\n\tfmt.Println(l.LogType, <span class=\"hljs-type\">string</span>(l.Content))\n}\n\n<span class=\"hljs-keyword\">var</span> logConsumer TestLogConsumer\n\n<span class=\"hljs-comment\">// We hard-code credentials here, since it's for one-time DB</span>\n<span class=\"hljs-comment\">// so they are not very important</span>\n<span class=\"hljs-keyword\">const</span> (\n\tdb       = <span class=\"hljs-string\">\"test_db\"</span>\n\tuser     = <span class=\"hljs-string\">\"test_user\"</span>\n\tpassword = <span class=\"hljs-string\">\"test_password\"</span>\n)\n\n<span class=\"hljs-comment\">// Create container with our test database</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">New</span><span class=\"hljs-params\">(ctx context.Context)</span></span> (*TestDBContainer, <span class=\"hljs-type\">error</span>) {\n\t<span class=\"hljs-comment\">// ContainerRequest describes Docker container we want to run</span>\n\treq := testcontainers.ContainerRequest{\n\t\tImage:        <span class=\"hljs-string\">\"postgres:latest\"</span>,\n\t\tExposedPorts: []<span class=\"hljs-type\">string</span>{<span class=\"hljs-string\">\"5432/tcp\"</span>, <span class=\"hljs-string\">\"8080/tcp\"</span>},\n\t\tEnv: <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">string</span>]<span class=\"hljs-type\">string</span>{\n\t\t\t<span class=\"hljs-string\">\"POSTGRES_DB\"</span>:       db,\n\t\t\t<span class=\"hljs-string\">\"POSTGRES_USER\"</span>:     user,\n\t\t\t<span class=\"hljs-string\">\"POSTGRES_PASSWORD\"</span>: password,\n\t\t},\n\t\tWaitingFor: wait.ForLog(<span class=\"hljs-string\">`listening on IPv4 address \"0.0.0.0\", port 5432`</span>),\n\t}\n\t<span class=\"hljs-comment\">// Run container</span>\n\tcontainer, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{\n\t\tContainerRequest: req,\n\t\tStarted:          <span class=\"hljs-literal\">true</span>, <span class=\"hljs-comment\">// block this call until container is started</span>\n\t})\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, err\n\t}\n\n\t<span class=\"hljs-comment\">// use logConsumer to print logs to stdout</span>\n\terr = container.StartLogProducer(ctx)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, err\n\t}\n\tcontainer.FollowOutput(logConsumer)\n\n\t<span class=\"hljs-comment\">// Get externally mapped port</span>\n\tmappedPort, err := container.MappedPort(ctx, <span class=\"hljs-string\">\"5432\"</span>)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, err\n\t}\n\n\t<span class=\"hljs-comment\">// Get container host</span>\n\thostIP, err := container.Host(ctx)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, err\n\t}\n\n\t<span class=\"hljs-comment\">// Build a DB URL connection string</span>\n\turi := fmt.Sprintf(<span class=\"hljs-string\">\"postgres://%s:%s@%s:%s/%s\"</span>, user, password, hostIP, mappedPort.Port(), db)\n\n\t<span class=\"hljs-keyword\">return</span> &#x26;TestDBContainer{\n\t\tContainer: container,\n\t\tURI:       uri,\n\t\tcontext:   ctx,\n\t}, <span class=\"hljs-literal\">nil</span>\n}\n\n<span class=\"hljs-comment\">// Stop the container</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(t *TestDBContainer)</span></span> Close() <span class=\"hljs-type\">error</span> {\n\t<span class=\"hljs-keyword\">return</span> t.Container.Terminate(t.context)\n}</code></pre>\n<p>And don't forget to install testcontainers package itself:</p>\n<pre><code class=\"hljs language-bash\">go get github.com/testcontainers/testcontainers-go</code></pre>\n<p>Now, let's add tests in <code>api/api_test.go</code>:</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> api\n\n<span class=\"hljs-keyword\">import</span> (\n\t<span class=\"hljs-string\">\"context\"</span>\n\t<span class=\"hljs-string\">\"io\"</span>\n\t<span class=\"hljs-string\">\"io/ioutil\"</span>\n\t<span class=\"hljs-string\">\"log\"</span>\n\t<span class=\"hljs-string\">\"net/http\"</span>\n\t<span class=\"hljs-string\">\"net/http/httptest\"</span>\n\t<span class=\"hljs-string\">\"strings\"</span>\n\t<span class=\"hljs-string\">\"testing\"</span>\n\t<span class=\"hljs-string\">\"time\"</span>\n\n\t<span class=\"hljs-string\">\"example/postest/store\"</span>\n\t<span class=\"hljs-string\">\"example/postest/testdb\"</span>\n\n\t<span class=\"hljs-string\">\"github.com/stretchr/testify/assert\"</span>\n)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">TestCreationAndRatingFlow</span><span class=\"hljs-params\">(t *testing.T)</span></span> {\n\t<span class=\"hljs-keyword\">var</span> err <span class=\"hljs-type\">error</span>\n\tctx, _ := context.WithTimeout(context.Background(), time.Second*<span class=\"hljs-number\">600</span>)\n\ttestDB, err := testdb.New(ctx)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\tlog.Fatal(err)\n\t}\n\ts, err := store.New(testDB.URI)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\tlog.Fatal(err)\n\t}\n\terr = s.Migrate()\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\tlog.Fatal(err)\n\t}\n\n\ta := New(s)\n\th := a.Handler()\n\n\tbody, status, err := doRequest(h, <span class=\"hljs-string\">\"GET\"</span>, <span class=\"hljs-string\">\"/products\"</span>, <span class=\"hljs-string\">\"\"</span>)\n\tassert.Nil(t, err)\n\tassert.Equal(t, http.StatusOK, status)\n\tassert.JSONEq(t, <span class=\"hljs-string\">`[]`</span>, body)\n\n\t<span class=\"hljs-comment\">// Test that product is created:</span>\n\tbody, status, err = doRequest(h, <span class=\"hljs-string\">\"POST\"</span>, <span class=\"hljs-string\">\"/products\"</span>, <span class=\"hljs-string\">`{\"name\":\"apple\"}`</span>)\n\tassert.Nil(t, err)\n\tassert.Equal(t, http.StatusCreated, status)\n\tassert.JSONEq(t, <span class=\"hljs-string\">`{\"id\":1,\"name\":\"apple\",\"likes\":0,\"dislikes\":0}`</span>, body)\n\n\tbody, status, err = doRequest(h, <span class=\"hljs-string\">\"POST\"</span>, <span class=\"hljs-string\">\"/products\"</span>, <span class=\"hljs-string\">`{\"name\":\"banana\"}`</span>)\n\tassert.Nil(t, err)\n\tassert.Equal(t, http.StatusCreated, status)\n\tassert.JSONEq(t, <span class=\"hljs-string\">`{\"id\":2,\"name\":\"banana\",\"likes\":0,\"dislikes\":0}`</span>, body)\n\n\t<span class=\"hljs-comment\">// Now should return two products:</span>\n\tbody, status, err = doRequest(h, <span class=\"hljs-string\">\"GET\"</span>, <span class=\"hljs-string\">\"/products\"</span>, <span class=\"hljs-string\">\"\"</span>)\n\tassert.Nil(t, err)\n\tassert.Equal(t, http.StatusOK, status)\n\tassert.JSONEq(t, <span class=\"hljs-string\">`[\n\t\t{\"id\":1,\"name\":\"apple\",\"likes\":0,\"dislikes\":0},\n\t\t{\"id\":2,\"name\":\"banana\",\"likes\":0,\"dislikes\":0}\n\t]`</span>, body)\n\n\t<span class=\"hljs-comment\">// Like banana:</span>\n\tbody, status, err = doRequest(h, <span class=\"hljs-string\">\"POST\"</span>, <span class=\"hljs-string\">\"/products/2/like\"</span>, <span class=\"hljs-string\">\"\"</span>)\n\tassert.Nil(t, err)\n\tassert.Equal(t, http.StatusOK, status)\n\n\t<span class=\"hljs-comment\">// Now banana should be at top:</span>\n\tbody, status, err = doRequest(h, <span class=\"hljs-string\">\"GET\"</span>, <span class=\"hljs-string\">\"/products\"</span>, <span class=\"hljs-string\">\"\"</span>)\n\tassert.JSONEq(t, <span class=\"hljs-string\">`[\n\t\t{\"id\":2,\"name\":\"banana\",\"likes\":1,\"dislikes\":0},\n\t\t{\"id\":1,\"name\":\"apple\",\"likes\":0,\"dislikes\":0}\n\t]`</span>, body)\n\n\t<span class=\"hljs-comment\">// Like apple twice:</span>\n\t_, _, _ = doRequest(h, <span class=\"hljs-string\">\"POST\"</span>, <span class=\"hljs-string\">\"/products/1/like\"</span>, <span class=\"hljs-string\">\"\"</span>)\n\t_, _, _ = doRequest(h, <span class=\"hljs-string\">\"POST\"</span>, <span class=\"hljs-string\">\"/products/1/like\"</span>, <span class=\"hljs-string\">\"\"</span>)\n\n\t<span class=\"hljs-comment\">// Now apple should be on top again:</span>\n\tbody, status, err = doRequest(h, <span class=\"hljs-string\">\"GET\"</span>, <span class=\"hljs-string\">\"/products\"</span>, <span class=\"hljs-string\">\"\"</span>)\n\tassert.JSONEq(t, <span class=\"hljs-string\">`[\n\t\t{\"id\":1,\"name\":\"apple\",\"likes\":2,\"dislikes\":0},\n\t\t{\"id\":2,\"name\":\"banana\",\"likes\":1,\"dislikes\":0}\n\t]`</span>, body)\n\n\t<span class=\"hljs-comment\">// Like banana, dislike apple:</span>\n\t_, _, _ = doRequest(h, <span class=\"hljs-string\">\"POST\"</span>, <span class=\"hljs-string\">\"/products/2/like\"</span>, <span class=\"hljs-string\">\"\"</span>)\n\t_, _, _ = doRequest(h, <span class=\"hljs-string\">\"POST\"</span>, <span class=\"hljs-string\">\"/products/1/dislike\"</span>, <span class=\"hljs-string\">\"\"</span>)\n\n\t<span class=\"hljs-comment\">// Now banana should be on top again:</span>\n\tbody, status, err = doRequest(h, <span class=\"hljs-string\">\"GET\"</span>, <span class=\"hljs-string\">\"/products\"</span>, <span class=\"hljs-string\">\"\"</span>)\n\tassert.JSONEq(t, <span class=\"hljs-string\">`[\n\t\t{\"id\":2,\"name\":\"banana\",\"likes\":2,\"dislikes\":0},\n\t\t{\"id\":1,\"name\":\"apple\",\"likes\":2,\"dislikes\":1}\n\t]`</span>, body)\n\n\ttestDB.Close()\n}\n\n<span class=\"hljs-comment\">// helper function to test handler using httptest recorder</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">doRequest</span><span class=\"hljs-params\">(h http.Handler, method, path, body <span class=\"hljs-type\">string</span>)</span></span> (content <span class=\"hljs-type\">string</span>, status <span class=\"hljs-type\">int</span>, err <span class=\"hljs-type\">error</span>) {\n\t<span class=\"hljs-keyword\">var</span> bodyReader io.Reader\n\t<span class=\"hljs-keyword\">if</span> body != <span class=\"hljs-string\">\"\"</span> {\n\t\tbodyReader = strings.NewReader(body)\n\t}\n\treq := httptest.NewRequest(method, path, bodyReader)\n\tw := httptest.NewRecorder()\n\th.ServeHTTP(w, req)\n\tres := w.Result()\n\t<span class=\"hljs-keyword\">defer</span> res.Body.Close()\n\tdata, err := ioutil.ReadAll(res.Body)\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">string</span>(data), res.StatusCode, err\n}</code></pre>\n<p>Here I did everything in one testcase. Here all the cases run from one function, one after another. Just to save myself some work like creating a lot of fixtures, so results of previous test are used in next ones.</p>\n<p>When we would want to do multiple independent tests, but share DB (because creating DB container for each testcase takes forever), I suggest to use <code>TestMain</code> to create and cleanup database container. Just be careful so tests do not influence each others in bad ways.</p>\n<h2 id=\"debugging\">Debugging</h2>\n<p>But surprise! When we run the tests above, they fail. Banana with one like is not rated above apple. To debug that, I pause tests execution by inserting  <code>time.Sleep(300 * time.Second)</code> where needed.</p>\n<p>While tests sleep, we could open their DB and check what's going on. <code>docker ps</code> will show you name of the PostgreSQL container. And then:</p>\n<pre><code class=\"hljs language-bash\">docker <span class=\"hljs-built_in\">exec</span> -it <span class=\"hljs-variable\">$CONTAINER_NAME</span> psql -U test_user test_db</code></pre>\n<p>Will launch a <code>psql</code> client. There we could see that our like is stored successfully:</p>\n<pre><code>test_db=# select * from products;\n id |  name  | likes | dislikes \n----+--------+-------+----------\n  1 | apple  |     0 |        0\n  2 | banana |     1 |        0\n</code></pre>\n<p>But rating is not calculated properly:</p>\n<pre><code>test_db=# select name, (likes + 1) / (likes + dislikes + 2) as rating from products;\n  name  | rating \n--------+--------\n apple  |      0\n banana |      0\n(2 rows)\n</code></pre>\n<p>Checking case for apples <code>(0 + 1) / (0 + 0 + 2)</code>  we see that we have a problem caused by division:</p>\n<pre><code>test_db=# select 1 / 2;\n ?column? \n----------\n        0\n(1 row)\n\ntest_db=# select 1.0 / 2.0;\n        ?column?        \n------------------------\n 0.50000000000000000000\n\n</code></pre>\n<p>Yeah, integer division! Open <code>store/store.go</code> and instead of</p>\n<pre><code class=\"hljs language-sql\">\t\t<span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> (likes <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">1</span>) <span class=\"hljs-operator\">/</span> (likes <span class=\"hljs-operator\">+</span> dislikes <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">2</span>) <span class=\"hljs-keyword\">DESC</span></code></pre>\n<p>write</p>\n<pre><code class=\"hljs language-sql\">\t\t<span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> (likes <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">1.0</span>) <span class=\"hljs-operator\">/</span> (likes <span class=\"hljs-operator\">+</span> dislikes <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">2.0</span>) <span class=\"hljs-keyword\">DESC</span></code></pre>\n<p>Now tests should pass.</p>\n<h2 id=\"coverage\">Coverage</h2>\n<p>Let's check how much of the code covered our tests:</p>\n<pre><code class=\"hljs language-bash\">$ go <span class=\"hljs-built_in\">test</span> -cover ./...\n?   \texample/postest\t[no <span class=\"hljs-built_in\">test</span> files]\nok  \texample/postest/api\t(cached)\tcoverage: 71.4% of statements\n?   \texample/postest/store\t[no <span class=\"hljs-built_in\">test</span> files]\n?   \texample/postest/testdb\t[no <span class=\"hljs-built_in\">test</span> files]</code></pre>\n<p>Interesting here is that we wrote tests just for the <code>api</code> package, almost 75% of it is covered, but we found a bug inside store package. So coverage report is a little bit misleading. Probably it was designed for unit tests, that do not reach outside of their package.</p>\n<p>To have better report do this:</p>\n<pre><code class=\"hljs language-bash\">go <span class=\"hljs-built_in\">test</span> -coverpkg=./... -coverprofile=profile.cov ./...</code></pre>\n<p>Parameter <code>-coverpkg</code> tells go to record also the coverage of the other packages in folder. You could also pass <code>all</code> value there, but then it will record also coverage of dependencies (web framework, standard library, etc.). Seems too much, so I prefer <code>./...</code>.</p>\n<p>This command still prints wrong report, but <code>profile.cov</code> now contains correct results. To view them, run</p>\n<pre><code class=\"hljs language-bash\">go tool cover -html=profile.cov</code></pre>\n<p>It will open a page in browser with a drop-down selector that shows coverage for each file (<code>store/store.go</code> has 85.2%), and will highlight lines that still needs to be covered.</p>\n<p>In our example not covered are mostly error handling code like</p>\n<pre><code class=\"hljs language-go\">        <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n                <span class=\"hljs-keyword\">return</span> err\n        }</code></pre>\n<p>It executes when database itself has problems (or our query has errors). Such cases probably could be better covered with mocked DB (or not covered at all).</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>So we saw that tests found a bug in SQL code itself. If we had just unit-tests that tested logic in Go code and mocked database, this bug would not have been detected.  Yes, in simple example like this query could have been tested manually. But imagine how many bugs are hiding when you build your query dynamically?</p>\n<p>I have seen assertions made about final text of SQL query, but that is very brittle way to write test-cases. You don't know if your query will work, and on every logic change you need to change most of your test-cases.</p>\n<p>Downside of writing automated tests like this are that they are waaaay slower than normal ones. Like you could go make a tea while they run, especially when you create multiple test databases. But still faster than manual, once you wrote them.</p>\n<p>So such integration testing stands in the middle between manual and unit tests. It's slower than unit-tests, but faster than humans. It potentially finds more bugs than unit-testing. But as any other kind of testing proves only that bugs exist, not that there are no bugs at all.</p>"},"__N_SSG":true}