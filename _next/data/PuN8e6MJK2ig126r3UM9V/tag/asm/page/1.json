{"pageProps":{"pageNumber":"1","posts":[{"id":"bare_metal_fizz_buzz","title":"Bare metal \"Fizz Buzz\"","date":"2021-10-31","tags":["notes","asm"],"excerpt":"<p>Being able to write <a href=\"http://bunyk.github.io/posts/bare_metal_hello_world\">hello world</a> would not get you a job. To be able to get a job, you need to at least be able to write program called \"<a href=\"https://en.wikipedia.org/wiki/Fizz_buzz#Programming\">fizz buzz</a>\". Yes, really, on one interview I was asked to write such program.</p>\n<p>It's hard to design such a program without subroutines to print different strings and numbers, so we would need to learn how to add subroutines to assembler.</p>","content":"<p>Being able to write <a href=\"http://bunyk.github.io/posts/bare_metal_hello_world\">hello world</a> would not get you a job. To be able to get a job, you need to at least be able to write program called \"<a href=\"https://en.wikipedia.org/wiki/Fizz_buzz#Programming\">fizz buzz</a>\". Yes, really, on one interview I was asked to write such program.</p>\n<p>It's hard to design such a program without subroutines to print different strings and numbers, so we would need to learn how to add subroutines to assembler.</p>\n<h2>New way to jump around</h2>\n<p>To have subroutines we need just two instructions, <code>call</code>, and <code>ret</code>.</p>\n<p>Call is almost the same as <code>jmp</code>, but in addition it writes the address of next instruction to the stack, so <code>ret</code> knows where to return. We could return also by using <code>jmp</code>, but if we call our subroutine from two different places, <code>jmp</code> would not know where to jump.</p>\n<p>There is special register called <code>ip</code>, that has address of instruction currently executed, but we could not read or manipulate it directly (on <code>x86</code> processors).</p>\n<p>Additionally, it is nice behaviour for the subroutines to <code>push</code> values of the registers they will mess with to the stack, and then <code>pop</code> them before return, so code that calls subroutines, could use that registers for other computations.</p>\n<p>So, knowing all this, routine to print a string could look like this:</p>\n<pre><code class=\"hljs language-x86asm\"><span class=\"hljs-comment\">; println routine prints null-terminated string to which bx points</span>\n<span class=\"hljs-symbol\">println:</span>\n\t<span class=\"hljs-keyword\">push</span> <span class=\"hljs-built_in\">ax</span> <span class=\"hljs-comment\">; save ax, and bx, since their values will be changed</span>\n\t<span class=\"hljs-keyword\">push</span> <span class=\"hljs-built_in\">bx</span>\n\n\t<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-number\">ah</span>, <span class=\"hljs-number\">0x0e</span><span class=\"hljs-comment\">; teletype mode</span>\n<span class=\"hljs-symbol\">\n\tprint_loop:</span> \n\t\t<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">al</span>, [<span class=\"hljs-built_in\">bx</span>] <span class=\"hljs-comment\">; prepare to print character to which bx points now</span>\n\n\t\t<span class=\"hljs-keyword\">cmp</span> <span class=\"hljs-built_in\">al</span>, <span class=\"hljs-number\">0</span>    <span class=\"hljs-comment\">; is it 0?</span>\n\t\t<span class=\"hljs-keyword\">je</span> finish_print    <span class=\"hljs-comment\">; if yes - jump to finish_print</span>\n\n\t\t<span class=\"hljs-keyword\">int</span> <span class=\"hljs-number\">0x10</span> \t <span class=\"hljs-comment\">; print current character</span>\n\n\t\t<span class=\"hljs-keyword\">inc</span> <span class=\"hljs-built_in\">bx</span> \t\t <span class=\"hljs-comment\">; go to next byte</span>\n\t<span class=\"hljs-keyword\">jmp</span> print_loop\n<span class=\"hljs-symbol\">\n\tfinish_print:</span>\n\t<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">al</span>, <span class=\"hljs-number\">13</span> <span class=\"hljs-comment\">; print \\r, moves to beginning of line</span>\n\t<span class=\"hljs-keyword\">int</span> <span class=\"hljs-number\">0x10</span>\n\t<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">al</span>, <span class=\"hljs-number\">10</span> <span class=\"hljs-comment\">; print \\n, moves to new line</span>\n\t<span class=\"hljs-keyword\">int</span> <span class=\"hljs-number\">0x10</span>\n\n\t<span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">bx</span> <span class=\"hljs-comment\">; restore values of registers</span>\n\t<span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">ax</span>\n<span class=\"hljs-keyword\">ret</span> <span class=\"hljs-comment\">; return to caller</span></code></pre>\n<p>Having this subroutine, to print two different lines, we just write this code:</p>\n<pre><code class=\"hljs language-x86asm\"><span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">bx</span>, msg <span class=\"hljs-comment\">; put address of message to bx</span>\n<span class=\"hljs-keyword\">call</span> println <span class=\"hljs-comment\">; print what bx points to</span>\n\n<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">bx</span>, msg2  <span class=\"hljs-comment\">; print msg2</span>\n<span class=\"hljs-keyword\">call</span> println\n\n<span class=\"hljs-keyword\">jmp</span> $ <span class=\"hljs-comment\">; loop forever</span>\n<span class=\"hljs-symbol\">\nmsg:</span> \n<span class=\"hljs-built_in\">db</span> <span class=\"hljs-string\">\"Fizz\"</span>,<span class=\"hljs-number\">0</span>\n<span class=\"hljs-symbol\">\nmsg2:</span> \n<span class=\"hljs-built_in\">db</span> <span class=\"hljs-string\">\"Buzz!\"</span>,<span class=\"hljs-number\">0</span></code></pre>\n<h2>Arithmetic's</h2>\n<p>To print number, we need to know it's digits, and to know it's digits, we need to be able to divide and find a remainder of division.</p>\n<p>That is tricky to do in assembly, since <code>div</code> instruction has no parameters like <code>div z, x, y ; same as z = x/y</code> that I imagined.</p>\n<p>Turns out it has single argument, and that argument could not be a constant, it should be register, or address of memory. And size of that argument defines how <code>div</code> would behave. For 16 bit register, div will divide <code>dx:ax</code> by that register, and after this <code>ax</code> will store the result of division, <code>dx</code> will store the remainder.</p>\n<p>So, if we want to check if some 16 bit integer is divisible by 3, we need to do this:</p>\n<ol>\n<li>Put it into <code>ax</code></li>\n<li>Put 0 into <code>dx</code>, to make sure value from there does not influence result.</li>\n<li>Put 3 into <code>bx</code> (or <code>cx</code>)</li>\n<li>Finally, call <code>div bx</code> (or <code>div cx</code>)</li>\n<li>Now check if value in <code>dx</code> is 0, and jump depending on that.</li>\n</ol>\n<p>Using this, section of code that prints string addressed by label <code>fizzbuzz</code>, if <code>ax</code> is divisible by 15 looks like this:</p>\n<pre><code class=\"hljs language-x86asm\">\t<span class=\"hljs-keyword\">push</span> <span class=\"hljs-built_in\">ax</span> <span class=\"hljs-comment\">; store ax, because it will be modified</span>\n\n\t<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">dx</span>, <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\">; div, divides dx:ax number by it's argument, but we want only ax</span>\n\t<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">bx</span>, <span class=\"hljs-number\">15</span> <span class=\"hljs-comment\">; div is not able to work with constants, so use bx to store 15</span>\n\t<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">bx</span>     <span class=\"hljs-comment\">; divide dx:ax by bx. After this ax = ax / bx; dx = ax % bx;</span>\n\n\t<span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">ax</span><span class=\"hljs-comment\">; restore ax</span>\n\n\t<span class=\"hljs-keyword\">cmp</span> <span class=\"hljs-built_in\">dx</span>, <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\">; was it divisible by 15 ? </span>\n\t<span class=\"hljs-keyword\">jne</span> check_fizz <span class=\"hljs-comment\">; if not - try with 5</span>\n\n\t<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">bx</span>, fizzbuzz <span class=\"hljs-comment\">; if yes - print fizzbuzz</span>\n\t<span class=\"hljs-keyword\">call</span> println</code></pre>\n<p>While programming in assembly, I feel like I need more registers, and a way to give them better names than just two letters. I miss variables.</p>\n<p>Maybe people who actually know assembly know how to use memory addresses as variables, I'm instead trying to stick to this 4 general purpose registers.</p>\n<h2>Printing decimals</h2>\n<p>Ok, now we are able to print any string by it's address, and we are able to do division. The only thing left is to print decimal numbers.</p>\n<p>For that - we just loop over all the digits, and print each. The only hard thing is that it is hard to know with which digit the number starts. It is easier to know with which digit it ends, because it's the remainder of division by 10. The digit that ends our number divided by 10 - is the second digit, etc... We could divide by 10 in each iteration, and get digits in reverse.</p>\n<p>But we could push all of them to the stack, and then just pop and print, that would print them in normal order.</p>\n<p>My decimal number printing code looks like this:</p>\n<pre><code class=\"hljs language-x86asm\"><span class=\"hljs-comment\">; print_decimal routine prints number stored in ax</span>\n<span class=\"hljs-symbol\">print_decimal:</span>\n\t<span class=\"hljs-keyword\">push</span> <span class=\"hljs-built_in\">ax</span> <span class=\"hljs-comment\">; store values of registers that will change</span>\n\t<span class=\"hljs-keyword\">push</span> <span class=\"hljs-built_in\">bx</span>\n\t<span class=\"hljs-keyword\">push</span> <span class=\"hljs-built_in\">cx</span>\n\t<span class=\"hljs-keyword\">push</span> <span class=\"hljs-built_in\">dx</span>\n\n\t<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">cx</span>, <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">; cx will hold number of digits, initially 0</span>\n\n\t<span class=\"hljs-keyword\">cmp</span> <span class=\"hljs-built_in\">ax</span>, <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">; is number we want to print 0? </span>\n\t<span class=\"hljs-keyword\">jne</span> push_last_digit <span class=\"hljs-comment\">; if not - proceed to pushing last digit of it</span>\n\t<span class=\"hljs-keyword\">push</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">; digit is 0</span>\n\t<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">cx</span>, <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">; number of digits in stack is 1</span>\n\t<span class=\"hljs-keyword\">jmp</span> print_from_stack <span class=\"hljs-comment\">; and print this</span>\n<span class=\"hljs-symbol\">\n\tpush_last_digit:</span>\n\t\t<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">dx</span>, <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\">; div, divides dx:ax number by it's argument, but we want only ax</span>\n\t\t<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">bx</span>, <span class=\"hljs-number\">10</span> <span class=\"hljs-comment\">; div is not able to work with constants, so use bx to store 10</span>\n\t\t<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">bx</span>     <span class=\"hljs-comment\">; divide dx:ax by bx. After this ax = ax / bx; dx = ax % bx;</span>\n\n\t\t<span class=\"hljs-keyword\">push</span> <span class=\"hljs-built_in\">dx</span>   <span class=\"hljs-comment\">; dx is last digit, put it in stack</span>\n\t\t<span class=\"hljs-keyword\">inc</span> <span class=\"hljs-built_in\">cx</span>    <span class=\"hljs-comment\">; we have one more digit to print</span>\n\n\t<span class=\"hljs-keyword\">cmp</span> <span class=\"hljs-built_in\">ax</span>, <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">; do we still have numbers?</span>\n\t<span class=\"hljs-keyword\">jne</span> push_last_digit <span class=\"hljs-comment\">; if yes - push that again</span>\n<span class=\"hljs-symbol\">\n\tprint_from_stack:</span>\n\t\t<span class=\"hljs-keyword\">cmp</span> <span class=\"hljs-built_in\">cx</span>, <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">; are there numbers to print?</span>\n\t\t<span class=\"hljs-keyword\">je</span> exit_print_decimal<span class=\"hljs-comment\">; if no - finish subroutine</span>\n\n\t\t<span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">bx</span>  <span class=\"hljs-comment\">; put number to print into bx</span>\n\t\t<span class=\"hljs-keyword\">add</span> <span class=\"hljs-built_in\">bx</span>, <span class=\"hljs-string\">'0'</span> <span class=\"hljs-comment\">; add to bx ASCII code of 0</span>\n\t\t<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">al</span>, <span class=\"hljs-built_in\">bl</span>  <span class=\"hljs-comment\">; put that code to AL</span>\n\n\t\t<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-number\">ah</span>, <span class=\"hljs-number\">0x0e</span><span class=\"hljs-comment\">; teletype mode</span>\n\t\t<span class=\"hljs-keyword\">int</span> <span class=\"hljs-number\">0x10</span> \t <span class=\"hljs-comment\">; print current digit</span>\n\n\t\t<span class=\"hljs-keyword\">dec</span> <span class=\"hljs-built_in\">cx</span> <span class=\"hljs-comment\">; and now we have one less digit to print</span>\n\t<span class=\"hljs-keyword\">jmp</span> print_from_stack\n<span class=\"hljs-symbol\">\n\texit_print_decimal:</span>\n\n\t<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">al</span>, <span class=\"hljs-number\">13</span> <span class=\"hljs-comment\">; print \\r, moves to beginning of line</span>\n\t<span class=\"hljs-keyword\">int</span> <span class=\"hljs-number\">0x10</span>\n\t<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">al</span>, <span class=\"hljs-number\">10</span> <span class=\"hljs-comment\">; print \\n, moves to new line</span>\n\t<span class=\"hljs-keyword\">int</span> <span class=\"hljs-number\">0x10</span>\n\n\t<span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">dx</span> <span class=\"hljs-comment\">; restore registers</span>\n\t<span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">cx</span> \n\t<span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">bx</span> \n\t<span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">ax</span>\n<span class=\"hljs-keyword\">ret</span></code></pre>\n<h2>Slowing down</h2>\n<p>And our FizzBuzz runs so fast that it's impossible to read anything, I found out how to ask BIOS to wait for some time:</p>\n<pre><code class=\"hljs language-x86asm\"><span class=\"hljs-comment\">; sleep about cx/15 seconds</span>\n<span class=\"hljs-comment\">; CX:DX = interval in microseconds, if we don't set dx - one cx is ~65536A microseconds, or 1/15 of second</span>\n<span class=\"hljs-symbol\">sleep:</span>\n\t<span class=\"hljs-keyword\">push</span> <span class=\"hljs-built_in\">ax</span>\n\n\t<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">al</span>, <span class=\"hljs-number\">0</span>\n\t<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-number\">ah</span>, <span class=\"hljs-number\">0x86</span>\n\t<span class=\"hljs-keyword\">int</span> <span class=\"hljs-number\">0x15</span>\n\n\t<span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">ax</span>\n<span class=\"hljs-keyword\">ret</span></code></pre>\n<h2>Main FizzBuzz loop</h2>\n<p>Having all that subroutines in place, FizzBuzz looks like this:</p>\n<pre><code class=\"hljs language-x86asm\"><span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">ax</span>, <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">; loop counter</span>\n<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">cx</span>, <span class=\"hljs-number\">5</span> <span class=\"hljs-comment\">; how long to sleep in 1/15th of second</span>\n<span class=\"hljs-symbol\">\nloop:</span>\n\t<span class=\"hljs-keyword\">inc</span> <span class=\"hljs-built_in\">ax</span>\n\t<span class=\"hljs-keyword\">call</span> sleep\n\n\t<span class=\"hljs-keyword\">push</span> <span class=\"hljs-built_in\">ax</span> <span class=\"hljs-comment\">; store ax, because it will be modified</span>\n\n\t<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">dx</span>, <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\">; div, divides dx:ax number by it's argument, but we want only ax</span>\n\t<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">bx</span>, <span class=\"hljs-number\">15</span> <span class=\"hljs-comment\">; div is not able to work with constants, so use bx to store 15</span>\n\t<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">bx</span>     <span class=\"hljs-comment\">; divide dx:ax by bx. After this ax = ax / bx; dx = ax % bx;</span>\n\n\t<span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">ax</span><span class=\"hljs-comment\">; restore ax</span>\n\n\t<span class=\"hljs-keyword\">cmp</span> <span class=\"hljs-built_in\">dx</span>, <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\">; was it divisible by 15 ? </span>\n\t<span class=\"hljs-keyword\">jne</span> check_fizz <span class=\"hljs-comment\">; if not - try with 5</span>\n\n\t<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">bx</span>, fizzbuzz <span class=\"hljs-comment\">; if yes - print fizzbuzz</span>\n\t<span class=\"hljs-keyword\">call</span> println\n\t<span class=\"hljs-keyword\">jmp</span> <span class=\"hljs-keyword\">loop</span> <span class=\"hljs-comment\">; continue with next iteration</span>\n<span class=\"hljs-symbol\">\n\tcheck_fizz:</span>\n\t<span class=\"hljs-keyword\">push</span> <span class=\"hljs-built_in\">ax</span>\n\n\t<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">dx</span>, <span class=\"hljs-number\">0</span>\n\t<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">bx</span>, <span class=\"hljs-number\">5</span>\n\t<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">bx</span>\n\n\t<span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">ax</span>\n\n\t<span class=\"hljs-keyword\">cmp</span> <span class=\"hljs-built_in\">dx</span>, <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\">; was it divisible by 5 ? </span>\n\t<span class=\"hljs-keyword\">jne</span> check_buzz <span class=\"hljs-comment\">; if not - try with 3</span>\n\n\t<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">bx</span>, fizz <span class=\"hljs-comment\">; if yes - print fizz</span>\n\t<span class=\"hljs-keyword\">call</span> println\n\n\t<span class=\"hljs-keyword\">jmp</span> <span class=\"hljs-keyword\">loop</span> <span class=\"hljs-comment\">; and move to next number</span>\n<span class=\"hljs-symbol\">\n\tcheck_buzz:</span>\n\t<span class=\"hljs-keyword\">push</span> <span class=\"hljs-built_in\">ax</span>\n\n\t<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">dx</span>, <span class=\"hljs-number\">0</span>\n\t<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">bx</span>, <span class=\"hljs-number\">3</span>\n\t<span class=\"hljs-keyword\">div</span> <span class=\"hljs-built_in\">bx</span>\n\n\t<span class=\"hljs-keyword\">pop</span> <span class=\"hljs-built_in\">ax</span>\n\n\t<span class=\"hljs-keyword\">cmp</span> <span class=\"hljs-built_in\">dx</span>, <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\">; was it divisible by 3 ? </span>\n\t<span class=\"hljs-keyword\">jne</span> integer <span class=\"hljs-comment\">; not - proceed to printing</span>\n\n\t<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">bx</span>, buzz <span class=\"hljs-comment\">; if yes - print fizz</span>\n\t<span class=\"hljs-keyword\">call</span> println\n\n\t<span class=\"hljs-keyword\">jmp</span> <span class=\"hljs-keyword\">loop</span>\n<span class=\"hljs-symbol\">\n\tinteger:</span>\n\t<span class=\"hljs-keyword\">call</span> print_decimal\n<span class=\"hljs-keyword\">jmp</span> <span class=\"hljs-keyword\">loop</span></code></pre>\n<p>Overall code with all the subroutines, constants, and comments takes me 172 lines. A lot for a FizzBuzz, but in Python you would not write two \"print\" functions for two data types from scratch.</p>\n<p>If I remove padding with zeroes, it no longer runs, but binary has just a little over 200 bytes. So, even with my poor assembly skills FizzBuzz could fit into 512 bytes bootsector twice.</p>"},{"id":"bare_metal_hello_world","title":"Bare metal \"Hello, world!\"","date":"2021-10-23","toc":true,"tags":["notes","asm"],"excerpt":"<p>From time to time I get an itch to write. I mean code. Everything: video games, search engines, operating systems. Many of my old friends <a href=\"https://danbst.wordpress.com/2009/12/26/helloworld_os_boot_sector/\">wrote their own OSes</a> (or at least bare-metal code), and I have FOMO.</p>\n<p>Recently I bought eBook reader with bigger screen than my Kindle. So I went on treasure hunt over internet to fill it with all the awesome free books that I wanted to read, but was not reading, because they did not fit to that tiny Kindle screen. And I found some unfinished free book: <a href=\"https://www.cs.bham.ac.uk/~exr/lectures/opsys/10_11/lectures/os-dev.pdf\">\"Writing a Simple Operating System - from Scratch\" by Nick Blundel (2010)</a>. It retriggered that itch to write OS, or at least code that runs without OS again.</p>\n<p>Here I'll post notes of my journey, skipping boring parts like explaining benefits of hexadecimal notation.</p>","content":"<p>From time to time I get an itch to write. I mean code. Everything: video games, search engines, operating systems. Many of my old friends <a href=\"https://danbst.wordpress.com/2009/12/26/helloworld_os_boot_sector/\">wrote their own OSes</a> (or at least bare-metal code), and I have FOMO.</p>\n<p>Recently I bought eBook reader with bigger screen than my Kindle. So I went on treasure hunt over internet to fill it with all the awesome free books that I wanted to read, but was not reading, because they did not fit to that tiny Kindle screen. And I found some unfinished free book: <a href=\"https://www.cs.bham.ac.uk/~exr/lectures/opsys/10_11/lectures/os-dev.pdf\">\"Writing a Simple Operating System - from Scratch\" by Nick Blundel (2010)</a>. It retriggered that itch to write OS, or at least code that runs without OS again.</p>\n<p>Here I'll post notes of my journey, skipping boring parts like explaining benefits of hexadecimal notation.</p>\n<h2>Installing tools</h2>\n<p>First things that we need are assembler and VM to run code produced by that assembler, because I would not risk running code written by me on bare metal, and risk formatting my disk.</p>\n<p>Book uses Netwide Assembler (NASM) and QEMU as VM. To install them with <code>apt</code>, run:</p>\n<pre><code class=\"hljs language-bash\">sudo apt-get install qemu-system-x86 nasm</code></pre>\n<p>Or select installation variant for your system:</p>\n<ul>\n<li><a href=\"https://www.qemu.org/download/\">QEMU</a></li>\n<li><a href=\"https://www.nasm.us/\">NASM</a></li>\n</ul>\n<p>Book also has alternative to use Bochs emulator, but I prefer Qemu, because it does not require config file to run</p>\n<p>To view a binary file, which is sometimes useful, you could use:</p>\n<pre><code class=\"hljs language-bash\">od -t x1 -A n boot_sect.bin</code></pre>\n<p><code>od</code> stands for \"octal dump\" (but could dump other formats), <code>-t x1</code> stands for \"type (<code>-t</code>) hexadecimal (<code>x</code>), 1 byte per number\", and <code>-A n</code> stands for \"addresses no\" (don't print byte offsets).</p>\n<h2>Not yet hello world</h2>\n<p>So, every tutorial starts from printing hello world to the screen, but this one will finish with it.</p>\n<p>Instead, we start from code that just runs, and does nothing else, at all:</p>\n<pre><code class=\"hljs language-x86asm\"><span class=\"hljs-comment\">; infinite loop bootsector</span>\n<span class=\"hljs-symbol\">\nloop:</span>                 <span class=\"hljs-comment\">; define a label (address in code)</span>\n\t<span class=\"hljs-keyword\">jmp</span> <span class=\"hljs-keyword\">loop</span>          <span class=\"hljs-comment\">; go execute code starting from instruction at label</span>\n\n<span class=\"hljs-built_in\">times</span> <span class=\"hljs-number\">510</span>-($-$$) <span class=\"hljs-built_in\">db</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">; pad with zeroes, so whole sector is 512 bytes</span>\n\n<span class=\"hljs-built_in\">dw</span> <span class=\"hljs-number\">0xaa55</span> <span class=\"hljs-comment\">; last two bytes are magic number to mark this as boot sector</span></code></pre>\n<p>Assembler is full of abbreviations:</p>\n<ul>\n<li><code>jmp</code> stands for jump. It is instruction for CPU to do something.</li>\n<li><code>db</code> probably stands for \"define byte\". This is pseudo-instruction of NASM, that says to just put something into particular address in memory.</li>\n<li><code>dw</code> probably stands for \"define word\" (two bytes)</li>\n</ul>\n<p>Interesting, how, unlike in high-level languages, assembler code translates 1 to 1 to bytes that will be loaded to computer memory. Where data, like magic numbers are mixed with instructions.</p>\n<p>To compile:</p>\n<pre><code class=\"hljs language-bash\">nasm boot_sect.asm -f bin -o boot_sect.bin</code></pre>\n<p>To run:</p>\n<pre><code class=\"hljs language-bash\">qemu-system-x86_64 boot_sect.bin</code></pre>\n<h2>Registers</h2>\n<p>When we program CPU, instead of using variables, we use <em>registers</em> to store our data. Each x86 CPU has 4 general purpose registers: <code>ax</code> , <code>bx</code>, <code>cx</code>, <code>dx</code>, able to store <em>word</em>, or 16 bits of data. They are way faster to read or write than memory. Also, each byte of register could be referenced separately, as <code>ah</code> (high) and <code>al</code> (low).</p>\n<p>Instruction <code>mov</code> moves data from and to register:</p>\n<ul>\n<li><code>mov ax, 123</code> - set value of <code>ax</code> to decimal <code>123</code></li>\n<li><code>mov ax, 0xabcd</code> - set value of <code>ax</code> to hexadecimal <code>abcd</code></li>\n<li><code>mov ax, 'a'</code> - set value of <code>ax</code> to ASCII code of <code>'a'</code></li>\n<li><code>mov bx, ax</code>  - copy value of <code>ax</code>   to <code>bx</code> (equivalent of <code>bx = ax;</code> in higher-level languages)</li>\n</ul>\n<h2>Interrupts</h2>\n<p><em>Interrupts</em> are like a callbacks of CPU. They allow it to interrupt what it currently runs, and run some other code to handle interrupt, before continuing with current task. They are raised by software instruction (for example <code>int 0x10</code>) , or by some device requiring action (input some data, etc..)</p>\n<p>Each interrupt has a number, that is used as index to table set-up by BIOS at the start of memory (address <code>0x0</code>), that contains pointers to <em>interrupt service routines (ISRs)</em></p>\n<p>Since BIOS has a log of ISRs, they are they are entry points to a set of handlers, indexed with <code>ax</code> register. <code>int 0x10</code> calls a screen-related ISR defined by <code>ax</code>, and <code>int 0x13</code> - disk related IO. They both have inside something like <code>switch</code> statement, that branches depending by <code>ax</code> value.</p>\n<h2>Hell!</h2>\n<p>To print a character on the screen, we need to set <code>ah</code> to <code>0xe</code> (teletype mode screen), <code>al</code> to ascii code of character to print, and call <code>int 0x10</code>. We could set <code>ah</code> once per al characters, and then just change <code>al</code>.</p>\n<p>And this is how to write bootsector that prints \"Hell!\" on the screen using BIOS interrupt:</p>\n<pre><code class=\"hljs language-x86asm\"><span class=\"hljs-keyword\">mov</span> <span class=\"hljs-number\">ah</span>, <span class=\"hljs-number\">0x0e</span> \t<span class=\"hljs-comment\">; teletype mode for BIOS interrupt </span>\n\n<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">al</span>, <span class=\"hljs-string\">'H'</span> \t<span class=\"hljs-comment\">; char to print</span>\n<span class=\"hljs-keyword\">int</span> <span class=\"hljs-number\">0x10</span> \t\t<span class=\"hljs-comment\">; call interrupt to print char</span>\n<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">al</span>, <span class=\"hljs-string\">'e'</span> \n<span class=\"hljs-keyword\">int</span> <span class=\"hljs-number\">0x10</span> \n<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">al</span>, <span class=\"hljs-string\">'l'</span>\n<span class=\"hljs-keyword\">int</span> <span class=\"hljs-number\">0x10</span>\n<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">al</span>, <span class=\"hljs-string\">'l'</span>\n<span class=\"hljs-keyword\">int</span> <span class=\"hljs-number\">0x10</span>\n<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">al</span>, <span class=\"hljs-string\">'!'</span>\n\n<span class=\"hljs-keyword\">jmp</span> $\n\n<span class=\"hljs-built_in\">times</span> <span class=\"hljs-number\">510</span>-($-$$) <span class=\"hljs-built_in\">db</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">; pad with zeroes</span>\n\n<span class=\"hljs-built_in\">dw</span> <span class=\"hljs-number\">0xaa55</span> <span class=\"hljs-comment\">; magic number to mark this as boot sector</span></code></pre>\n<p>It prints \"Hell!\" because \"Hello, world!\" would be too much work. Until we implement strings.</p>\n<p>Or, one cool trick. Since we are so low level, we could look at binary produced, and figure out that  code</p>\n<pre><code class=\"hljs language-x86asm\"><span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">al</span>, <span class=\"hljs-string\">'H'</span>\n<span class=\"hljs-keyword\">int</span> <span class=\"hljs-number\">0x10</span></code></pre>\n<p>is compiled to <code>b0 48 cd 10</code>, where 48 is ASCII code of <code>'H'</code>. So we could write code to print \"Hell\", like this:</p>\n<pre><code class=\"hljs language-x86asm\"><span class=\"hljs-built_in\">db</span> <span class=\"hljs-number\">0xb0</span>,<span class=\"hljs-string\">'H'</span>,<span class=\"hljs-number\">0xcd</span>,<span class=\"hljs-number\">0x10</span>\n<span class=\"hljs-built_in\">db</span> <span class=\"hljs-number\">0xb0</span>,<span class=\"hljs-string\">'e'</span>,<span class=\"hljs-number\">0xcd</span>,<span class=\"hljs-number\">0x10</span>\n<span class=\"hljs-built_in\">db</span> <span class=\"hljs-number\">0xb0</span>,<span class=\"hljs-string\">'l'</span>,<span class=\"hljs-number\">0xcd</span>,<span class=\"hljs-number\">0x10</span>\n<span class=\"hljs-built_in\">db</span> <span class=\"hljs-number\">0xb0</span>,<span class=\"hljs-string\">'l'</span>,<span class=\"hljs-number\">0xcd</span>,<span class=\"hljs-number\">0x10</span></code></pre>\n<p>Lower than that would be just rewiring cables on plugboard.</p>\n<h2>Memory</h2>\n<p><code>label:</code> could be seen as constant that stores index of byte in memory from which instruction (or bytes defined by <code>db</code>) after it starts.</p>\n<p>The problem is, BIOS loads code of boot sector to address <code>0x7c00</code>, because beginning of memory is already taken by ISRs, if you remember. To offset our addresses, we could tell assembler that our program will be located there by using directive <code>[org 0x7c00]</code>.  We could also do pointer arithmetic manually, be we will do it for more interesting things, which is to print \"Hello, world!\".</p>\n<p>So we could put bunch of bytes somewhere after our code using <code>db \"Hello world!\"</code>, mark their address using <code>msg:</code>, and then use <code>msg</code> to set value of <code>ah</code>.</p>\n<p>Just if we will use <code>mv al, msg</code>, it will put into <code>al</code> address marked by <code>msg</code>, and later print ASCII value of it. If we want to do pointer dereferencing, we use square brackets <code>mv al, [msg]</code>. NASM also could do pointer arithmetic for you. This, for example, prints \"Hel\":</p>\n<pre><code class=\"hljs language-x86asm\">[org <span class=\"hljs-number\">0x7c00</span>] <span class=\"hljs-comment\">; Memory offset of boot sector</span>\n\n<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-number\">ah</span>, <span class=\"hljs-number\">0x0e</span><span class=\"hljs-comment\">; teletype mode</span>\n\n<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">al</span>, [msg] <span class=\"hljs-comment\">; put value from memory address msg to al</span>\n<span class=\"hljs-keyword\">int</span> <span class=\"hljs-number\">0x10</span> \t\n<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">al</span>, [msg+<span class=\"hljs-number\">1</span>] <span class=\"hljs-comment\">; put value from memory address msg+1 to al</span>\n<span class=\"hljs-keyword\">int</span> <span class=\"hljs-number\">0x10</span> \t\n<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">al</span>, [msg+<span class=\"hljs-number\">2</span>]\n<span class=\"hljs-keyword\">int</span> <span class=\"hljs-number\">0x10</span> \t\n\n<span class=\"hljs-keyword\">jmp</span> $ <span class=\"hljs-comment\">; loop forever</span>\n<span class=\"hljs-symbol\">\nmsg:</span> \n<span class=\"hljs-built_in\">db</span> <span class=\"hljs-string\">\"Hello world!\"</span>\n\n<span class=\"hljs-built_in\">times</span> <span class=\"hljs-number\">510</span>-($-$$) <span class=\"hljs-built_in\">db</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">; pad with zeroes</span>\n<span class=\"hljs-built_in\">dw</span> <span class=\"hljs-number\">0xaa55</span> <span class=\"hljs-comment\">; magic number to mark this as boot sector</span></code></pre>\n<h2>Control structures</h2>\n<p>In language C, string is sequence of bytes that ends with byte 0. If we create our string like this, we could write code that loops over addresses starting from beginning of string, and stops when reaches zero character.</p>\n<p>We already know how to do infinite loops:</p>\n<pre><code class=\"hljs language-x86asm\"><span class=\"hljs-symbol\">loop:</span>\n<span class=\"hljs-keyword\">jmp</span> <span class=\"hljs-keyword\">loop</span>\n\n<span class=\"hljs-comment\">; or shorter equivalent:</span>\n\n<span class=\"hljs-keyword\">jmp</span> $</code></pre>\n<p>To program loops that end, we need conditional jumps, and comparison instruction.</p>\n<p><code>cmp x, y</code>, compares <code>x</code> with <code>y</code>, and sets result into special <code>flags</code> register. Now, there are instruction that jump depending on the comparison result stored in that register:</p>\n<ul>\n<li><code>je</code> - jump if equal</li>\n<li><code>jne</code> - if not equal</li>\n<li><code>jl</code> - less than</li>\n<li><code>jle</code> - less than or equal</li>\n<li><code>jg</code> - greater</li>\n<li><code>jge</code> - greater or equal</li>\n</ul>\n<p>And we need a little bit of arithmetic:</p>\n<ul>\n<li><code>inc ax</code> - increments <code>ax</code> (`ax++``)</li>\n<li><code>add ax, 2</code> - adds 2 (or any other value you wish) to <code>ax</code> (<code>ax+=2</code>)</li>\n</ul>\n<h2>Hello world, finally</h2>\n<p>Putting it all together:</p>\n<pre><code class=\"hljs language-x86asm\">[org <span class=\"hljs-number\">0x7c00</span>] <span class=\"hljs-comment\">; Memory offset of boot sector</span>\n\n<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-number\">ah</span>, <span class=\"hljs-number\">0x0e</span><span class=\"hljs-comment\">; teletype mode</span>\n\n<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">bx</span>, msg <span class=\"hljs-comment\">; put address of message to bx</span>\n<span class=\"hljs-symbol\">\nloop:</span>\n\t<span class=\"hljs-keyword\">mov</span> <span class=\"hljs-built_in\">al</span>, [<span class=\"hljs-built_in\">bx</span>] <span class=\"hljs-comment\">; prepare to print character to which bx points now</span>\n\n\t<span class=\"hljs-keyword\">cmp</span> <span class=\"hljs-built_in\">al</span>, <span class=\"hljs-number\">0</span>    <span class=\"hljs-comment\">; is it 0?</span>\n\t<span class=\"hljs-keyword\">je</span> finish    <span class=\"hljs-comment\">; if yes - jump to finish</span>\n\n\t<span class=\"hljs-keyword\">int</span> <span class=\"hljs-number\">0x10</span> \t <span class=\"hljs-comment\">; print current character</span>\n\n\t<span class=\"hljs-keyword\">inc</span> <span class=\"hljs-built_in\">bx</span> \t\t <span class=\"hljs-comment\">; go to next byte</span>\n<span class=\"hljs-keyword\">jmp</span> <span class=\"hljs-keyword\">loop</span>\n<span class=\"hljs-symbol\">\nfinish:</span>\n<span class=\"hljs-keyword\">jmp</span> $ <span class=\"hljs-comment\">; loop forever</span>\n<span class=\"hljs-symbol\">\nmsg:</span> \n<span class=\"hljs-built_in\">db</span> <span class=\"hljs-string\">\"Hello, world!\"</span>,<span class=\"hljs-number\">0</span>\n\n<span class=\"hljs-built_in\">times</span> <span class=\"hljs-number\">510</span>-($-$$) <span class=\"hljs-built_in\">db</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">; pad with zeroes</span>\n\n<span class=\"hljs-built_in\">dw</span> <span class=\"hljs-number\">0xaa55</span> <span class=\"hljs-comment\">; magic number to mark this as boot sector</span></code></pre>\n<p>If you forget to jump to finish, and make infinite loop, you could print content of whole memory. Which of course will be trash once you went over \"Hello, world!\", all the zeroes and magic number.</p>\n<p>Next level from here, would probably be to try to fit \"fizz buzz\" into boot sector, or load more sectors.</p>"}],"pages":1,"archives":[{"url":"/month/2021-10/page/1","id":"2021-10","count":2,"title":"2021-10"},{"url":"/month/2021-01/page/1","id":"2021-01","count":4,"title":"2021-01"},{"url":"/month/2020-12/page/1","id":"2020-12","count":1,"title":"2020-12"},{"url":"/month/2020-09/page/1","id":"2020-09","count":2,"title":"2020-09"},{"url":"/month/2020-08/page/1","id":"2020-08","count":2,"title":"2020-08"},{"url":"/month/2020-07/page/1","id":"2020-07","count":10,"title":"2020-07"},{"url":"/month/2020-06/page/1","id":"2020-06","count":7,"title":"2020-06"},{"url":"/month/2018-12/page/1","id":"2018-12","count":1,"title":"2018-12"}],"topics":[{"url":"/tag/MOOC/page/1","id":"MOOC","title":"MOOC","count":2},{"url":"/tag/SICP/page/1","id":"SICP","title":"SICP","count":20},{"url":"/tag/asm/page/1","id":"asm","title":"asm","count":2},{"url":"/tag/ideas/page/1","id":"ideas","title":"ideas","count":1},{"url":"/tag/notes/page/1","id":"notes","title":"notes","count":7},{"url":"/tag/on writing/page/1","id":"on writing","title":"on writing","count":3}],"tag":"asm"},"__N_SSG":true}