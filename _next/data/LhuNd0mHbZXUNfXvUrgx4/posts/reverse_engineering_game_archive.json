{"pageProps":{"id":"reverse_engineering_game_archive","title":"Reverse engineering game archive of London Racer: World Challenge","date":"2022-02-12T18:45:07.000Z","updated_at":"2022-02-12T17:58:04+01:00","content":"<p>\"London Racer: World Challenge\" is fun old racing game. I like it because of nostalgia (I last played it around 2005). And among other places you could also race in Berlin. Game mechanics reminds me of Super Tux Cart.</p>\n<p>Wikipedia says that \"Davilex closed the game division in 2005 because it was not profitable enough, and their games were generally not well received\".  But it also says that Germans even made a movie based on a game <a href=\"https://de.wikipedia.org/wiki/Autobahnraser_(Film)\">Autobahnraser</a>, so I would say that's a great success.</p>\n<p>But unfortunately the game does not run on my computer, even with Wine.\nIt would be interesting to extract model of some Berlin streets from there. Or car models. Maybe I'll even manage to put them into Super Tux Cart, will see.</p>\n<p>You could download it from <a href=\"https://www.myabandonware.com/game/london-racer-world-challenge-e5l\">here</a>.</p>\n<p>Apart from <code>WR.exe</code>, archive with game contains files with game data: <code>WR.idx</code> and <code>WR.img</code>\nFirst one contains list of file names, and second one - their contents. Offsets are stored somewhere in idx, but format of idx file is not clear. <code>.img</code> file looks like just concatenated files of the game.</p>\n<h2 id=\"extracting-from-img-file\">Extracting from .img file</h2>\n<p>Every <code>.nif</code> file seems to start with the string \"NetImmerse File Format, Version 4.2.1.0\". We could use that to split them:</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(<span class=\"hljs-string\">'WR.img'</span>, <span class=\"hljs-string\">'rb'</span>) <span class=\"hljs-keyword\">as</span> f:\n\tdata = f.read()\n\nchunks = data.split(<span class=\"hljs-string\">b'NetImmerse'</span>)\n\nchunks = [<span class=\"hljs-string\">b'NetImmerse'</span> + c <span class=\"hljs-keyword\">for</span> c <span class=\"hljs-keyword\">in</span> chunks <span class=\"hljs-keyword\">if</span> c.startswith(<span class=\"hljs-string\">b' File Format'</span>)]\n\n<span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(<span class=\"hljs-string\">'some.nif'</span>, <span class=\"hljs-string\">'wb'</span>) <span class=\"hljs-keyword\">as</span> f:\n\tf.write(chunks[<span class=\"hljs-number\">0</span>])\n</code></pre>\n<h2 id=\"installing-blender-and-niftools-addon\">Installing Blender and NifTools Addon</h2>\n<p>NetImmerse was popular game engine, used for such games as Morrowind, Fallout and many others. And there is huge community of modders that created tools to work with <code>.nif</code> files.</p>\n<p>Here is <a href=\"https://blender-niftools-addon.readthedocs.io/en/latest/user/install.html\">the instruction to install .nif addon for Blender</a></p>\n<p>After doing what instruction says, <code>some.nif</code> will open, and show a model of wrench:</p>\n<p><img src=\"/content/wrench_model.png\" alt=\"Wrench model\"></p>\n<p>That is <code>repairsmall.nif</code> I would guess. In the game you hit that wrench to repair damage done to your car by other objects that you hit.</p>\n<h2 id=\"decoding-idx\">Decoding .idx</h2>\n<p>Some other chunks would not open with the Blender addon, and It would be interesting to know which are which, so let's try to figure out the structure of .idx</p>\n<h3 id=\"looking-for-offsets\">Looking for offsets</h3>\n<p>Offset of first <code>.nif</code> file was 0xFA4. Looking for byte with value A4 gives one at some distance after string <code>repairsmall.nif</code>. After it there is a byte 07. That means little-endian format.</p>\n<p>While I was trying to calculate distances from filename field to offset field, I found the page that describes format for another version of racing game from the same developer - <a href=\"http://wiki.xentax.com/index.php/London_Racer:_Police_Madness_IDX\">London Racer: Police Madness</a></p>\n<p>It gives some important tips. Image file is indeed just concatenated files, but index is a little bit more complex. It contains also directories. That is the correct suggestion from that page. Another correct suggestion was that size of file is stored in index twice. But unfortunately offsets and sizes of the fields do not match.</p>\n<p>I wrote some python snippets to load binary data, and do a search in it. To test hypothesis that file offset should have constant distance from file name.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> struct \n<span class=\"hljs-keyword\">import</span> string\n<span class=\"hljs-keyword\">import</span> re\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">load_file</span>(<span class=\"hljs-params\">fn</span>): \n    <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(fn, <span class=\"hljs-string\">'rb'</span>) <span class=\"hljs-keyword\">as</span> f:\n        <span class=\"hljs-keyword\">return</span> f.read()\n\n<span class=\"hljs-comment\"># Find all offsets of pattern in data</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">all_offsets</span>(<span class=\"hljs-params\">pattern, data</span>):\n    <span class=\"hljs-keyword\">return</span> [m.start() <span class=\"hljs-keyword\">for</span> m <span class=\"hljs-keyword\">in</span> re.finditer(pattern, data)]\n\nimg = load_file(<span class=\"hljs-string\">'WR.img'</span>)\nidx = load_file(<span class=\"hljs-string\">'WR.idx'</span>)\n\nnif_offsets = all_offsets(<span class=\"hljs-string\">b'NetImmerse File Format'</span>, img)\n\n<span class=\"hljs-comment\"># offsets of nif file offsets in idx.file</span>\nnif_offset_offsets = [\n    idx.find(struct.pack(<span class=\"hljs-string\">'&#x3C;i'</span>, o)) <span class=\"hljs-comment\"># search for given integer in little-endian format</span>\n    <span class=\"hljs-keyword\">for</span> o <span class=\"hljs-keyword\">in</span> nif_offsets\n]\n\n<span class=\"hljs-comment\"># offsets of ends of names of niff files - 4 bytes</span>\nnif_name_offsets = all_offsets(<span class=\"hljs-string\">b'\\.nif\\x00'</span>, idx)\n\n\n<span class=\"hljs-comment\"># Distance between the two</span>\n[b-a <span class=\"hljs-keyword\">for</span> a, b <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">zip</span>(nif_name_offsets[:<span class=\"hljs-number\">10</span>], nif_offset_offsets[:<span class=\"hljs-number\">10</span>])]\n[<span class=\"hljs-number\">17</span>, <span class=\"hljs-number\">19</span>, <span class=\"hljs-number\">18</span>, <span class=\"hljs-number\">17</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">18</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">1420</span>, <span class=\"hljs-number\">1428</span>, <span class=\"hljs-number\">1436</span>]</code></pre>\n<p>Hm, not always the same.</p>\n<h3 id=\"looking-at-the-hex\">Looking at the hex</h3>\n<p>I also tried some hex editors. Hexinator is fancy one, where you could comment and mark different bytes with different colors. But it crashed for me, so I uninstalled it. Ghex is simple one, and I don't use hex editors so often, so I kept it. But lack of color was making it hard to look at all that numbers, so I wrote short function to pretty print binary.</p>\n<pre><code class=\"hljs language-python\">nocolor = <span class=\"hljs-string\">\"\\033[0m\"</span>\nred = <span class=\"hljs-string\">\"\\033[31m\"</span>\ngreen = <span class=\"hljs-string\">\"\\033[92m\"</span>\n\nvisible_charset = <span class=\"hljs-built_in\">bytes</span>(string.digits + string.ascii_letters + string.punctuation + <span class=\"hljs-string\">' '</span>, <span class=\"hljs-string\">'ascii'</span>)\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">is_visible</span>(<span class=\"hljs-params\">b</span>):\n    <span class=\"hljs-keyword\">return</span> b <span class=\"hljs-keyword\">in</span> visible_charset\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">pprint</span>(<span class=\"hljs-params\">data, columns=<span class=\"hljs-number\">10</span>, column_width=<span class=\"hljs-number\">4</span></span>):\n    <span class=\"hljs-keyword\">for</span> i, b <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(data):\n        <span class=\"hljs-keyword\">if</span> i % (column_width * columns) == <span class=\"hljs-number\">0</span>:\n            <span class=\"hljs-built_in\">print</span>()\n        <span class=\"hljs-keyword\">if</span> i % column_width == <span class=\"hljs-number\">0</span>:\n            <span class=\"hljs-built_in\">print</span>(end=<span class=\"hljs-string\">'  '</span>)\n        \n        r = <span class=\"hljs-string\">'%02X'</span> % b\n        <span class=\"hljs-keyword\">if</span> is_visible(b):\n            r = <span class=\"hljs-string\">'%s%2s%s'</span> % (green, <span class=\"hljs-built_in\">chr</span>(b), nocolor)\n\n        <span class=\"hljs-keyword\">if</span> b == <span class=\"hljs-number\">0</span>:\n            r = <span class=\"hljs-string\">'%s 0%s'</span> % (red, nocolor)\n\n        <span class=\"hljs-built_in\">print</span>(r, end=<span class=\"hljs-string\">''</span>)\n    <span class=\"hljs-built_in\">print</span>()</code></pre>\n<p>It prints string values in green, zero bytes in red, and everything else as hexadecimal numbers in white. In groups of 4 bytes:</p>\n<p><img src=\"/content/idx_hex_view.png\" alt=\"Hex view\" title=\"HEX view of head of WR.idx file\"></p>\n<p>Grouping by 4 bytes helps the most. From there you see that after the name of the file there are two repeating groups of 4 bytes. For example after <code>wr.ini</code> - <code>840F 0 0</code> and again <code>840F 0 0</code>. After <code>repairsmall.nif</code> - <code>A7 8 0 0</code>. I checked - size of file with that wrench is 14503 bytes, which is <code>0x38A7</code> in hex or <code>A7 38 00 00</code> in little-endian format. That <code>8</code> is green, which means ASCII, and ASCII code of character '8' is  56 or 38 in hex.</p>\n<p>Filenames end with byte <code>0</code> , like proper C strings, but if position of next byte is not divisible by 4, more zero bytes are added for padding. That explains small variations in distances between filenames and offsets of offsets.</p>\n<p>After that two fields, goes another unknown 32-bit field, and then 32-bit offset of file. Then another unknown 4 bytes, and then 8 zero bytes. Or we could look at that from the other point of view, and say that each filename record starts from 8 zero bytes. Directory names also seems to be prefixed by 8 zero bytes. Apart from that, they seem to contain 8 bytes of data. Some of that bytes probably should be number of directories.</p>\n<p>Since first string in index after the header seems to be file, some values preceding it are probably data for the root directory. Maybe <code>2</code> is number of objects in the root directory? <code>wr.ini</code> and <code>data</code>? Otherwise it's <code>01 008 0</code>, which corresponds to <code>524289</code> and seems too much.</p>\n<h3 id=\"trying-to-unpack\">Trying to unpack</h3>\n<p>To summarize file structure:</p>\n<ol>\n<li>Header: 48 bytes</li>\n<li>int32 - number of items in root folder</li>\n<li>Then items</li>\n</ol>\n<p>Each item:</p>\n<ol>\n<li>1 byte - 1 = file, 0 - folder</li>\n<li>3 unknown bytes</li>\n<li>8 zeroes</li>\n<li>Name, null-terminated string, padded with zero bytes to have total length a multiple of 4</li>\n<li>Fields, depending on type</li>\n</ol>\n<p>Fields for file:</p>\n<ol>\n<li>int32 - size</li>\n<li>int32 - size again, same value</li>\n<li>int32 - unknown</li>\n<li>int32 - offset</li>\n</ol>\n<p>Fields for folder:</p>\n<ol>\n<li>int32 - number of items</li>\n</ol>\n<p>Here is code to read structure like this:</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">IdxReader</span>():\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, filename</span>):\n        self.file = <span class=\"hljs-built_in\">open</span>(filename, <span class=\"hljs-string\">'rb'</span>)\n        self.file.seek(<span class=\"hljs-number\">48</span>) <span class=\"hljs-comment\"># skip header</span>\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">read_int</span>(<span class=\"hljs-params\">self</span>):\n        data = self.file.read(<span class=\"hljs-number\">4</span>)\n        decoded = struct.unpack(<span class=\"hljs-string\">'&#x3C;l'</span>, data) <span class=\"hljs-comment\"># unpack it as little-endian int</span>\n        <span class=\"hljs-keyword\">return</span> decoded[<span class=\"hljs-number\">0</span>]\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">read_string</span>(<span class=\"hljs-params\">self</span>):\n        res = []\n        <span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">True</span>:\n            c = self.file.read(<span class=\"hljs-number\">1</span>)[<span class=\"hljs-number\">0</span>]\n            <span class=\"hljs-keyword\">if</span> c == <span class=\"hljs-number\">0</span>:\n                pad = self.file.tell() % <span class=\"hljs-number\">4</span>\n                <span class=\"hljs-keyword\">if</span> pad > <span class=\"hljs-number\">0</span>:\n                    self.file.read(<span class=\"hljs-number\">4</span> - pad)\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">''</span>.join(res)\n            res.append(<span class=\"hljs-built_in\">chr</span>(c))\n        <span class=\"hljs-keyword\">return</span> res\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">read_item</span>(<span class=\"hljs-params\">self</span>):\n        is_file = self.file.read(<span class=\"hljs-number\">1</span>)[<span class=\"hljs-number\">0</span>] <span class=\"hljs-comment\"># type of item</span>\n        self.file.read(<span class=\"hljs-number\">3</span>) <span class=\"hljs-comment\"># unknown bytes</span>\n        self.file.read(<span class=\"hljs-number\">8</span>) <span class=\"hljs-comment\"># zeroes</span>\n        name = self.read_string()\n        <span class=\"hljs-built_in\">print</span>(name)\n        <span class=\"hljs-keyword\">if</span> is_file == <span class=\"hljs-number\">1</span>:\n            size, offset = self.read_file_fields()\n            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">'\\tfile'</span>, size, offset)\n        <span class=\"hljs-keyword\">else</span>:\n            self.read_folder()\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">read_folder</span>(<span class=\"hljs-params\">self</span>):\n        n = self.read_int()\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">'\\tfolder'</span>, n)\n        res = []\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n):\n            entry = self.read_item()\n            res.append(entry)\n        <span class=\"hljs-keyword\">return</span> res\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">read_file_fields</span>(<span class=\"hljs-params\">self</span>):\n        data = self.file.read(<span class=\"hljs-number\">16</span>)\n        size1, size2, offset = struct.unpack(<span class=\"hljs-string\">'&#x3C;llxxxxl'</span>, data)\n        <span class=\"hljs-keyword\">assert</span> size1 == size2\n        <span class=\"hljs-keyword\">return</span> size1, offset\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__enter__</span>(<span class=\"hljs-params\">self</span>):\n        <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-string\">'root'</span>, self.read_folder())\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__exit__</span>(<span class=\"hljs-params\">self, <span class=\"hljs-built_in\">type</span>, value, traceback</span>):\n        self.file.close()</code></pre>\n<p>It fails, because data for file <code>b_lights.nif</code> have additional 4 bytes.  I suspect this is because before that, unknown field between size and offset had value 1, and for this file it is 2. Probably that means additional fields.</p>\n<p>After fixing that, by replacing method <code>read_file_fields</code> with</p>\n<pre><code class=\"hljs language-python\">        data = self.file.read(<span class=\"hljs-number\">16</span>)\n        size1, size2, pad, offset = struct.unpack(<span class=\"hljs-string\">'&#x3C;llll'</span>, data)\n        self.file.read((pad - <span class=\"hljs-number\">1</span>) * <span class=\"hljs-number\">4</span>) <span class=\"hljs-comment\"># skip some unknown values</span>\n        <span class=\"hljs-keyword\">return</span> size1, offset</code></pre>\n<p><code>.idx</code> file seems to be read without problems.</p>\n<h2 id=\"unpacking-archive\">Unpacking archive</h2>\n<p>I put the final code of unpacker in <a href=\"https://gist.github.com/bunyk/f17e991cd9566b7fe6dc82ff2d5f9992\">this gist</a>, to not overload the post with code.</p>\n<p>Only the models from <code>data/nif</code> folder are loading in Blender, models from <code>tracks</code> and <code>vehicle</code> folder crash it, or give error like this:</p>\n<pre><code>Executing - Niftools : Blender Niftools Addon v0.0.13(running on Blender 2.82 (sub 7), PyFFI 2.2.4.dev3)\nImporting /home/tbunyk/projects/lrwc/unpacked/data/vehicle/b_cop01.nif\nNIF file version: 4020100\nReading file\nGame set to 'DARK_AGE_OF_CAMELOT', but multiple games qualified\nImporting data\nScale Correction set to 0.10000000149011612\nSkipped unsupported root block type '&#x3C;struct 'NiPixelData'>' (corrupted nif?).\nFinished\n</code></pre>\n<p>Probably I need to debug Blender Niftools Addon, or maybe check if there is open ticket about this, but that would be another story.</p>\n<h2 id=\"see-also\">See also</h2>\n<ul>\n<li><a href=\"http://wiki.xentax.com/index.php/DGTEFF\">THE DEFINITIVE GUIDE TO EXPLORING FILE FORMATS</a> - provided a lot of helpful advice. For example it said that strings could be padded, so values align, which nudged me display bytes in groups of 4.</li>\n</ul>"},"__N_SSG":true}