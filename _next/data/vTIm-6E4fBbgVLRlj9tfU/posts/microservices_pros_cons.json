{"pageProps":{"post":{"id":"microservices_pros_cons","title":"To split or not to split? What are microservices and should you use them.","date":"2021-01-08","tags":["notes"],"excerpt":"<p>Notes from reading early 2nd edition release of book <strong>Building Microservices</strong> by <em>Sam Newman</em>.</p>","content":"<p>Notes from reading early 2nd edition release of book <strong>Building Microservices</strong> by <em>Sam Newman</em>.</p>\n<h2>Microservices</h2>\n<p><strong>Microservices</strong> are independently releasable services modelled around business domain. <strong>Services</strong> are programs that encapsulate some functionality and make it available to other services over network.</p>\n<p>There is related concept of Service Oriented Architecture (SOA). Microservices is one of the approaches to SOA in the same way as Scrum is one of the Agile approaches to development. In SOA you have multiple services that collaborate with each other, but they are not necessary independently deployable. For microservices independent deployment is a must.</p>\n<p>Independent deployment means that you could deploy your microservices without having to deploy any other service. This could be achieved by designing service boundaries properly.</p>\n<p>To have proper boundaries, you should model your services around business domain, so the changes that involve different services become less likely.</p>\n<p>Popular 3-layer architecture of front-end (UI), back-end (business logic) and storage (Database), is contrast to this, because most of the time adding some new feature involves changing each layer. For example to display new field, it needs to be added to UI, to back-end for processing, and to database schema. But this architecture is so popular because of Conway's law: \"Any organization that designs a system will produce a design whose structure is a copy of the organization's communication structure\", and the fact that organisations often had developers grouped into departments by their qualification - database administration, UI design, etc... Instead it's better to build around business departments - warehouse, sales, accounting, etc...</p>\n<p>From the outside of the service boundary microservice should look like a black box. It should hide as much information as possible and share as little as possible. Information could be shared by API endpoints or messages in message queues. Each microservice should own their own state. Sharing single database between different microservices is a big no no. This is intended to make changing internal implementation very easy, and is similar to concept of encapsulation in OOP.</p>\n<p>What size should microservices be? Well, small, so they could be easily understood, but there is no exact measure. Size should depend on purpose and architecture and is not very important concern.</p>\n<p>Microservices require some supporting tech:</p>\n<ul>\n<li>Log aggregation</li>\n<li>Distributed tracing</li>\n<li>Containers and orchestration</li>\n<li>Streaming (event queues)</li>\n<li>Cloud infrastructure</li>\n</ul>\n<h2>Monoliths</h2>\n<p><strong>Monolith</strong> is opposite concept - anything that is not independently deployed. Monolith could be implemented in many ways: it could be developed as single application, it could be built from multiple independently developed modules or it could be <strong>distributed monolith</strong>: bunch of services that does not share code, and could be located on different hosts but still have to be de deployed together.</p>\n<p>Contrary to popular opinion that monolith is a bad thing and often associated with legacy, it is not legacy. Actually, it should be default choice, and you should have reasons to not use monolith.</p>\n<p>Monoliths have lots of serious advantages, like simplicity, avoiding problems of distributed systems, better code reuse inside monolith (if you need function, you just call it, no need for copy-paste or creating external library).</p>\n<h2>How to choose?</h2>\n<h3>Advantages of microservices</h3>\n<p>You should use microservices if you want to allow developers independently work on their parts of the software, so they don't get in each ones way. One developer could want to do a deployment to fix a bug, but other could want to wait with deployment, because there is unfixed bug in master branch that needs to be fixed first. If you have company with hundreds of employees, you should definitely consider them.</p>\n<ul>\n<li>They allow <strong>heterogenity</strong>. You will not be constrained by one language or framework.</li>\n<li><strong>Robustness</strong>. Failure of one microservices should cause less harm than failure of whole monolith and not bring system down.</li>\n<li><strong>Precise scallability</strong>. You scale only what needs to be scaled. If you see that you need more performance, you could start more instances of the service that is bottleneck, and not deploy whole app couple of times.</li>\n<li><strong>Faster deployment</strong>. Deploying one-line change in million-code app will take more time and resources than in small microservice.</li>\n</ul>\n<h3>Pain points</h3>\n<p>You should better not use microservices for new products and in startups where domain is not yet precisely defined and could quickly change. If your team consists only from 5 people, you definitely don't need them.</p>\n<ul>\n<li><strong>More overhead work</strong> to develop and support microservices.</li>\n<li>Problems with <strong>data consistency</strong></li>\n<li><strong>Techology overload</strong></li>\n<li><strong>Hard to develop</strong>. You will no longer be able to run whole system on your local machine.</li>\n<li><strong>Hard to do reporting</strong> and queries across data in different services.</li>\n<li><strong>Hard to troubleshoot and monitor</strong>. To find failure in a system you will need to look into multiple services.</li>\n<li><strong>Hard to test</strong>. It is hard to create fixtures and environment to run system test. Often false positives would be caused by configuration of test environment.</li>\n<li><strong>Increased latency</strong>. What before would have been call to a function or reading a RAM, now would be a network request, which significantly slows things down.</li>\n</ul>"},"archives":[{"url":"/month/2021-10/page/1","id":"2021-10","count":1,"title":"2021-10"},{"url":"/month/2021-01/page/1","id":"2021-01","count":4,"title":"2021-01"},{"url":"/month/2020-12/page/1","id":"2020-12","count":1,"title":"2020-12"},{"url":"/month/2020-09/page/1","id":"2020-09","count":2,"title":"2020-09"},{"url":"/month/2020-08/page/1","id":"2020-08","count":2,"title":"2020-08"},{"url":"/month/2020-07/page/1","id":"2020-07","count":10,"title":"2020-07"},{"url":"/month/2020-06/page/1","id":"2020-06","count":7,"title":"2020-06"},{"url":"/month/2018-12/page/1","id":"2018-12","count":1,"title":"2018-12"}],"topics":[{"url":"/tag/MOOC/page/1","id":"MOOC","title":"MOOC","count":2},{"url":"/tag/SICP/page/1","id":"SICP","title":"SICP","count":20},{"url":"/tag/asm/page/1","id":"asm","title":"asm","count":1},{"url":"/tag/ideas/page/1","id":"ideas","title":"ideas","count":1},{"url":"/tag/notes/page/1","id":"notes","title":"notes","count":6},{"url":"/tag/on writing/page/1","id":"on writing","title":"on writing","count":3}]},"__N_SSG":true}