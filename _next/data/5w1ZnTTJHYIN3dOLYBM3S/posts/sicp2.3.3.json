{"pageProps":{"id":"sicp2.3.3","title":"SICP 2.3.3 Representing sets","date":"2020-07-28T21:59:22.000Z","tags":["SICP"],"updated_at":"2021-04-20T00:38:16+02:00","content":"<p>This was more boring in comparison to previous section, probably because it required writing less code, and just writing more explanations. Writing is thinking, so I tried to do that. Or maybe it was boring because sets are not as exciting as symbolic differentiation. At least when you have high level language.</p>\n<h2>Exercise 2.59</h2>\n<pre><code class=\"hljs language-scheme\">(<span class=\"hljs-name\"><span class=\"hljs-built_in\">define</span></span> (<span class=\"hljs-name\">element-of-set?</span> x set)\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cond</span></span> ((<span class=\"hljs-name\"><span class=\"hljs-built_in\">null?</span></span> set) false)\n        ((<span class=\"hljs-name\"><span class=\"hljs-built_in\">equal?</span></span> x (<span class=\"hljs-name\"><span class=\"hljs-built_in\">car</span></span> set)) true)\n        (<span class=\"hljs-name\"><span class=\"hljs-built_in\">else</span></span> (<span class=\"hljs-name\">element-of-set?</span> x (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cdr</span></span> set)))))\n\n(<span class=\"hljs-name\"><span class=\"hljs-built_in\">define</span></span> (<span class=\"hljs-name\">adjoin-set</span> x set)\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">if</span></span> (<span class=\"hljs-name\">element-of-set?</span> x set)\n      set\n      (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cons</span></span> x set)))\n\n(<span class=\"hljs-name\"><span class=\"hljs-built_in\">define</span></span> (<span class=\"hljs-name\">union-set</span> set1 set2)\n  (<span class=\"hljs-name\">fold-left</span>\n    (<span class=\"hljs-name\"><span class=\"hljs-built_in\">lambda</span></span> (union next) (<span class=\"hljs-name\">adjoin-set</span> next union))\n    set1\n    set2\n  )\n)</code></pre>\n<h2>Exercise 2.60</h2>\n<pre><code class=\"hljs language-scheme\">(<span class=\"hljs-name\"><span class=\"hljs-built_in\">define</span></span> (<span class=\"hljs-name\">element-of-set?</span> x set)\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cond</span></span> ((<span class=\"hljs-name\"><span class=\"hljs-built_in\">null?</span></span> set) false)\n        ((<span class=\"hljs-name\"><span class=\"hljs-built_in\">equal?</span></span> x (<span class=\"hljs-name\"><span class=\"hljs-built_in\">car</span></span> set)) true)\n        (<span class=\"hljs-name\"><span class=\"hljs-built_in\">else</span></span> (<span class=\"hljs-name\">element-of-set?</span> x (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cdr</span></span> set)))))</code></pre>\n<p>O(n), as unique one, but here list could be way longer, so less performant.</p>\n<pre><code class=\"hljs language-scheme\">(<span class=\"hljs-name\"><span class=\"hljs-built_in\">define</span></span> (<span class=\"hljs-name\">adjoin-set</span> x set)\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cons</span></span> x set)\n)</code></pre>\n<p>O(1), lot better than unique one ( O(n)), because we not checking uniqueness.</p>\n<pre><code class=\"hljs language-scheme\">(<span class=\"hljs-name\"><span class=\"hljs-built_in\">define</span></span> (<span class=\"hljs-name\">union-set</span> set1 set2)\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">append</span></span> set1 set2)\n)</code></pre>\n<p>Append has complexity O(n) = O(len(set1)) if I'm not mistaken. O(n), better than O(n2).</p>\n<pre><code class=\"hljs language-scheme\">(<span class=\"hljs-name\"><span class=\"hljs-built_in\">define</span></span> (<span class=\"hljs-name\">intersection-set</span> set1 set2)\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cond</span></span> ((<span class=\"hljs-name\"><span class=\"hljs-built_in\">or</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">null?</span></span> set1) (<span class=\"hljs-name\"><span class=\"hljs-built_in\">null?</span></span> set2)) '())\n        ((<span class=\"hljs-name\">element-of-set?</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">car</span></span> set1) set2)        \n         (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cons</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">car</span></span> set1)\n               (<span class=\"hljs-name\">intersection-set</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cdr</span></span> set1) set2)))\n        (<span class=\"hljs-name\"><span class=\"hljs-built_in\">else</span></span> (<span class=\"hljs-name\">intersection-set</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cdr</span></span> set1) set2))))</code></pre>\n<p>Intersection has same implementation and as a result same asymptotic complexity O(n2), but we expect n to be a lot larger.</p>\n<p>So, this approach would suit applications where we will do a lot of adjoins and unions, and not much checking for element or intersections.</p>\n<h2>Exercise 2.61</h2>\n<pre><code class=\"hljs language-scheme\">(<span class=\"hljs-name\"><span class=\"hljs-built_in\">define</span></span> (<span class=\"hljs-name\">adjoin-set</span> x set)\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cond</span></span> ((<span class=\"hljs-name\"><span class=\"hljs-built_in\">or</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">null?</span></span> set) (<span class=\"hljs-name\"><span class=\"hljs-built_in\">&#x3C;</span></span> x (<span class=\"hljs-name\"><span class=\"hljs-built_in\">car</span></span> set))) (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cons</span></span> x set))\n        ((<span class=\"hljs-name\"><span class=\"hljs-built_in\">=</span></span> x (<span class=\"hljs-name\"><span class=\"hljs-built_in\">car</span></span> set)) set)\n        (<span class=\"hljs-name\"><span class=\"hljs-built_in\">else</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cons</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">car</span></span> set) (<span class=\"hljs-name\">adjoin-set</span> x (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cdr</span></span> set))))))\n\n(<span class=\"hljs-name\">adjoin-set</span> <span class=\"hljs-number\">0</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">list</span></span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">3</span>))\n(<span class=\"hljs-name\">adjoin-set</span> <span class=\"hljs-number\">1</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">list</span></span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">3</span>))\n(<span class=\"hljs-name\">adjoin-set</span> <span class=\"hljs-number\">2</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">list</span></span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">3</span>))\n(<span class=\"hljs-name\">adjoin-set</span> <span class=\"hljs-number\">4</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">list</span></span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">3</span>))</code></pre>\n<h2>Exercise 2.62</h2>\n<pre><code class=\"hljs language-scheme\">(<span class=\"hljs-name\"><span class=\"hljs-built_in\">define</span></span> (<span class=\"hljs-name\">union-set</span> set1 set2)\n    (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cond</span></span>\n        ((<span class=\"hljs-name\"><span class=\"hljs-built_in\">null?</span></span> set1) set2)\n        ((<span class=\"hljs-name\"><span class=\"hljs-built_in\">null?</span></span> set2) set1)\n        ((<span class=\"hljs-name\"><span class=\"hljs-built_in\">&#x3C;</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">car</span></span> set1) (<span class=\"hljs-name\"><span class=\"hljs-built_in\">car</span></span> set2)) (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cons</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">car</span></span> set1) (<span class=\"hljs-name\">union-set</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cdr</span></span> set1) set2)))\n        (<span class=\"hljs-name\"><span class=\"hljs-built_in\">else</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cons</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">car</span></span> set2) (<span class=\"hljs-name\">union-set</span> set1 (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cdr</span></span> set2))))\n    )\n)\n(<span class=\"hljs-name\">union-set</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">list</span></span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span>) (<span class=\"hljs-name\"><span class=\"hljs-built_in\">list</span></span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span>))\n(<span class=\"hljs-name\">union-set</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">list</span></span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span>) (<span class=\"hljs-name\"><span class=\"hljs-built_in\">list</span></span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">4</span>))</code></pre>\n<h2>Exercise 2.63</h2>\n<p>a. Yes, they give same results by traversing tree from left to right.</p>\n<p>b. One without <code>append</code> is better. For the second one <code>copy-to-list</code> is called for right subtree first, and then process conses current tree entry to result, then <code>copy-to-list</code> is called recursively to cons left subtree to the resulting list.</p>\n<p>In case with append, we compute <code>tree->list1</code> for both subtrees simultaniously, then iterate over result for left subtree inside <code>append</code>.  Append takes O(n) time, where n is length of left argument. It is processing half of nodes in each level in the tree, which is approximately O(n log(n)).</p>\n<h2>Exercise 2.64</h2>\n<pre><code class=\"hljs language-scheme\">(<span class=\"hljs-name\"><span class=\"hljs-built_in\">define</span></span> (<span class=\"hljs-name\">list->tree</span> elements)\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">car</span></span> (<span class=\"hljs-name\">partial-tree</span> elements (<span class=\"hljs-name\"><span class=\"hljs-built_in\">length</span></span> elements))))\n\n(<span class=\"hljs-name\"><span class=\"hljs-built_in\">define</span></span> (<span class=\"hljs-name\">partial-tree</span> elts n)\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">=</span></span> n <span class=\"hljs-number\">0</span>)\n      (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cons</span></span> '() elts)\n      (<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> ((<span class=\"hljs-name\">left-size</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">quotient</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">-</span></span> n <span class=\"hljs-number\">1</span>) <span class=\"hljs-number\">2</span>)))\n        (<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> ((<span class=\"hljs-name\">left-result</span> (<span class=\"hljs-name\">partial-tree</span> elts left-size)))\n          (<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> ((<span class=\"hljs-name\">left-tree</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">car</span></span> left-result))\n                (<span class=\"hljs-name\">non-left-elts</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cdr</span></span> left-result))\n                (<span class=\"hljs-name\">right-size</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">-</span></span> n (<span class=\"hljs-name\"><span class=\"hljs-built_in\">+</span></span> left-size <span class=\"hljs-number\">1</span>))))\n            (<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> ((<span class=\"hljs-name\">this-entry</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">car</span></span> non-left-elts))\n                  (<span class=\"hljs-name\">right-result</span> (<span class=\"hljs-name\">partial-tree</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cdr</span></span> non-left-elts)\n                                              right-size)))\n              (<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> ((<span class=\"hljs-name\">right-tree</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">car</span></span> right-result))\n                    (<span class=\"hljs-name\">remaining-elts</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cdr</span></span> right-result)))\n                (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cons</span></span> (<span class=\"hljs-name\">make-tree</span> this-entry left-tree right-tree)\n                      remaining-elts))))))))</code></pre>\n<p><code>partial-tree</code> takes as arguments <code>elts</code> - list of elements, and integer <code>n</code> and returns pair whose <code>car</code> is balanced tree containing the first <code>n</code> elements of the list and <code>cdr</code> is the list of elements not included in the tree.</p>\n<p>If we need to construct tree with 0 elements, we just return empty tree and list provided to us. Otherwise, we will have tree with one element in root, and subtrees. Size of subtrees will be (n-1) / 2 (remaining amount of elements appriximately equally split for each subtree). First we build left subtree and obtain remaining elements. First of the remaining elements goes into root of our tree, the rest - to building right subtree. After we have both subtrees attached to tree with root element, we return it, and what was left in list of elements from building right subtree.</p>\n<p>So, when we have list <code>(1 3 5 7 9 11)</code>, we will have following tree:</p>\n<pre><code>(5\n    (1\n        ()\n        (3 () ())\n    )\n    (9\n        (7 () ())\n        (11 () ())\n    )\n)\n</code></pre>\n<p>b. What is the order of growth in the number of steps required by list->tree to convert a list of n elements?</p>\n<p>partial-tree is called once for n = 0. For n > 0, it is called X(n), where X(n) = 2 + X( (n-1) / 2) + X(n - 1 - (n-1)/2 = (n-1)/2) => X(n) = 2 + X((n-1)/2). If X is identity function - equation is true, so X(n) = n. Order of growth is linear.</p>\n<h2>Exercise 2.65</h2>\n<p>Finally coding and not writing essays. I'm bad at essays (probably need another textbook on this topic, but how to test myself?)</p>\n<p>I imagine we convert both trees to ordered lists, then use operations on ordered lists described in previous section, then convert back to trees. All of this operations take O(n).</p>\n<pre><code class=\"hljs language-scheme\">(<span class=\"hljs-name\"><span class=\"hljs-built_in\">define</span></span> (<span class=\"hljs-name\">union-set</span> s1 s2)\n  (<span class=\"hljs-name\">list->tree</span> (<span class=\"hljs-name\">list-union-set</span> (<span class=\"hljs-name\">tree->list2</span> s1) (<span class=\"hljs-name\">tree->list2</span>)))\n)</code></pre>\n<p>Same for intersection, just call different function. I'm even not going to test this code, as it will be more effort than writing it.</p>\n<h2>Exercise 2.66</h2>\n<pre><code class=\"hljs language-scheme\">(<span class=\"hljs-name\"><span class=\"hljs-built_in\">define</span></span> (<span class=\"hljs-name\">lookup</span> given-key set-of-records)\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cond</span></span> ((<span class=\"hljs-name\"><span class=\"hljs-built_in\">null?</span></span> set-of-records) false)\n        ((<span class=\"hljs-name\"><span class=\"hljs-built_in\">=</span></span> given-key (<span class=\"hljs-name\">key</span> (<span class=\"hljs-name\">entry</span> set-of-records)))\n         (<span class=\"hljs-name\">entry</span> set-of-records))\n        ((<span class=\"hljs-name\"><span class=\"hljs-built_in\">&#x3C;</span></span> given-key (<span class=\"hljs-name\">key</span> (<span class=\"hljs-name\">entry</span> set-of-records)))\n         (<span class=\"hljs-name\">lookup</span> (<span class=\"hljs-name\">left-branch</span> set-of-records)))\n        (<span class=\"hljs-name\"><span class=\"hljs-built_in\">else</span></span>\n         (<span class=\"hljs-name\">lookup</span> (<span class=\"hljs-name\">right-branch</span> set-of-records)))))</code></pre>"},"__N_SSG":true}