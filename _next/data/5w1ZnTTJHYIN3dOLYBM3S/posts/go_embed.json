{"pageProps":{"id":"go_embed","title":"Embedding files in Go","date":"2021-11-28T21:08:07.000Z","tags":["go"],"updated_at":"2021-11-28T23:14:56+01:00","content":"<p>Go has a nice property - it compiles to single executable, that could just run. Which does not have depencencies to other packages, does not require runtime or interpreter.</p>\n<p>But many of programs could not be built just in Go, and use multiple of different languages that are better fit for their tasks. For example in web you would probably use a lot of SQL, JavaScript, CSS, HTML, JSON, etc... Even desktop apps could use some embedded XML or GLSL, or even CSS for styling.</p>\n<p><img src=\"/content/yo-dawg-code.jpg\" alt=\"Yo dawg, we heard you like coding\" title=\"Put a language in your language\"></p>\n<p>There are two ways to put such code in your projects: as string literals in Go code, or as separate files. Separate files have advantage of having better modularity, and being more readable (less indentation, and it's easier to highlight file with extension <code>.sql</code> as SQL).</p>\n<p>But text files in project that does not contain Go code have huge disadvantage - they are not included into the executable built by compiler, and need to be loaded during runtime. So you need to add them to Docker image, and distribute docker image instead. Or distribute your program in some other package format, that includes both executable and files.</p>\n<p>Four years ago I have built a package &#x26; tool to fix that problem and embed text files into go executable as strings: <a href=\"https://github.com/bunyk/require\">https://github.com/bunyk/require</a></p>\n<p>In that library you could call <code>require.File(\"filename.txt\")</code>, and it will return content of that file as a string, without actually opening it. There is a <code>hardcode</code> utility that generates go code for each <code>require.File</code> call you have in your codebase to work.</p>\n<p>But today I noticed two interesting lines <a href=\"https://github.com/hismailbulut/neoray/blob/e4baaaf8a09651a4f311a6e50cfb5ed3ec0fae14/src/renderergl.go#L40-L41\">in code of Neoray</a> (My GUI of choice for Neovim):</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-comment\">//go:embed shader.glsl</span>\n<span class=\"hljs-keyword\">var</span> EmbeddedShaderSources <span class=\"hljs-type\">string</span></code></pre>\n<p>Turns out that since Go 1.16, <a href=\"https://go.dev/doc/go1.16#library-embed\">embed functionality is in standard library</a>. Written by Russ Cox and reviewed by Rob Pike (<a href=\"https://cs.opensource.google/go/go/+/400581b8b008ece8d0df34f54f281d365a175dba\">commit</a>). So, obviously it has better design than my package.</p>\n<p>Small downside it has, is that you could use it only with global variables. Using <code>embed</code> directive in function gave me <code>cannot apply to var inside func</code> compilation error. And it does not work with constants, so you need to be careful to not mutate value yourself.</p>\n<p>But, that are not really reasons to not deprecate my library. To quote fortune program used as an example:</p>\n<blockquote>\n<p>One of my most productive days was throwing away 1000 lines of code.  â€” Ken Thompson</p>\n</blockquote>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> (\n\t_ <span class=\"hljs-string\">\"embed\"</span>\n\t<span class=\"hljs-string\">\"fmt\"</span>\n\t<span class=\"hljs-string\">\"math/rand\"</span>\n\t<span class=\"hljs-string\">\"strings\"</span>\n\t<span class=\"hljs-string\">\"time\"</span>\n)\n\n<span class=\"hljs-comment\">//go:embed fortunes.txt</span>\n<span class=\"hljs-keyword\">const</span> contents <span class=\"hljs-type\">string</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\tfortunes := strings.Split(contents, <span class=\"hljs-string\">\"\\n\"</span>)\n\n\trand.Seed(time.Now().UTC().UnixNano())\n\n\tfmt.Println(fortunes[rand.Intn(<span class=\"hljs-built_in\">len</span>(fortunes))])\n}</code></pre>"},"__N_SSG":true}